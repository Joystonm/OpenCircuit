import {
  zodToJsonSchema
} from "./chunk-EPS5PXLD.js";
import {
  $ZodAny,
  $ZodArray,
  $ZodBase64,
  $ZodBase64URL,
  $ZodBigInt,
  $ZodBigIntFormat,
  $ZodBoolean,
  $ZodCIDRv4,
  $ZodCIDRv6,
  $ZodCUID,
  $ZodCUID2,
  $ZodCatch,
  $ZodCheck,
  $ZodCustom,
  $ZodCustomStringFormat,
  $ZodDate,
  $ZodDefault,
  $ZodDiscriminatedUnion,
  $ZodE164,
  $ZodEmail,
  $ZodEmoji,
  $ZodEnum,
  $ZodError,
  $ZodFile,
  $ZodGUID,
  $ZodIPv4,
  $ZodIPv6,
  $ZodISODate,
  $ZodISODateTime,
  $ZodISODuration,
  $ZodISOTime,
  $ZodIntersection,
  $ZodJWT,
  $ZodKSUID,
  $ZodLazy,
  $ZodLiteral,
  $ZodMap,
  $ZodNaN,
  $ZodNanoID,
  $ZodNever,
  $ZodNonOptional,
  $ZodNull,
  $ZodNullable,
  $ZodNumber,
  $ZodNumberFormat,
  $ZodObject,
  $ZodOptional,
  $ZodPipe,
  $ZodPrefault,
  $ZodPromise,
  $ZodReadonly,
  $ZodRecord,
  $ZodSet,
  $ZodString,
  $ZodStringFormat,
  $ZodSuccess,
  $ZodSymbol,
  $ZodTemplateLiteral,
  $ZodTransform,
  $ZodTuple,
  $ZodType,
  $ZodULID,
  $ZodURL,
  $ZodUUID,
  $ZodUndefined,
  $ZodUnion,
  $ZodUnknown,
  $ZodVoid,
  $ZodXID,
  $brand,
  $constructor,
  $input,
  $output,
  NEVER,
  TimePrecision,
  _any,
  _array,
  _base64,
  _base64url,
  _bigint,
  _boolean,
  _cidrv4,
  _cidrv6,
  _coercedBigint,
  _coercedBoolean,
  _coercedDate,
  _coercedNumber,
  _coercedString,
  _cuid,
  _cuid2,
  _custom,
  _date,
  _e164,
  _email,
  _emoji,
  _endsWith,
  _file,
  _float32,
  _float64,
  _function,
  _gt,
  _gte,
  _guid,
  _includes,
  _int,
  _int32,
  _int64,
  _ipv4,
  _ipv6,
  _isoDate,
  _isoDateTime,
  _isoDuration,
  _isoTime,
  _jwt,
  _ksuid,
  _length,
  _lowercase,
  _lt,
  _lte,
  _maxLength,
  _maxSize,
  _mime,
  _minLength,
  _minSize,
  _multipleOf,
  _nan,
  _nanoid,
  _negative,
  _never,
  _nonnegative,
  _nonpositive,
  _normalize,
  _null,
  _number,
  _overwrite,
  _parse,
  _parseAsync,
  _positive,
  _property,
  _refine,
  _regex,
  _safeParse,
  _safeParseAsync,
  _size,
  _startsWith,
  _string,
  _stringFormat,
  _stringbool,
  _symbol,
  _toLowerCase,
  _toUpperCase,
  _trim,
  _uint32,
  _uint64,
  _ulid,
  _undefined,
  _unknown,
  _uppercase,
  _url,
  _uuid,
  _uuidv4,
  _uuidv6,
  _uuidv7,
  _void,
  _xid,
  clone,
  config,
  core_exports,
  en_default,
  flattenError,
  formatError,
  globalRegistry,
  locales_exports,
  parse,
  parseAsync,
  prettifyError,
  regexes_exports,
  registry,
  safeParse,
  safeParseAsync,
  toJSONSchema,
  treeifyError,
  util_exports
} from "./chunk-CGYA4UZO.js";
import {
  loadVendor,
  toJsonSchema
} from "./chunk-ZCCKF5ZT.js";
import {
  require_jsx_runtime
} from "./chunk-CRNJR6QK.js";
import {
  require_react
} from "./chunk-ZMLY2J2T.js";
import {
  external_exports
} from "./chunk-RHOT5UXY.js";
import {
  __commonJS,
  __esm,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __toCommonJS,
  __toESM
} from "./chunk-4B2QHNJT.js";

// node_modules/partial-json/dist/options.js
var require_options = __commonJS({
  "node_modules/partial-json/dist/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Allow = exports.ALL = exports.COLLECTION = exports.ATOM = exports.SPECIAL = exports.INF = exports._INFINITY = exports.INFINITY = exports.NAN = exports.BOOL = exports.NULL = exports.OBJ = exports.ARR = exports.NUM = exports.STR = void 0;
    exports.STR = 1;
    exports.NUM = 2;
    exports.ARR = 4;
    exports.OBJ = 8;
    exports.NULL = 16;
    exports.BOOL = 32;
    exports.NAN = 64;
    exports.INFINITY = 128;
    exports._INFINITY = 256;
    exports.INF = exports.INFINITY | exports._INFINITY;
    exports.SPECIAL = exports.NULL | exports.BOOL | exports.INF | exports.NAN;
    exports.ATOM = exports.STR | exports.NUM | exports.SPECIAL;
    exports.COLLECTION = exports.ARR | exports.OBJ;
    exports.ALL = exports.ATOM | exports.COLLECTION;
    exports.Allow = { STR: exports.STR, NUM: exports.NUM, ARR: exports.ARR, OBJ: exports.OBJ, NULL: exports.NULL, BOOL: exports.BOOL, NAN: exports.NAN, INFINITY: exports.INFINITY, _INFINITY: exports._INFINITY, INF: exports.INF, SPECIAL: exports.SPECIAL, ATOM: exports.ATOM, COLLECTION: exports.COLLECTION, ALL: exports.ALL };
    exports.default = exports.Allow;
  }
});

// node_modules/partial-json/dist/index.js
var require_dist = __commonJS({
  "node_modules/partial-json/dist/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Allow = exports.MalformedJSON = exports.PartialJSON = exports.parseJSON = exports.parse = void 0;
    var options_1 = require_options();
    Object.defineProperty(exports, "Allow", { enumerable: true, get: function() {
      return options_1.Allow;
    } });
    __exportStar(require_options(), exports);
    var PartialJSON = class extends Error {
    };
    exports.PartialJSON = PartialJSON;
    var MalformedJSON = class extends Error {
    };
    exports.MalformedJSON = MalformedJSON;
    function parseJSON(jsonString, allowPartial = options_1.Allow.ALL) {
      if (typeof jsonString !== "string") {
        throw new TypeError(`expecting str, got ${typeof jsonString}`);
      }
      if (!jsonString.trim()) {
        throw new Error(`${jsonString} is empty`);
      }
      return _parseJSON(jsonString.trim(), allowPartial);
    }
    exports.parseJSON = parseJSON;
    var _parseJSON = (jsonString, allow) => {
      const length = jsonString.length;
      let index = 0;
      const markPartialJSON = (msg) => {
        throw new PartialJSON(`${msg} at position ${index}`);
      };
      const throwMalformedError = (msg) => {
        throw new MalformedJSON(`${msg} at position ${index}`);
      };
      const parseAny = () => {
        skipBlank();
        if (index >= length)
          markPartialJSON("Unexpected end of input");
        if (jsonString[index] === '"')
          return parseStr();
        if (jsonString[index] === "{")
          return parseObj();
        if (jsonString[index] === "[")
          return parseArr();
        if (jsonString.substring(index, index + 4) === "null" || options_1.Allow.NULL & allow && length - index < 4 && "null".startsWith(jsonString.substring(index))) {
          index += 4;
          return null;
        }
        if (jsonString.substring(index, index + 4) === "true" || options_1.Allow.BOOL & allow && length - index < 4 && "true".startsWith(jsonString.substring(index))) {
          index += 4;
          return true;
        }
        if (jsonString.substring(index, index + 5) === "false" || options_1.Allow.BOOL & allow && length - index < 5 && "false".startsWith(jsonString.substring(index))) {
          index += 5;
          return false;
        }
        if (jsonString.substring(index, index + 8) === "Infinity" || options_1.Allow.INFINITY & allow && length - index < 8 && "Infinity".startsWith(jsonString.substring(index))) {
          index += 8;
          return Infinity;
        }
        if (jsonString.substring(index, index + 9) === "-Infinity" || options_1.Allow._INFINITY & allow && 1 < length - index && length - index < 9 && "-Infinity".startsWith(jsonString.substring(index))) {
          index += 9;
          return -Infinity;
        }
        if (jsonString.substring(index, index + 3) === "NaN" || options_1.Allow.NAN & allow && length - index < 3 && "NaN".startsWith(jsonString.substring(index))) {
          index += 3;
          return NaN;
        }
        return parseNum();
      };
      const parseStr = () => {
        const start = index;
        let escape2 = false;
        index++;
        while (index < length && (jsonString[index] !== '"' || escape2 && jsonString[index - 1] === "\\")) {
          escape2 = jsonString[index] === "\\" ? !escape2 : false;
          index++;
        }
        if (jsonString.charAt(index) == '"') {
          try {
            return JSON.parse(jsonString.substring(start, ++index - Number(escape2)));
          } catch (e2) {
            throwMalformedError(String(e2));
          }
        } else if (options_1.Allow.STR & allow) {
          try {
            return JSON.parse(jsonString.substring(start, index - Number(escape2)) + '"');
          } catch (e2) {
            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("\\")) + '"');
          }
        }
        markPartialJSON("Unterminated string literal");
      };
      const parseObj = () => {
        index++;
        skipBlank();
        const obj = {};
        try {
          while (jsonString[index] !== "}") {
            skipBlank();
            if (index >= length && options_1.Allow.OBJ & allow)
              return obj;
            const key = parseStr();
            skipBlank();
            index++;
            try {
              const value = parseAny();
              obj[key] = value;
            } catch (e2) {
              if (options_1.Allow.OBJ & allow)
                return obj;
              else
                throw e2;
            }
            skipBlank();
            if (jsonString[index] === ",")
              index++;
          }
        } catch (e2) {
          if (options_1.Allow.OBJ & allow)
            return obj;
          else
            markPartialJSON("Expected '}' at end of object");
        }
        index++;
        return obj;
      };
      const parseArr = () => {
        index++;
        const arr = [];
        try {
          while (jsonString[index] !== "]") {
            arr.push(parseAny());
            skipBlank();
            if (jsonString[index] === ",") {
              index++;
            }
          }
        } catch (e2) {
          if (options_1.Allow.ARR & allow) {
            return arr;
          }
          markPartialJSON("Expected ']' at end of array");
        }
        index++;
        return arr;
      };
      const parseNum = () => {
        if (index === 0) {
          if (jsonString === "-")
            throwMalformedError("Not sure what '-' is");
          try {
            return JSON.parse(jsonString);
          } catch (e2) {
            if (options_1.Allow.NUM & allow)
              try {
                return JSON.parse(jsonString.substring(0, jsonString.lastIndexOf("e")));
              } catch (e3) {
              }
            throwMalformedError(String(e2));
          }
        }
        const start = index;
        if (jsonString[index] === "-")
          index++;
        while (jsonString[index] && ",]}".indexOf(jsonString[index]) === -1)
          index++;
        if (index == length && !(options_1.Allow.NUM & allow))
          markPartialJSON("Unterminated number literal");
        try {
          return JSON.parse(jsonString.substring(start, index));
        } catch (e2) {
          if (jsonString.substring(start, index) === "-")
            markPartialJSON("Not sure what '-' is");
          try {
            return JSON.parse(jsonString.substring(start, jsonString.lastIndexOf("e")));
          } catch (e3) {
            throwMalformedError(String(e3));
          }
        }
      };
      const skipBlank = () => {
        while (index < length && " \n\r	".includes(jsonString[index])) {
          index++;
        }
      };
      return parseAny();
    };
    var parse4 = parseJSON;
    exports.parse = parse4;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/codegen/code.js
var require_code = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a13;
        return (_a13 = this._str) !== null && _a13 !== void 0 ? _a13 : this._str = this._items.reduce((s, c2) => `${s}${c2}`, "");
      }
      get names() {
        var _a13;
        return (_a13 = this._names) !== null && _a13 !== void 0 ? _a13 : this._names = this._items.reduce((names, c2) => {
          if (c2 instanceof Name)
            names[c2.str] = (names[c2.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a13, _b;
        if (((_b = (_a13 = this._parent) === null || _a13 === void 0 ? void 0 : _a13._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a13;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a13 = value.key) !== null && _a13 !== void 0 ? _a13 : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c2 = valueCode(name);
            if (c2) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c2};${this.opts._n}`;
            } else if (c2 = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c2}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code();
    var scope_1 = require_scope();
    var code_2 = require_code();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n2) => code + n2.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n2 = nodes[i].optimizeNodes();
          if (Array.isArray(n2))
            nodes.splice(i, 1, ...n2);
          else if (n2)
            nodes[i] = n2;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n2 = nodes[i];
          if (n2.optimizeNames(names, constants))
            continue;
          subtractNames(names, n2.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n2) => addNames(names, n2.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e2 = this.else;
        if (e2) {
          const ns = e2.optimizeNodes();
          e2 = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e2) {
          if (cond === false)
            return e2 instanceof _If ? e2 : e2.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e2 instanceof _If ? [e2] : e2.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a13;
        this.else = (_a13 = this.else) === null || _a13 === void 0 ? void 0 : _a13.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a13, _b;
        super.optimizeNodes();
        (_a13 = this.catch) === null || _a13 === void 0 ? void 0 : _a13.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a13, _b;
        super.optimizeNames(names, constants);
        (_a13 = this.catch) === null || _a13 === void 0 ? void 0 : _a13.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c2) {
        if (typeof c2 == "function")
          c2();
        else if (c2 !== code_1.nil)
          this._leafNode(new AnyCode(c2));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n2 = 1) {
        while (n2-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n2 = this._currNode;
        if (n2 instanceof N1 || N2 && n2 instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n2 = this._currNode;
        if (!(n2 instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n2.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) + (from[n2] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c2) => {
        if (c2 instanceof code_1.Name)
          c2 = replaceName(c2);
        if (c2 instanceof code_1._Code)
          items.push(...c2._items);
        else
          items.push(c2);
        return items;
      }, []));
      function replaceName(n2) {
        const c2 = constants[n2.str];
        if (c2 === void 0 || names[n2.str] !== 1)
          return n2;
        delete names[n2.str];
        return c2;
      }
      function canOptimize(e2) {
        return e2 instanceof code_1._Code && e2._items.some((c2) => c2 instanceof code_1.Name && names[c2.str] === 1 && constants[c2.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) - (from[n2] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/util.js
var require_util = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen();
    var code_1 = require_code();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/names.js
var require_names = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/errors.js
var require_errors = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/rules.js
var require_rules = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a13;
      return schema[rule.keyword] !== void 0 || ((_a13 = rule.definition.implements) === null || _a13 === void 0 ? void 0 : _a13.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules();
    var applicability_1 = require_applicability();
    var errors_1 = require_errors();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t2 of coerceTo) {
        if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t2);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t2) {
        switch (t2) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t2 in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t2, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/code.js
var require_code2 = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var names_1 = require_names();
    var util_2 = require_util();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u2 = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u2);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u2})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var code_1 = require_code2();
    var errors_1 = require_errors();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a13;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a13 = def.valid) !== null && _a13 !== void 0 ? _a13 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e2) => gen.assign(valid, false).if((0, codegen_1._)`${e2} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e2}.errors`), () => gen.throw(e2)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a14;
        gen.if((0, codegen_1.not)((_a14 = def.valid) !== null && _a14 !== void 0 ? _a14 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/fast-deep-equal/index.js
var require_fast_deep_equal = __commonJS({
  "node_modules/fast-deep-equal/index.js"(exports, module) {
    "use strict";
    module.exports = function equal(a, b) {
      if (a === b) return true;
      if (a && b && typeof a == "object" && typeof b == "object") {
        if (a.constructor !== b.constructor) return false;
        var length, i, keys2;
        if (Array.isArray(a)) {
          length = a.length;
          if (length != b.length) return false;
          for (i = length; i-- !== 0; )
            if (!equal(a[i], b[i])) return false;
          return true;
        }
        if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
        if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
        if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();
        keys2 = Object.keys(a);
        length = keys2.length;
        if (length !== Object.keys(b).length) return false;
        for (i = length; i-- !== 0; )
          if (!Object.prototype.hasOwnProperty.call(b, keys2[i])) return false;
        for (i = length; i-- !== 0; ) {
          var key = keys2[i];
          if (!equal(a[key], b[key])) return false;
        }
        return true;
      }
      return a !== a && b !== b;
    };
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/resolve.js
var require_resolve = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/index.js
var require_validate = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema();
    var dataType_1 = require_dataType();
    var applicability_1 = require_applicability();
    var dataType_2 = require_dataType();
    var defaults_1 = require_defaults();
    var keyword_1 = require_keyword();
    var subschema_1 = require_subschema();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var errors_1 = require_errors();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t2) => {
        if (!includesType(it.dataTypes, t2)) {
          strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t2) => hasApplicableType(ts, t2))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t2) {
      return ts.includes(t2) || t2 === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t2 of it.dataTypes) {
        if (includesType(withTypes, t2))
          ts.push(t2);
        else if (withTypes.includes("integer") && t2 === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/index.js
var require_compile = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen();
    var validation_error_1 = require_validation_error();
    var names_1 = require_names();
    var resolve_1 = require_resolve();
    var util_1 = require_util();
    var validate_1 = require_validate();
    var SchemaEnv = class {
      constructor(env) {
        var _a13;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a13 = env.baseId) !== null && _a13 !== void 0 ? _a13 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e2) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e2;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a13;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a13 = root.localRefs) === null || _a13 === void 0 ? void 0 : _a13[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a13;
      if (((_a13 = parsedRef.fragment) === null || _a13 === void 0 ? void 0 : _a13[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/refs/data.json
var require_data = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/fast-uri/lib/utils.js
var require_utils = __commonJS({
  "node_modules/fast-uri/lib/utils.js"(exports, module) {
    "use strict";
    var isUUID = RegExp.prototype.test.bind(/^[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}$/iu);
    var isIPv4 = RegExp.prototype.test.bind(/^(?:(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d{2}|[1-9]\d|\d)$/u);
    function stringArrayToHexStripped(input) {
      let acc = "";
      let code = 0;
      let i = 0;
      for (i = 0; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (code === 48) {
          continue;
        }
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
        break;
      }
      for (i += 1; i < input.length; i++) {
        code = input[i].charCodeAt(0);
        if (!(code >= 48 && code <= 57 || code >= 65 && code <= 70 || code >= 97 && code <= 102)) {
          return "";
        }
        acc += input[i];
      }
      return acc;
    }
    var nonSimpleDomain = RegExp.prototype.test.bind(/[^!"$&'()*+,\-.;=_`a-z{}~]/u);
    function consumeIsZone(buffer) {
      buffer.length = 0;
      return true;
    }
    function consumeHextets(buffer, address, output) {
      if (buffer.length) {
        const hex = stringArrayToHexStripped(buffer);
        if (hex !== "") {
          address.push(hex);
        } else {
          output.error = true;
          return false;
        }
        buffer.length = 0;
      }
      return true;
    }
    function getIPV6(input) {
      let tokenCount = 0;
      const output = { error: false, address: "", zone: "" };
      const address = [];
      const buffer = [];
      let endipv6Encountered = false;
      let endIpv6 = false;
      let consume = consumeHextets;
      for (let i = 0; i < input.length; i++) {
        const cursor = input[i];
        if (cursor === "[" || cursor === "]") {
          continue;
        }
        if (cursor === ":") {
          if (endipv6Encountered === true) {
            endIpv6 = true;
          }
          if (!consume(buffer, address, output)) {
            break;
          }
          if (++tokenCount > 7) {
            output.error = true;
            break;
          }
          if (i > 0 && input[i - 1] === ":") {
            endipv6Encountered = true;
          }
          address.push(":");
          continue;
        } else if (cursor === "%") {
          if (!consume(buffer, address, output)) {
            break;
          }
          consume = consumeIsZone;
        } else {
          buffer.push(cursor);
          continue;
        }
      }
      if (buffer.length) {
        if (consume === consumeIsZone) {
          output.zone = buffer.join("");
        } else if (endIpv6) {
          address.push(buffer.join(""));
        } else {
          address.push(stringArrayToHexStripped(buffer));
        }
      }
      output.address = address.join("");
      return output;
    }
    function normalizeIPv6(host) {
      if (findToken(host, ":") < 2) {
        return { host, isIPV6: false };
      }
      const ipv62 = getIPV6(host);
      if (!ipv62.error) {
        let newHost = ipv62.address;
        let escapedHost = ipv62.address;
        if (ipv62.zone) {
          newHost += "%" + ipv62.zone;
          escapedHost += "%25" + ipv62.zone;
        }
        return { host: newHost, isIPV6: true, escapedHost };
      } else {
        return { host, isIPV6: false };
      }
    }
    function findToken(str, token) {
      let ind = 0;
      for (let i = 0; i < str.length; i++) {
        if (str[i] === token) ind++;
      }
      return ind;
    }
    function removeDotSegments(path2) {
      let input = path2;
      const output = [];
      let nextSlash = -1;
      let len = 0;
      while (len = input.length) {
        if (len === 1) {
          if (input === ".") {
            break;
          } else if (input === "/") {
            output.push("/");
            break;
          } else {
            output.push(input);
            break;
          }
        } else if (len === 2) {
          if (input[0] === ".") {
            if (input[1] === ".") {
              break;
            } else if (input[1] === "/") {
              input = input.slice(2);
              continue;
            }
          } else if (input[0] === "/") {
            if (input[1] === "." || input[1] === "/") {
              output.push("/");
              break;
            }
          }
        } else if (len === 3) {
          if (input === "/..") {
            if (output.length !== 0) {
              output.pop();
            }
            output.push("/");
            break;
          }
        }
        if (input[0] === ".") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(3);
              continue;
            }
          } else if (input[1] === "/") {
            input = input.slice(2);
            continue;
          }
        } else if (input[0] === "/") {
          if (input[1] === ".") {
            if (input[2] === "/") {
              input = input.slice(2);
              continue;
            } else if (input[2] === ".") {
              if (input[3] === "/") {
                input = input.slice(3);
                if (output.length !== 0) {
                  output.pop();
                }
                continue;
              }
            }
          }
        }
        if ((nextSlash = input.indexOf("/", 1)) === -1) {
          output.push(input);
          break;
        } else {
          output.push(input.slice(0, nextSlash));
          input = input.slice(nextSlash);
        }
      }
      return output.join("");
    }
    function normalizeComponentEncoding(component, esc) {
      const func = esc !== true ? escape : unescape;
      if (component.scheme !== void 0) {
        component.scheme = func(component.scheme);
      }
      if (component.userinfo !== void 0) {
        component.userinfo = func(component.userinfo);
      }
      if (component.host !== void 0) {
        component.host = func(component.host);
      }
      if (component.path !== void 0) {
        component.path = func(component.path);
      }
      if (component.query !== void 0) {
        component.query = func(component.query);
      }
      if (component.fragment !== void 0) {
        component.fragment = func(component.fragment);
      }
      return component;
    }
    function recomposeAuthority(component) {
      const uriTokens = [];
      if (component.userinfo !== void 0) {
        uriTokens.push(component.userinfo);
        uriTokens.push("@");
      }
      if (component.host !== void 0) {
        let host = unescape(component.host);
        if (!isIPv4(host)) {
          const ipV6res = normalizeIPv6(host);
          if (ipV6res.isIPV6 === true) {
            host = `[${ipV6res.escapedHost}]`;
          } else {
            host = component.host;
          }
        }
        uriTokens.push(host);
      }
      if (typeof component.port === "number" || typeof component.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(component.port));
      }
      return uriTokens.length ? uriTokens.join("") : void 0;
    }
    module.exports = {
      nonSimpleDomain,
      recomposeAuthority,
      normalizeComponentEncoding,
      removeDotSegments,
      isIPv4,
      isUUID,
      normalizeIPv6,
      stringArrayToHexStripped
    };
  }
});

// node_modules/fast-uri/lib/schemes.js
var require_schemes = __commonJS({
  "node_modules/fast-uri/lib/schemes.js"(exports, module) {
    "use strict";
    var { isUUID } = require_utils();
    var URN_REG = /([\da-z][\d\-a-z]{0,31}):((?:[\w!$'()*+,\-.:;=@]|%[\da-f]{2})+)/iu;
    var supportedSchemeNames = (
      /** @type {const} */
      [
        "http",
        "https",
        "ws",
        "wss",
        "urn",
        "urn:uuid"
      ]
    );
    function isValidSchemeName(name) {
      return supportedSchemeNames.indexOf(
        /** @type {*} */
        name
      ) !== -1;
    }
    function wsIsSecure(wsComponent) {
      if (wsComponent.secure === true) {
        return true;
      } else if (wsComponent.secure === false) {
        return false;
      } else if (wsComponent.scheme) {
        return wsComponent.scheme.length === 3 && (wsComponent.scheme[0] === "w" || wsComponent.scheme[0] === "W") && (wsComponent.scheme[1] === "s" || wsComponent.scheme[1] === "S") && (wsComponent.scheme[2] === "s" || wsComponent.scheme[2] === "S");
      } else {
        return false;
      }
    }
    function httpParse(component) {
      if (!component.host) {
        component.error = component.error || "HTTP URIs must have a host.";
      }
      return component;
    }
    function httpSerialize(component) {
      const secure = String(component.scheme).toLowerCase() === "https";
      if (component.port === (secure ? 443 : 80) || component.port === "") {
        component.port = void 0;
      }
      if (!component.path) {
        component.path = "/";
      }
      return component;
    }
    function wsParse(wsComponent) {
      wsComponent.secure = wsIsSecure(wsComponent);
      wsComponent.resourceName = (wsComponent.path || "/") + (wsComponent.query ? "?" + wsComponent.query : "");
      wsComponent.path = void 0;
      wsComponent.query = void 0;
      return wsComponent;
    }
    function wsSerialize(wsComponent) {
      if (wsComponent.port === (wsIsSecure(wsComponent) ? 443 : 80) || wsComponent.port === "") {
        wsComponent.port = void 0;
      }
      if (typeof wsComponent.secure === "boolean") {
        wsComponent.scheme = wsComponent.secure ? "wss" : "ws";
        wsComponent.secure = void 0;
      }
      if (wsComponent.resourceName) {
        const [path2, query] = wsComponent.resourceName.split("?");
        wsComponent.path = path2 && path2 !== "/" ? path2 : void 0;
        wsComponent.query = query;
        wsComponent.resourceName = void 0;
      }
      wsComponent.fragment = void 0;
      return wsComponent;
    }
    function urnParse(urnComponent, options) {
      if (!urnComponent.path) {
        urnComponent.error = "URN can not be parsed";
        return urnComponent;
      }
      const matches = urnComponent.path.match(URN_REG);
      if (matches) {
        const scheme = options.scheme || urnComponent.scheme || "urn";
        urnComponent.nid = matches[1].toLowerCase();
        urnComponent.nss = matches[2];
        const urnScheme = `${scheme}:${options.nid || urnComponent.nid}`;
        const schemeHandler = getSchemeHandler(urnScheme);
        urnComponent.path = void 0;
        if (schemeHandler) {
          urnComponent = schemeHandler.parse(urnComponent, options);
        }
      } else {
        urnComponent.error = urnComponent.error || "URN can not be parsed.";
      }
      return urnComponent;
    }
    function urnSerialize(urnComponent, options) {
      if (urnComponent.nid === void 0) {
        throw new Error("URN without nid cannot be serialized");
      }
      const scheme = options.scheme || urnComponent.scheme || "urn";
      const nid = urnComponent.nid.toLowerCase();
      const urnScheme = `${scheme}:${options.nid || nid}`;
      const schemeHandler = getSchemeHandler(urnScheme);
      if (schemeHandler) {
        urnComponent = schemeHandler.serialize(urnComponent, options);
      }
      const uriComponent = urnComponent;
      const nss = urnComponent.nss;
      uriComponent.path = `${nid || options.nid}:${nss}`;
      options.skipEscape = true;
      return uriComponent;
    }
    function urnuuidParse(urnComponent, options) {
      const uuidComponent = urnComponent;
      uuidComponent.uuid = uuidComponent.nss;
      uuidComponent.nss = void 0;
      if (!options.tolerant && (!uuidComponent.uuid || !isUUID(uuidComponent.uuid))) {
        uuidComponent.error = uuidComponent.error || "UUID is not valid.";
      }
      return uuidComponent;
    }
    function urnuuidSerialize(uuidComponent) {
      const urnComponent = uuidComponent;
      urnComponent.nss = (uuidComponent.uuid || "").toLowerCase();
      return urnComponent;
    }
    var http = (
      /** @type {SchemeHandler} */
      {
        scheme: "http",
        domainHost: true,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var https = (
      /** @type {SchemeHandler} */
      {
        scheme: "https",
        domainHost: http.domainHost,
        parse: httpParse,
        serialize: httpSerialize
      }
    );
    var ws = (
      /** @type {SchemeHandler} */
      {
        scheme: "ws",
        domainHost: true,
        parse: wsParse,
        serialize: wsSerialize
      }
    );
    var wss = (
      /** @type {SchemeHandler} */
      {
        scheme: "wss",
        domainHost: ws.domainHost,
        parse: ws.parse,
        serialize: ws.serialize
      }
    );
    var urn = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn",
        parse: urnParse,
        serialize: urnSerialize,
        skipNormalize: true
      }
    );
    var urnuuid = (
      /** @type {SchemeHandler} */
      {
        scheme: "urn:uuid",
        parse: urnuuidParse,
        serialize: urnuuidSerialize,
        skipNormalize: true
      }
    );
    var SCHEMES = (
      /** @type {Record<SchemeName, SchemeHandler>} */
      {
        http,
        https,
        ws,
        wss,
        urn,
        "urn:uuid": urnuuid
      }
    );
    Object.setPrototypeOf(SCHEMES, null);
    function getSchemeHandler(scheme) {
      return scheme && (SCHEMES[
        /** @type {SchemeName} */
        scheme
      ] || SCHEMES[
        /** @type {SchemeName} */
        scheme.toLowerCase()
      ]) || void 0;
    }
    module.exports = {
      wsIsSecure,
      SCHEMES,
      isValidSchemeName,
      getSchemeHandler
    };
  }
});

// node_modules/fast-uri/index.js
var require_fast_uri = __commonJS({
  "node_modules/fast-uri/index.js"(exports, module) {
    "use strict";
    var { normalizeIPv6, removeDotSegments, recomposeAuthority, normalizeComponentEncoding, isIPv4, nonSimpleDomain } = require_utils();
    var { SCHEMES, getSchemeHandler } = require_schemes();
    function normalize(uri, options) {
      if (typeof uri === "string") {
        uri = /** @type {T} */
        serialize(parse4(uri, options), options);
      } else if (typeof uri === "object") {
        uri = /** @type {T} */
        parse4(serialize(uri, options), options);
      }
      return uri;
    }
    function resolve(baseURI, relativeURI, options) {
      const schemelessOptions = options ? Object.assign({ scheme: "null" }, options) : { scheme: "null" };
      const resolved = resolveComponent(parse4(baseURI, schemelessOptions), parse4(relativeURI, schemelessOptions), schemelessOptions, true);
      schemelessOptions.skipEscape = true;
      return serialize(resolved, schemelessOptions);
    }
    function resolveComponent(base, relative, options, skipNormalization) {
      const target = {};
      if (!skipNormalization) {
        base = parse4(serialize(base, options), options);
        relative = parse4(serialize(relative, options), options);
      }
      options = options || {};
      if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
      } else {
        if (relative.userinfo !== void 0 || relative.host !== void 0 || relative.port !== void 0) {
          target.userinfo = relative.userinfo;
          target.host = relative.host;
          target.port = relative.port;
          target.path = removeDotSegments(relative.path || "");
          target.query = relative.query;
        } else {
          if (!relative.path) {
            target.path = base.path;
            if (relative.query !== void 0) {
              target.query = relative.query;
            } else {
              target.query = base.query;
            }
          } else {
            if (relative.path[0] === "/") {
              target.path = removeDotSegments(relative.path);
            } else {
              if ((base.userinfo !== void 0 || base.host !== void 0 || base.port !== void 0) && !base.path) {
                target.path = "/" + relative.path;
              } else if (!base.path) {
                target.path = relative.path;
              } else {
                target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
              }
              target.path = removeDotSegments(target.path);
            }
            target.query = relative.query;
          }
          target.userinfo = base.userinfo;
          target.host = base.host;
          target.port = base.port;
        }
        target.scheme = base.scheme;
      }
      target.fragment = relative.fragment;
      return target;
    }
    function equal(uriA, uriB, options) {
      if (typeof uriA === "string") {
        uriA = unescape(uriA);
        uriA = serialize(normalizeComponentEncoding(parse4(uriA, options), true), { ...options, skipEscape: true });
      } else if (typeof uriA === "object") {
        uriA = serialize(normalizeComponentEncoding(uriA, true), { ...options, skipEscape: true });
      }
      if (typeof uriB === "string") {
        uriB = unescape(uriB);
        uriB = serialize(normalizeComponentEncoding(parse4(uriB, options), true), { ...options, skipEscape: true });
      } else if (typeof uriB === "object") {
        uriB = serialize(normalizeComponentEncoding(uriB, true), { ...options, skipEscape: true });
      }
      return uriA.toLowerCase() === uriB.toLowerCase();
    }
    function serialize(cmpts, opts) {
      const component = {
        host: cmpts.host,
        scheme: cmpts.scheme,
        userinfo: cmpts.userinfo,
        port: cmpts.port,
        path: cmpts.path,
        query: cmpts.query,
        nid: cmpts.nid,
        nss: cmpts.nss,
        uuid: cmpts.uuid,
        fragment: cmpts.fragment,
        reference: cmpts.reference,
        resourceName: cmpts.resourceName,
        secure: cmpts.secure,
        error: ""
      };
      const options = Object.assign({}, opts);
      const uriTokens = [];
      const schemeHandler = getSchemeHandler(options.scheme || component.scheme);
      if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(component, options);
      if (component.path !== void 0) {
        if (!options.skipEscape) {
          component.path = escape(component.path);
          if (component.scheme !== void 0) {
            component.path = component.path.split("%3A").join(":");
          }
        } else {
          component.path = unescape(component.path);
        }
      }
      if (options.reference !== "suffix" && component.scheme) {
        uriTokens.push(component.scheme, ":");
      }
      const authority = recomposeAuthority(component);
      if (authority !== void 0) {
        if (options.reference !== "suffix") {
          uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (component.path && component.path[0] !== "/") {
          uriTokens.push("/");
        }
      }
      if (component.path !== void 0) {
        let s = component.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
          s = removeDotSegments(s);
        }
        if (authority === void 0 && s[0] === "/" && s[1] === "/") {
          s = "/%2F" + s.slice(2);
        }
        uriTokens.push(s);
      }
      if (component.query !== void 0) {
        uriTokens.push("?", component.query);
      }
      if (component.fragment !== void 0) {
        uriTokens.push("#", component.fragment);
      }
      return uriTokens.join("");
    }
    var URI_PARSE = /^(?:([^#/:?]+):)?(?:\/\/((?:([^#/?@]*)@)?(\[[^#/?\]]+\]|[^#/:?]*)(?::(\d*))?))?([^#?]*)(?:\?([^#]*))?(?:#((?:.|[\n\r])*))?/u;
    function parse4(uri, opts) {
      const options = Object.assign({}, opts);
      const parsed = {
        scheme: void 0,
        userinfo: void 0,
        host: "",
        port: void 0,
        path: "",
        query: void 0,
        fragment: void 0
      };
      let isIP = false;
      if (options.reference === "suffix") {
        if (options.scheme) {
          uri = options.scheme + ":" + uri;
        } else {
          uri = "//" + uri;
        }
      }
      const matches = uri.match(URI_PARSE);
      if (matches) {
        parsed.scheme = matches[1];
        parsed.userinfo = matches[3];
        parsed.host = matches[4];
        parsed.port = parseInt(matches[5], 10);
        parsed.path = matches[6] || "";
        parsed.query = matches[7];
        parsed.fragment = matches[8];
        if (isNaN(parsed.port)) {
          parsed.port = matches[5];
        }
        if (parsed.host) {
          const ipv4result = isIPv4(parsed.host);
          if (ipv4result === false) {
            const ipv6result = normalizeIPv6(parsed.host);
            parsed.host = ipv6result.host.toLowerCase();
            isIP = ipv6result.isIPV6;
          } else {
            isIP = true;
          }
        }
        if (parsed.scheme === void 0 && parsed.userinfo === void 0 && parsed.host === void 0 && parsed.port === void 0 && parsed.query === void 0 && !parsed.path) {
          parsed.reference = "same-document";
        } else if (parsed.scheme === void 0) {
          parsed.reference = "relative";
        } else if (parsed.fragment === void 0) {
          parsed.reference = "absolute";
        } else {
          parsed.reference = "uri";
        }
        if (options.reference && options.reference !== "suffix" && options.reference !== parsed.reference) {
          parsed.error = parsed.error || "URI is not a " + options.reference + " reference.";
        }
        const schemeHandler = getSchemeHandler(options.scheme || parsed.scheme);
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
          if (parsed.host && (options.domainHost || schemeHandler && schemeHandler.domainHost) && isIP === false && nonSimpleDomain(parsed.host)) {
            try {
              parsed.host = URL.domainToASCII(parsed.host.toLowerCase());
            } catch (e2) {
              parsed.error = parsed.error || "Host's domain name can not be converted to ASCII: " + e2;
            }
          }
        }
        if (!schemeHandler || schemeHandler && !schemeHandler.skipNormalize) {
          if (uri.indexOf("%") !== -1) {
            if (parsed.scheme !== void 0) {
              parsed.scheme = unescape(parsed.scheme);
            }
            if (parsed.host !== void 0) {
              parsed.host = unescape(parsed.host);
            }
          }
          if (parsed.path) {
            parsed.path = escape(unescape(parsed.path));
          }
          if (parsed.fragment) {
            parsed.fragment = encodeURI(decodeURIComponent(parsed.fragment));
          }
        }
        if (schemeHandler && schemeHandler.parse) {
          schemeHandler.parse(parsed, options);
        }
      } else {
        parsed.error = parsed.error || "URI can not be parsed.";
      }
      return parsed;
    }
    var fastUri = {
      SCHEMES,
      normalize,
      resolve,
      resolveComponent,
      equal,
      serialize,
      parse: parse4
    };
    module.exports = fastUri;
    module.exports.default = fastUri;
    module.exports.fastUri = fastUri;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/uri.js
var require_uri = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/core.js
var require_core = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    var ref_error_1 = require_ref_error();
    var rules_1 = require_rules();
    var compile_1 = require_compile();
    var codegen_2 = require_codegen();
    var resolve_1 = require_resolve();
    var dataType_1 = require_dataType();
    var util_1 = require_util();
    var $dataRefSchema = require_data();
    var uri_1 = require_uri();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a13, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a13 = o.code) === null || _a13 === void 0 ? void 0 : _a13.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e2) {
            if (!(e2 instanceof ref_error_1.default))
              throw e2;
            checkLoaded.call(this, e2);
            await loadMissingSchema.call(this, e2.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a13;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a13 = definition.implements) === null || _a13 === void 0 ? void 0 : _a13.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/core/id.js
var require_id = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error();
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var compile_1 = require_compile();
    var util_1 = require_util();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e2) => {
          gen.if((0, codegen_1._)`!(${e2} instanceof ${it.ValidationError})`, () => gen.throw(e2));
          addErrorsFrom(e2);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a13;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a13 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a13 === void 0 ? void 0 : _a13.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/core/index.js
var require_core2 = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id();
    var ref_1 = require_ref();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var ucs2length_1 = require_ucs2length();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u2 = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/equal.js
var require_equal = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var equal_1 = require_equal();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber();
    var multipleOf_1 = require_multipleOf();
    var limitLength_1 = require_limitLength();
    var pattern_1 = require_pattern();
    var limitProperties_1 = require_limitProperties();
    var required_1 = require_required();
    var limitItems_1 = require_limitItems();
    var uniqueItems_1 = require_uniqueItems();
    var const_1 = require_const();
    var enum_1 = require_enum();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items2020 = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    var additionalItems_1 = require_additionalItems();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var code_1 = require_code2();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var names_1 = require_names();
    var util_1 = require_util();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate();
    var code_1 = require_code2();
    var util_1 = require_util();
    var additionalProperties_1 = require_additionalProperties();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var util_2 = require_util();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code2();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var util_1 = require_util();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems();
    var prefixItems_1 = require_prefixItems();
    var items_1 = require_items();
    var items2020_1 = require_items2020();
    var contains_1 = require_contains();
    var dependencies_1 = require_dependencies();
    var propertyNames_1 = require_propertyNames();
    var additionalProperties_1 = require_additionalProperties();
    var properties_1 = require_properties();
    var patternProperties_1 = require_patternProperties();
    var not_1 = require_not();
    var anyOf_1 = require_anyOf();
    var oneOf_1 = require_oneOf();
    var allOf_1 = require_allOf();
    var if_1 = require_if();
    var thenElse_1 = require_thenElse();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/format/format.js
var require_format = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/format/index.js
var require_format2 = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format();
    var format = [format_1.default];
    exports.default = format;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft7 = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core2();
    var validation_1 = require_validation();
    var applicator_1 = require_applicator();
    var format_1 = require_format2();
    var metadata_1 = require_metadata();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen();
    var types_1 = require_types();
    var compile_1 = require_compile();
    var ref_error_1 = require_ref_error();
    var util_1 = require_util();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a13;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a13 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a13 === void 0 ? void 0 : _a13[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_07 = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/ajv.js
var require_ajv = __commonJS({
  "node_modules/@modelcontextprotocol/sdk/node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core();
    var draft7_1 = require_draft7();
    var discriminator_1 = require_discriminator();
    var draft7MetaSchema = require_json_schema_draft_07();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv2;
    module.exports = exports = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv2;
    var validate_1 = require_validate();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/formats.js
var require_formats = __commonJS({
  "node_modules/ajv-formats/dist/formats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatNames = exports.fastFormats = exports.fullFormats = void 0;
    function fmtDef(validate, compare) {
      return { validate, compare };
    }
    exports.fullFormats = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: fmtDef(date6, compareDate),
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: fmtDef(getTime(true), compareTime),
      "date-time": fmtDef(getDateTime(true), compareDateTime),
      "iso-time": fmtDef(getTime(), compareIsoTime),
      "iso-date-time": fmtDef(getDateTime(), compareIsoDateTime),
      // duration: https://tools.ietf.org/html/rfc3339#appendix-A
      duration: /^P(?!$)((\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+S)?)?|(\d+W)?)$/,
      uri,
      "uri-reference": /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i,
      // uri-template: https://tools.ietf.org/html/rfc6570
      "uri-template": /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i,
      // For the source: https://gist.github.com/dperini/729294
      // For test cases: https://mathiasbynens.be/demo/url-regex
      url: /^(?:https?|ftp):\/\/(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)(?:\.(?:[a-z0-9\u{00a1}-\u{ffff}]+-)*[a-z0-9\u{00a1}-\u{ffff}]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)$/,
      ipv6: /^((([0-9a-f]{1,4}:){7}([0-9a-f]{1,4}|:))|(([0-9a-f]{1,4}:){6}(:[0-9a-f]{1,4}|((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){5}(((:[0-9a-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(([0-9a-f]{1,4}:){4}(((:[0-9a-f]{1,4}){1,3})|((:[0-9a-f]{1,4})?:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){3}(((:[0-9a-f]{1,4}){1,4})|((:[0-9a-f]{1,4}){0,2}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){2}(((:[0-9a-f]{1,4}){1,5})|((:[0-9a-f]{1,4}){0,3}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(([0-9a-f]{1,4}:){1}(((:[0-9a-f]{1,4}){1,6})|((:[0-9a-f]{1,4}){0,4}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(:(((:[0-9a-f]{1,4}){1,7})|((:[0-9a-f]{1,4}){0,5}:((25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))$/i,
      regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      "json-pointer": /^(?:\/(?:[^~/]|~0|~1)*)*$/,
      "json-pointer-uri-fragment": /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      "relative-json-pointer": /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/,
      // the following formats are used by the openapi specification: https://spec.openapis.org/oas/v3.0.0#data-types
      // byte: https://github.com/miguelmota/is-base64
      byte,
      // signed 32 bit integer
      int32: { type: "number", validate: validateInt32 },
      // signed 64 bit integer
      int64: { type: "number", validate: validateInt64 },
      // C-type float
      float: { type: "number", validate: validateNumber },
      // C-type double
      double: { type: "number", validate: validateNumber },
      // hint to the UI to hide input strings
      password: true,
      // unchecked string payload
      binary: true
    };
    exports.fastFormats = {
      ...exports.fullFormats,
      date: fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d$/, compareDate),
      time: fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareTime),
      "date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\dt(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i, compareDateTime),
      "iso-time": fmtDef(/^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoTime),
      "iso-date-time": fmtDef(/^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i, compareIsoDateTime),
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
      "uri-reference": /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'wilful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i
    };
    exports.formatNames = Object.keys(exports.fullFormats);
    function isLeapYear(year) {
      return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
    }
    var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    function date6(str) {
      const matches = DATE.exec(str);
      if (!matches)
        return false;
      const year = +matches[1];
      const month = +matches[2];
      const day = +matches[3];
      return month >= 1 && month <= 12 && day >= 1 && day <= (month === 2 && isLeapYear(year) ? 29 : DAYS[month]);
    }
    function compareDate(d1, d2) {
      if (!(d1 && d2))
        return void 0;
      if (d1 > d2)
        return 1;
      if (d1 < d2)
        return -1;
      return 0;
    }
    var TIME = /^(\d\d):(\d\d):(\d\d(?:\.\d+)?)(z|([+-])(\d\d)(?::?(\d\d))?)?$/i;
    function getTime(strictTimeZone) {
      return function time3(str) {
        const matches = TIME.exec(str);
        if (!matches)
          return false;
        const hr = +matches[1];
        const min = +matches[2];
        const sec = +matches[3];
        const tz = matches[4];
        const tzSign = matches[5] === "-" ? -1 : 1;
        const tzH = +(matches[6] || 0);
        const tzM = +(matches[7] || 0);
        if (tzH > 23 || tzM > 59 || strictTimeZone && !tz)
          return false;
        if (hr <= 23 && min <= 59 && sec < 60)
          return true;
        const utcMin = min - tzM * tzSign;
        const utcHr = hr - tzH * tzSign - (utcMin < 0 ? 1 : 0);
        return (utcHr === 23 || utcHr === -1) && (utcMin === 59 || utcMin === -1) && sec < 61;
      };
    }
    function compareTime(s1, s2) {
      if (!(s1 && s2))
        return void 0;
      const t1 = (/* @__PURE__ */ new Date("2020-01-01T" + s1)).valueOf();
      const t2 = (/* @__PURE__ */ new Date("2020-01-01T" + s2)).valueOf();
      if (!(t1 && t2))
        return void 0;
      return t1 - t2;
    }
    function compareIsoTime(t1, t2) {
      if (!(t1 && t2))
        return void 0;
      const a1 = TIME.exec(t1);
      const a2 = TIME.exec(t2);
      if (!(a1 && a2))
        return void 0;
      t1 = a1[1] + a1[2] + a1[3];
      t2 = a2[1] + a2[2] + a2[3];
      if (t1 > t2)
        return 1;
      if (t1 < t2)
        return -1;
      return 0;
    }
    var DATE_TIME_SEPARATOR = /t|\s/i;
    function getDateTime(strictTimeZone) {
      const time3 = getTime(strictTimeZone);
      return function date_time(str) {
        const dateTime = str.split(DATE_TIME_SEPARATOR);
        return dateTime.length === 2 && date6(dateTime[0]) && time3(dateTime[1]);
      };
    }
    function compareDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const d1 = new Date(dt1).valueOf();
      const d2 = new Date(dt2).valueOf();
      if (!(d1 && d2))
        return void 0;
      return d1 - d2;
    }
    function compareIsoDateTime(dt1, dt2) {
      if (!(dt1 && dt2))
        return void 0;
      const [d1, t1] = dt1.split(DATE_TIME_SEPARATOR);
      const [d2, t2] = dt2.split(DATE_TIME_SEPARATOR);
      const res = compareDate(d1, d2);
      if (res === void 0)
        return void 0;
      return res || compareTime(t1, t2);
    }
    var NOT_URI_FRAGMENT = /\/|:/;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    function uri(str) {
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }
    var BYTE = /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/gm;
    function byte(str) {
      BYTE.lastIndex = 0;
      return BYTE.test(str);
    }
    var MIN_INT32 = -(2 ** 31);
    var MAX_INT32 = 2 ** 31 - 1;
    function validateInt32(value) {
      return Number.isInteger(value) && value <= MAX_INT32 && value >= MIN_INT32;
    }
    function validateInt64(value) {
      return Number.isInteger(value);
    }
    function validateNumber() {
      return true;
    }
    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str))
        return false;
      try {
        new RegExp(str);
        return true;
      } catch (e2) {
        return false;
      }
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/code.js
var require_code3 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.regexpCode = exports.getEsmExportName = exports.getProperty = exports.safeStringify = exports.stringify = exports.strConcat = exports.addCodeArg = exports.str = exports._ = exports.nil = exports._Code = exports.Name = exports.IDENTIFIER = exports._CodeOrName = void 0;
    var _CodeOrName = class {
    };
    exports._CodeOrName = _CodeOrName;
    exports.IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var Name = class extends _CodeOrName {
      constructor(s) {
        super();
        if (!exports.IDENTIFIER.test(s))
          throw new Error("CodeGen: name must be a valid identifier");
        this.str = s;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        return false;
      }
      get names() {
        return { [this.str]: 1 };
      }
    };
    exports.Name = Name;
    var _Code = class extends _CodeOrName {
      constructor(code) {
        super();
        this._items = typeof code === "string" ? [code] : code;
      }
      toString() {
        return this.str;
      }
      emptyStr() {
        if (this._items.length > 1)
          return false;
        const item = this._items[0];
        return item === "" || item === '""';
      }
      get str() {
        var _a13;
        return (_a13 = this._str) !== null && _a13 !== void 0 ? _a13 : this._str = this._items.reduce((s, c2) => `${s}${c2}`, "");
      }
      get names() {
        var _a13;
        return (_a13 = this._names) !== null && _a13 !== void 0 ? _a13 : this._names = this._items.reduce((names, c2) => {
          if (c2 instanceof Name)
            names[c2.str] = (names[c2.str] || 0) + 1;
          return names;
        }, {});
      }
    };
    exports._Code = _Code;
    exports.nil = new _Code("");
    function _(strs, ...args) {
      const code = [strs[0]];
      let i = 0;
      while (i < args.length) {
        addCodeArg(code, args[i]);
        code.push(strs[++i]);
      }
      return new _Code(code);
    }
    exports._ = _;
    var plus = new _Code("+");
    function str(strs, ...args) {
      const expr = [safeStringify(strs[0])];
      let i = 0;
      while (i < args.length) {
        expr.push(plus);
        addCodeArg(expr, args[i]);
        expr.push(plus, safeStringify(strs[++i]));
      }
      optimize(expr);
      return new _Code(expr);
    }
    exports.str = str;
    function addCodeArg(code, arg) {
      if (arg instanceof _Code)
        code.push(...arg._items);
      else if (arg instanceof Name)
        code.push(arg);
      else
        code.push(interpolate(arg));
    }
    exports.addCodeArg = addCodeArg;
    function optimize(expr) {
      let i = 1;
      while (i < expr.length - 1) {
        if (expr[i] === plus) {
          const res = mergeExprItems(expr[i - 1], expr[i + 1]);
          if (res !== void 0) {
            expr.splice(i - 1, 3, res);
            continue;
          }
          expr[i++] = "+";
        }
        i++;
      }
    }
    function mergeExprItems(a, b) {
      if (b === '""')
        return a;
      if (a === '""')
        return b;
      if (typeof a == "string") {
        if (b instanceof Name || a[a.length - 1] !== '"')
          return;
        if (typeof b != "string")
          return `${a.slice(0, -1)}${b}"`;
        if (b[0] === '"')
          return a.slice(0, -1) + b.slice(1);
        return;
      }
      if (typeof b == "string" && b[0] === '"' && !(a instanceof Name))
        return `"${a}${b.slice(1)}`;
      return;
    }
    function strConcat(c1, c2) {
      return c2.emptyStr() ? c1 : c1.emptyStr() ? c2 : str`${c1}${c2}`;
    }
    exports.strConcat = strConcat;
    function interpolate(x) {
      return typeof x == "number" || typeof x == "boolean" || x === null ? x : safeStringify(Array.isArray(x) ? x.join(",") : x);
    }
    function stringify(x) {
      return new _Code(safeStringify(x));
    }
    exports.stringify = stringify;
    function safeStringify(x) {
      return JSON.stringify(x).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    exports.safeStringify = safeStringify;
    function getProperty(key) {
      return typeof key == "string" && exports.IDENTIFIER.test(key) ? new _Code(`.${key}`) : _`[${key}]`;
    }
    exports.getProperty = getProperty;
    function getEsmExportName(key) {
      if (typeof key == "string" && exports.IDENTIFIER.test(key)) {
        return new _Code(`${key}`);
      }
      throw new Error(`CodeGen: invalid export name: ${key}, use explicit $id name mapping`);
    }
    exports.getEsmExportName = getEsmExportName;
    function regexpCode(rx) {
      return new _Code(rx.toString());
    }
    exports.regexpCode = regexpCode;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/scope.js
var require_scope2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/scope.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ValueScope = exports.ValueScopeName = exports.Scope = exports.varKinds = exports.UsedValueState = void 0;
    var code_1 = require_code3();
    var ValueError = class extends Error {
      constructor(name) {
        super(`CodeGen: "code" for ${name} not defined`);
        this.value = name.value;
      }
    };
    var UsedValueState;
    (function(UsedValueState2) {
      UsedValueState2[UsedValueState2["Started"] = 0] = "Started";
      UsedValueState2[UsedValueState2["Completed"] = 1] = "Completed";
    })(UsedValueState || (exports.UsedValueState = UsedValueState = {}));
    exports.varKinds = {
      const: new code_1.Name("const"),
      let: new code_1.Name("let"),
      var: new code_1.Name("var")
    };
    var Scope = class {
      constructor({ prefixes, parent } = {}) {
        this._names = {};
        this._prefixes = prefixes;
        this._parent = parent;
      }
      toName(nameOrPrefix) {
        return nameOrPrefix instanceof code_1.Name ? nameOrPrefix : this.name(nameOrPrefix);
      }
      name(prefix) {
        return new code_1.Name(this._newName(prefix));
      }
      _newName(prefix) {
        const ng = this._names[prefix] || this._nameGroup(prefix);
        return `${prefix}${ng.index++}`;
      }
      _nameGroup(prefix) {
        var _a13, _b;
        if (((_b = (_a13 = this._parent) === null || _a13 === void 0 ? void 0 : _a13._prefixes) === null || _b === void 0 ? void 0 : _b.has(prefix)) || this._prefixes && !this._prefixes.has(prefix)) {
          throw new Error(`CodeGen: prefix "${prefix}" is not allowed in this scope`);
        }
        return this._names[prefix] = { prefix, index: 0 };
      }
    };
    exports.Scope = Scope;
    var ValueScopeName = class extends code_1.Name {
      constructor(prefix, nameStr) {
        super(nameStr);
        this.prefix = prefix;
      }
      setValue(value, { property, itemIndex }) {
        this.value = value;
        this.scopePath = (0, code_1._)`.${new code_1.Name(property)}[${itemIndex}]`;
      }
    };
    exports.ValueScopeName = ValueScopeName;
    var line = (0, code_1._)`\n`;
    var ValueScope = class extends Scope {
      constructor(opts) {
        super(opts);
        this._values = {};
        this._scope = opts.scope;
        this.opts = { ...opts, _n: opts.lines ? line : code_1.nil };
      }
      get() {
        return this._scope;
      }
      name(prefix) {
        return new ValueScopeName(prefix, this._newName(prefix));
      }
      value(nameOrPrefix, value) {
        var _a13;
        if (value.ref === void 0)
          throw new Error("CodeGen: ref must be passed in value");
        const name = this.toName(nameOrPrefix);
        const { prefix } = name;
        const valueKey = (_a13 = value.key) !== null && _a13 !== void 0 ? _a13 : value.ref;
        let vs = this._values[prefix];
        if (vs) {
          const _name = vs.get(valueKey);
          if (_name)
            return _name;
        } else {
          vs = this._values[prefix] = /* @__PURE__ */ new Map();
        }
        vs.set(valueKey, name);
        const s = this._scope[prefix] || (this._scope[prefix] = []);
        const itemIndex = s.length;
        s[itemIndex] = value.ref;
        name.setValue(value, { property: prefix, itemIndex });
        return name;
      }
      getValue(prefix, keyOrRef) {
        const vs = this._values[prefix];
        if (!vs)
          return;
        return vs.get(keyOrRef);
      }
      scopeRefs(scopeName, values = this._values) {
        return this._reduceValues(values, (name) => {
          if (name.scopePath === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return (0, code_1._)`${scopeName}${name.scopePath}`;
        });
      }
      scopeCode(values = this._values, usedValues, getCode) {
        return this._reduceValues(values, (name) => {
          if (name.value === void 0)
            throw new Error(`CodeGen: name "${name}" has no value`);
          return name.value.code;
        }, usedValues, getCode);
      }
      _reduceValues(values, valueCode, usedValues = {}, getCode) {
        let code = code_1.nil;
        for (const prefix in values) {
          const vs = values[prefix];
          if (!vs)
            continue;
          const nameSet = usedValues[prefix] = usedValues[prefix] || /* @__PURE__ */ new Map();
          vs.forEach((name) => {
            if (nameSet.has(name))
              return;
            nameSet.set(name, UsedValueState.Started);
            let c2 = valueCode(name);
            if (c2) {
              const def = this.opts.es5 ? exports.varKinds.var : exports.varKinds.const;
              code = (0, code_1._)`${code}${def} ${name} = ${c2};${this.opts._n}`;
            } else if (c2 = getCode === null || getCode === void 0 ? void 0 : getCode(name)) {
              code = (0, code_1._)`${code}${c2}${this.opts._n}`;
            } else {
              throw new ValueError(name);
            }
            nameSet.set(name, UsedValueState.Completed);
          });
        }
        return code;
      }
    };
    exports.ValueScope = ValueScope;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js
var require_codegen2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/codegen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.or = exports.and = exports.not = exports.CodeGen = exports.operators = exports.varKinds = exports.ValueScopeName = exports.ValueScope = exports.Scope = exports.Name = exports.regexpCode = exports.stringify = exports.getProperty = exports.nil = exports.strConcat = exports.str = exports._ = void 0;
    var code_1 = require_code3();
    var scope_1 = require_scope2();
    var code_2 = require_code3();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return code_2._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return code_2.str;
    } });
    Object.defineProperty(exports, "strConcat", { enumerable: true, get: function() {
      return code_2.strConcat;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return code_2.nil;
    } });
    Object.defineProperty(exports, "getProperty", { enumerable: true, get: function() {
      return code_2.getProperty;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return code_2.stringify;
    } });
    Object.defineProperty(exports, "regexpCode", { enumerable: true, get: function() {
      return code_2.regexpCode;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return code_2.Name;
    } });
    var scope_2 = require_scope2();
    Object.defineProperty(exports, "Scope", { enumerable: true, get: function() {
      return scope_2.Scope;
    } });
    Object.defineProperty(exports, "ValueScope", { enumerable: true, get: function() {
      return scope_2.ValueScope;
    } });
    Object.defineProperty(exports, "ValueScopeName", { enumerable: true, get: function() {
      return scope_2.ValueScopeName;
    } });
    Object.defineProperty(exports, "varKinds", { enumerable: true, get: function() {
      return scope_2.varKinds;
    } });
    exports.operators = {
      GT: new code_1._Code(">"),
      GTE: new code_1._Code(">="),
      LT: new code_1._Code("<"),
      LTE: new code_1._Code("<="),
      EQ: new code_1._Code("==="),
      NEQ: new code_1._Code("!=="),
      NOT: new code_1._Code("!"),
      OR: new code_1._Code("||"),
      AND: new code_1._Code("&&"),
      ADD: new code_1._Code("+")
    };
    var Node = class {
      optimizeNodes() {
        return this;
      }
      optimizeNames(_names, _constants) {
        return this;
      }
    };
    var Def = class extends Node {
      constructor(varKind, name, rhs) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.rhs = rhs;
      }
      render({ es5, _n }) {
        const varKind = es5 ? scope_1.varKinds.var : this.varKind;
        const rhs = this.rhs === void 0 ? "" : ` = ${this.rhs}`;
        return `${varKind} ${this.name}${rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (!names[this.name.str])
          return;
        if (this.rhs)
          this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        return this.rhs instanceof code_1._CodeOrName ? this.rhs.names : {};
      }
    };
    var Assign = class extends Node {
      constructor(lhs, rhs, sideEffects) {
        super();
        this.lhs = lhs;
        this.rhs = rhs;
        this.sideEffects = sideEffects;
      }
      render({ _n }) {
        return `${this.lhs} = ${this.rhs};` + _n;
      }
      optimizeNames(names, constants) {
        if (this.lhs instanceof code_1.Name && !names[this.lhs.str] && !this.sideEffects)
          return;
        this.rhs = optimizeExpr(this.rhs, names, constants);
        return this;
      }
      get names() {
        const names = this.lhs instanceof code_1.Name ? {} : { ...this.lhs.names };
        return addExprNames(names, this.rhs);
      }
    };
    var AssignOp = class extends Assign {
      constructor(lhs, op, rhs, sideEffects) {
        super(lhs, rhs, sideEffects);
        this.op = op;
      }
      render({ _n }) {
        return `${this.lhs} ${this.op}= ${this.rhs};` + _n;
      }
    };
    var Label = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        return `${this.label}:` + _n;
      }
    };
    var Break = class extends Node {
      constructor(label) {
        super();
        this.label = label;
        this.names = {};
      }
      render({ _n }) {
        const label = this.label ? ` ${this.label}` : "";
        return `break${label};` + _n;
      }
    };
    var Throw = class extends Node {
      constructor(error) {
        super();
        this.error = error;
      }
      render({ _n }) {
        return `throw ${this.error};` + _n;
      }
      get names() {
        return this.error.names;
      }
    };
    var AnyCode = class extends Node {
      constructor(code) {
        super();
        this.code = code;
      }
      render({ _n }) {
        return `${this.code};` + _n;
      }
      optimizeNodes() {
        return `${this.code}` ? this : void 0;
      }
      optimizeNames(names, constants) {
        this.code = optimizeExpr(this.code, names, constants);
        return this;
      }
      get names() {
        return this.code instanceof code_1._CodeOrName ? this.code.names : {};
      }
    };
    var ParentNode = class extends Node {
      constructor(nodes = []) {
        super();
        this.nodes = nodes;
      }
      render(opts) {
        return this.nodes.reduce((code, n2) => code + n2.render(opts), "");
      }
      optimizeNodes() {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n2 = nodes[i].optimizeNodes();
          if (Array.isArray(n2))
            nodes.splice(i, 1, ...n2);
          else if (n2)
            nodes[i] = n2;
          else
            nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      optimizeNames(names, constants) {
        const { nodes } = this;
        let i = nodes.length;
        while (i--) {
          const n2 = nodes[i];
          if (n2.optimizeNames(names, constants))
            continue;
          subtractNames(names, n2.names);
          nodes.splice(i, 1);
        }
        return nodes.length > 0 ? this : void 0;
      }
      get names() {
        return this.nodes.reduce((names, n2) => addNames(names, n2.names), {});
      }
    };
    var BlockNode = class extends ParentNode {
      render(opts) {
        return "{" + opts._n + super.render(opts) + "}" + opts._n;
      }
    };
    var Root = class extends ParentNode {
    };
    var Else = class extends BlockNode {
    };
    Else.kind = "else";
    var If = class _If extends BlockNode {
      constructor(condition, nodes) {
        super(nodes);
        this.condition = condition;
      }
      render(opts) {
        let code = `if(${this.condition})` + super.render(opts);
        if (this.else)
          code += "else " + this.else.render(opts);
        return code;
      }
      optimizeNodes() {
        super.optimizeNodes();
        const cond = this.condition;
        if (cond === true)
          return this.nodes;
        let e2 = this.else;
        if (e2) {
          const ns = e2.optimizeNodes();
          e2 = this.else = Array.isArray(ns) ? new Else(ns) : ns;
        }
        if (e2) {
          if (cond === false)
            return e2 instanceof _If ? e2 : e2.nodes;
          if (this.nodes.length)
            return this;
          return new _If(not(cond), e2 instanceof _If ? [e2] : e2.nodes);
        }
        if (cond === false || !this.nodes.length)
          return void 0;
        return this;
      }
      optimizeNames(names, constants) {
        var _a13;
        this.else = (_a13 = this.else) === null || _a13 === void 0 ? void 0 : _a13.optimizeNames(names, constants);
        if (!(super.optimizeNames(names, constants) || this.else))
          return;
        this.condition = optimizeExpr(this.condition, names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        addExprNames(names, this.condition);
        if (this.else)
          addNames(names, this.else.names);
        return names;
      }
    };
    If.kind = "if";
    var For = class extends BlockNode {
    };
    For.kind = "for";
    var ForLoop = class extends For {
      constructor(iteration) {
        super();
        this.iteration = iteration;
      }
      render(opts) {
        return `for(${this.iteration})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iteration = optimizeExpr(this.iteration, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iteration.names);
      }
    };
    var ForRange = class extends For {
      constructor(varKind, name, from, to) {
        super();
        this.varKind = varKind;
        this.name = name;
        this.from = from;
        this.to = to;
      }
      render(opts) {
        const varKind = opts.es5 ? scope_1.varKinds.var : this.varKind;
        const { name, from, to } = this;
        return `for(${varKind} ${name}=${from}; ${name}<${to}; ${name}++)` + super.render(opts);
      }
      get names() {
        const names = addExprNames(super.names, this.from);
        return addExprNames(names, this.to);
      }
    };
    var ForIter = class extends For {
      constructor(loop, varKind, name, iterable) {
        super();
        this.loop = loop;
        this.varKind = varKind;
        this.name = name;
        this.iterable = iterable;
      }
      render(opts) {
        return `for(${this.varKind} ${this.name} ${this.loop} ${this.iterable})` + super.render(opts);
      }
      optimizeNames(names, constants) {
        if (!super.optimizeNames(names, constants))
          return;
        this.iterable = optimizeExpr(this.iterable, names, constants);
        return this;
      }
      get names() {
        return addNames(super.names, this.iterable.names);
      }
    };
    var Func = class extends BlockNode {
      constructor(name, args, async) {
        super();
        this.name = name;
        this.args = args;
        this.async = async;
      }
      render(opts) {
        const _async = this.async ? "async " : "";
        return `${_async}function ${this.name}(${this.args})` + super.render(opts);
      }
    };
    Func.kind = "func";
    var Return = class extends ParentNode {
      render(opts) {
        return "return " + super.render(opts);
      }
    };
    Return.kind = "return";
    var Try = class extends BlockNode {
      render(opts) {
        let code = "try" + super.render(opts);
        if (this.catch)
          code += this.catch.render(opts);
        if (this.finally)
          code += this.finally.render(opts);
        return code;
      }
      optimizeNodes() {
        var _a13, _b;
        super.optimizeNodes();
        (_a13 = this.catch) === null || _a13 === void 0 ? void 0 : _a13.optimizeNodes();
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNodes();
        return this;
      }
      optimizeNames(names, constants) {
        var _a13, _b;
        super.optimizeNames(names, constants);
        (_a13 = this.catch) === null || _a13 === void 0 ? void 0 : _a13.optimizeNames(names, constants);
        (_b = this.finally) === null || _b === void 0 ? void 0 : _b.optimizeNames(names, constants);
        return this;
      }
      get names() {
        const names = super.names;
        if (this.catch)
          addNames(names, this.catch.names);
        if (this.finally)
          addNames(names, this.finally.names);
        return names;
      }
    };
    var Catch = class extends BlockNode {
      constructor(error) {
        super();
        this.error = error;
      }
      render(opts) {
        return `catch(${this.error})` + super.render(opts);
      }
    };
    Catch.kind = "catch";
    var Finally = class extends BlockNode {
      render(opts) {
        return "finally" + super.render(opts);
      }
    };
    Finally.kind = "finally";
    var CodeGen = class {
      constructor(extScope, opts = {}) {
        this._values = {};
        this._blockStarts = [];
        this._constants = {};
        this.opts = { ...opts, _n: opts.lines ? "\n" : "" };
        this._extScope = extScope;
        this._scope = new scope_1.Scope({ parent: extScope });
        this._nodes = [new Root()];
      }
      toString() {
        return this._root.render(this.opts);
      }
      // returns unique name in the internal scope
      name(prefix) {
        return this._scope.name(prefix);
      }
      // reserves unique name in the external scope
      scopeName(prefix) {
        return this._extScope.name(prefix);
      }
      // reserves unique name in the external scope and assigns value to it
      scopeValue(prefixOrName, value) {
        const name = this._extScope.value(prefixOrName, value);
        const vs = this._values[name.prefix] || (this._values[name.prefix] = /* @__PURE__ */ new Set());
        vs.add(name);
        return name;
      }
      getScopeValue(prefix, keyOrRef) {
        return this._extScope.getValue(prefix, keyOrRef);
      }
      // return code that assigns values in the external scope to the names that are used internally
      // (same names that were returned by gen.scopeName or gen.scopeValue)
      scopeRefs(scopeName) {
        return this._extScope.scopeRefs(scopeName, this._values);
      }
      scopeCode() {
        return this._extScope.scopeCode(this._values);
      }
      _def(varKind, nameOrPrefix, rhs, constant) {
        const name = this._scope.toName(nameOrPrefix);
        if (rhs !== void 0 && constant)
          this._constants[name.str] = rhs;
        this._leafNode(new Def(varKind, name, rhs));
        return name;
      }
      // `const` declaration (`var` in es5 mode)
      const(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.const, nameOrPrefix, rhs, _constant);
      }
      // `let` declaration with optional assignment (`var` in es5 mode)
      let(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.let, nameOrPrefix, rhs, _constant);
      }
      // `var` declaration with optional assignment
      var(nameOrPrefix, rhs, _constant) {
        return this._def(scope_1.varKinds.var, nameOrPrefix, rhs, _constant);
      }
      // assignment code
      assign(lhs, rhs, sideEffects) {
        return this._leafNode(new Assign(lhs, rhs, sideEffects));
      }
      // `+=` code
      add(lhs, rhs) {
        return this._leafNode(new AssignOp(lhs, exports.operators.ADD, rhs));
      }
      // appends passed SafeExpr to code or executes Block
      code(c2) {
        if (typeof c2 == "function")
          c2();
        else if (c2 !== code_1.nil)
          this._leafNode(new AnyCode(c2));
        return this;
      }
      // returns code for object literal for the passed argument list of key-value pairs
      object(...keyValues) {
        const code = ["{"];
        for (const [key, value] of keyValues) {
          if (code.length > 1)
            code.push(",");
          code.push(key);
          if (key !== value || this.opts.es5) {
            code.push(":");
            (0, code_1.addCodeArg)(code, value);
          }
        }
        code.push("}");
        return new code_1._Code(code);
      }
      // `if` clause (or statement if `thenBody` and, optionally, `elseBody` are passed)
      if(condition, thenBody, elseBody) {
        this._blockNode(new If(condition));
        if (thenBody && elseBody) {
          this.code(thenBody).else().code(elseBody).endIf();
        } else if (thenBody) {
          this.code(thenBody).endIf();
        } else if (elseBody) {
          throw new Error('CodeGen: "else" body without "then" body');
        }
        return this;
      }
      // `else if` clause - invalid without `if` or after `else` clauses
      elseIf(condition) {
        return this._elseNode(new If(condition));
      }
      // `else` clause - only valid after `if` or `else if` clauses
      else() {
        return this._elseNode(new Else());
      }
      // end `if` statement (needed if gen.if was used only with condition)
      endIf() {
        return this._endBlockNode(If, Else);
      }
      _for(node, forBody) {
        this._blockNode(node);
        if (forBody)
          this.code(forBody).endFor();
        return this;
      }
      // a generic `for` clause (or statement if `forBody` is passed)
      for(iteration, forBody) {
        return this._for(new ForLoop(iteration), forBody);
      }
      // `for` statement for a range of values
      forRange(nameOrPrefix, from, to, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.let) {
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForRange(varKind, name, from, to), () => forBody(name));
      }
      // `for-of` statement (in es5 mode replace with a normal for loop)
      forOf(nameOrPrefix, iterable, forBody, varKind = scope_1.varKinds.const) {
        const name = this._scope.toName(nameOrPrefix);
        if (this.opts.es5) {
          const arr = iterable instanceof code_1.Name ? iterable : this.var("_arr", iterable);
          return this.forRange("_i", 0, (0, code_1._)`${arr}.length`, (i) => {
            this.var(name, (0, code_1._)`${arr}[${i}]`);
            forBody(name);
          });
        }
        return this._for(new ForIter("of", varKind, name, iterable), () => forBody(name));
      }
      // `for-in` statement.
      // With option `ownProperties` replaced with a `for-of` loop for object keys
      forIn(nameOrPrefix, obj, forBody, varKind = this.opts.es5 ? scope_1.varKinds.var : scope_1.varKinds.const) {
        if (this.opts.ownProperties) {
          return this.forOf(nameOrPrefix, (0, code_1._)`Object.keys(${obj})`, forBody);
        }
        const name = this._scope.toName(nameOrPrefix);
        return this._for(new ForIter("in", varKind, name, obj), () => forBody(name));
      }
      // end `for` loop
      endFor() {
        return this._endBlockNode(For);
      }
      // `label` statement
      label(label) {
        return this._leafNode(new Label(label));
      }
      // `break` statement
      break(label) {
        return this._leafNode(new Break(label));
      }
      // `return` statement
      return(value) {
        const node = new Return();
        this._blockNode(node);
        this.code(value);
        if (node.nodes.length !== 1)
          throw new Error('CodeGen: "return" should have one node');
        return this._endBlockNode(Return);
      }
      // `try` statement
      try(tryBody, catchCode, finallyCode) {
        if (!catchCode && !finallyCode)
          throw new Error('CodeGen: "try" without "catch" and "finally"');
        const node = new Try();
        this._blockNode(node);
        this.code(tryBody);
        if (catchCode) {
          const error = this.name("e");
          this._currNode = node.catch = new Catch(error);
          catchCode(error);
        }
        if (finallyCode) {
          this._currNode = node.finally = new Finally();
          this.code(finallyCode);
        }
        return this._endBlockNode(Catch, Finally);
      }
      // `throw` statement
      throw(error) {
        return this._leafNode(new Throw(error));
      }
      // start self-balancing block
      block(body, nodeCount) {
        this._blockStarts.push(this._nodes.length);
        if (body)
          this.code(body).endBlock(nodeCount);
        return this;
      }
      // end the current self-balancing block
      endBlock(nodeCount) {
        const len = this._blockStarts.pop();
        if (len === void 0)
          throw new Error("CodeGen: not in self-balancing block");
        const toClose = this._nodes.length - len;
        if (toClose < 0 || nodeCount !== void 0 && toClose !== nodeCount) {
          throw new Error(`CodeGen: wrong number of nodes: ${toClose} vs ${nodeCount} expected`);
        }
        this._nodes.length = len;
        return this;
      }
      // `function` heading (or definition if funcBody is passed)
      func(name, args = code_1.nil, async, funcBody) {
        this._blockNode(new Func(name, args, async));
        if (funcBody)
          this.code(funcBody).endFunc();
        return this;
      }
      // end function definition
      endFunc() {
        return this._endBlockNode(Func);
      }
      optimize(n2 = 1) {
        while (n2-- > 0) {
          this._root.optimizeNodes();
          this._root.optimizeNames(this._root.names, this._constants);
        }
      }
      _leafNode(node) {
        this._currNode.nodes.push(node);
        return this;
      }
      _blockNode(node) {
        this._currNode.nodes.push(node);
        this._nodes.push(node);
      }
      _endBlockNode(N1, N2) {
        const n2 = this._currNode;
        if (n2 instanceof N1 || N2 && n2 instanceof N2) {
          this._nodes.pop();
          return this;
        }
        throw new Error(`CodeGen: not in block "${N2 ? `${N1.kind}/${N2.kind}` : N1.kind}"`);
      }
      _elseNode(node) {
        const n2 = this._currNode;
        if (!(n2 instanceof If)) {
          throw new Error('CodeGen: "else" without "if"');
        }
        this._currNode = n2.else = node;
        return this;
      }
      get _root() {
        return this._nodes[0];
      }
      get _currNode() {
        const ns = this._nodes;
        return ns[ns.length - 1];
      }
      set _currNode(node) {
        const ns = this._nodes;
        ns[ns.length - 1] = node;
      }
    };
    exports.CodeGen = CodeGen;
    function addNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) + (from[n2] || 0);
      return names;
    }
    function addExprNames(names, from) {
      return from instanceof code_1._CodeOrName ? addNames(names, from.names) : names;
    }
    function optimizeExpr(expr, names, constants) {
      if (expr instanceof code_1.Name)
        return replaceName(expr);
      if (!canOptimize(expr))
        return expr;
      return new code_1._Code(expr._items.reduce((items, c2) => {
        if (c2 instanceof code_1.Name)
          c2 = replaceName(c2);
        if (c2 instanceof code_1._Code)
          items.push(...c2._items);
        else
          items.push(c2);
        return items;
      }, []));
      function replaceName(n2) {
        const c2 = constants[n2.str];
        if (c2 === void 0 || names[n2.str] !== 1)
          return n2;
        delete names[n2.str];
        return c2;
      }
      function canOptimize(e2) {
        return e2 instanceof code_1._Code && e2._items.some((c2) => c2 instanceof code_1.Name && names[c2.str] === 1 && constants[c2.str] !== void 0);
      }
    }
    function subtractNames(names, from) {
      for (const n2 in from)
        names[n2] = (names[n2] || 0) - (from[n2] || 0);
    }
    function not(x) {
      return typeof x == "boolean" || typeof x == "number" || x === null ? !x : (0, code_1._)`!${par(x)}`;
    }
    exports.not = not;
    var andCode = mappend(exports.operators.AND);
    function and(...args) {
      return args.reduce(andCode);
    }
    exports.and = and;
    var orCode = mappend(exports.operators.OR);
    function or(...args) {
      return args.reduce(orCode);
    }
    exports.or = or;
    function mappend(op) {
      return (x, y) => x === code_1.nil ? y : y === code_1.nil ? x : (0, code_1._)`${par(x)} ${op} ${par(y)}`;
    }
    function par(x) {
      return x instanceof code_1.Name ? x : (0, code_1._)`(${x})`;
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/util.js
var require_util2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkStrictMode = exports.getErrorPath = exports.Type = exports.useFunc = exports.setEvaluated = exports.evaluatedPropsToName = exports.mergeEvaluated = exports.eachItem = exports.unescapeJsonPointer = exports.escapeJsonPointer = exports.escapeFragment = exports.unescapeFragment = exports.schemaRefOrVal = exports.schemaHasRulesButRef = exports.schemaHasRules = exports.checkUnknownRules = exports.alwaysValidSchema = exports.toHash = void 0;
    var codegen_1 = require_codegen2();
    var code_1 = require_code3();
    function toHash(arr) {
      const hash = {};
      for (const item of arr)
        hash[item] = true;
      return hash;
    }
    exports.toHash = toHash;
    function alwaysValidSchema(it, schema) {
      if (typeof schema == "boolean")
        return schema;
      if (Object.keys(schema).length === 0)
        return true;
      checkUnknownRules(it, schema);
      return !schemaHasRules(schema, it.self.RULES.all);
    }
    exports.alwaysValidSchema = alwaysValidSchema;
    function checkUnknownRules(it, schema = it.schema) {
      const { opts, self } = it;
      if (!opts.strictSchema)
        return;
      if (typeof schema === "boolean")
        return;
      const rules = self.RULES.keywords;
      for (const key in schema) {
        if (!rules[key])
          checkStrictMode(it, `unknown keyword: "${key}"`);
      }
    }
    exports.checkUnknownRules = checkUnknownRules;
    function schemaHasRules(schema, rules) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (rules[key])
          return true;
      return false;
    }
    exports.schemaHasRules = schemaHasRules;
    function schemaHasRulesButRef(schema, RULES) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (key !== "$ref" && RULES.all[key])
          return true;
      return false;
    }
    exports.schemaHasRulesButRef = schemaHasRulesButRef;
    function schemaRefOrVal({ topSchemaRef, schemaPath }, schema, keyword, $data) {
      if (!$data) {
        if (typeof schema == "number" || typeof schema == "boolean")
          return schema;
        if (typeof schema == "string")
          return (0, codegen_1._)`${schema}`;
      }
      return (0, codegen_1._)`${topSchemaRef}${schemaPath}${(0, codegen_1.getProperty)(keyword)}`;
    }
    exports.schemaRefOrVal = schemaRefOrVal;
    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }
    exports.unescapeFragment = unescapeFragment;
    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }
    exports.escapeFragment = escapeFragment;
    function escapeJsonPointer(str) {
      if (typeof str == "number")
        return `${str}`;
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
    exports.escapeJsonPointer = escapeJsonPointer;
    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, "/").replace(/~0/g, "~");
    }
    exports.unescapeJsonPointer = unescapeJsonPointer;
    function eachItem(xs, f) {
      if (Array.isArray(xs)) {
        for (const x of xs)
          f(x);
      } else {
        f(xs);
      }
    }
    exports.eachItem = eachItem;
    function makeMergeEvaluated({ mergeNames, mergeToName, mergeValues, resultToName }) {
      return (gen, from, to, toName) => {
        const res = to === void 0 ? from : to instanceof codegen_1.Name ? (from instanceof codegen_1.Name ? mergeNames(gen, from, to) : mergeToName(gen, from, to), to) : from instanceof codegen_1.Name ? (mergeToName(gen, to, from), from) : mergeValues(from, to);
        return toName === codegen_1.Name && !(res instanceof codegen_1.Name) ? resultToName(gen, res) : res;
      };
    }
    exports.mergeEvaluated = {
      props: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => {
          gen.if((0, codegen_1._)`${from} === true`, () => gen.assign(to, true), () => gen.assign(to, (0, codegen_1._)`${to} || {}`).code((0, codegen_1._)`Object.assign(${to}, ${from})`));
        }),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => {
          if (from === true) {
            gen.assign(to, true);
          } else {
            gen.assign(to, (0, codegen_1._)`${to} || {}`);
            setEvaluated(gen, to, from);
          }
        }),
        mergeValues: (from, to) => from === true ? true : { ...from, ...to },
        resultToName: evaluatedPropsToName
      }),
      items: makeMergeEvaluated({
        mergeNames: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true && ${from} !== undefined`, () => gen.assign(to, (0, codegen_1._)`${from} === true ? true : ${to} > ${from} ? ${to} : ${from}`)),
        mergeToName: (gen, from, to) => gen.if((0, codegen_1._)`${to} !== true`, () => gen.assign(to, from === true ? true : (0, codegen_1._)`${to} > ${from} ? ${to} : ${from}`)),
        mergeValues: (from, to) => from === true ? true : Math.max(from, to),
        resultToName: (gen, items) => gen.var("items", items)
      })
    };
    function evaluatedPropsToName(gen, ps) {
      if (ps === true)
        return gen.var("props", true);
      const props = gen.var("props", (0, codegen_1._)`{}`);
      if (ps !== void 0)
        setEvaluated(gen, props, ps);
      return props;
    }
    exports.evaluatedPropsToName = evaluatedPropsToName;
    function setEvaluated(gen, props, ps) {
      Object.keys(ps).forEach((p) => gen.assign((0, codegen_1._)`${props}${(0, codegen_1.getProperty)(p)}`, true));
    }
    exports.setEvaluated = setEvaluated;
    var snippets = {};
    function useFunc(gen, f) {
      return gen.scopeValue("func", {
        ref: f,
        code: snippets[f.code] || (snippets[f.code] = new code_1._Code(f.code))
      });
    }
    exports.useFunc = useFunc;
    var Type;
    (function(Type2) {
      Type2[Type2["Num"] = 0] = "Num";
      Type2[Type2["Str"] = 1] = "Str";
    })(Type || (exports.Type = Type = {}));
    function getErrorPath(dataProp, dataPropType, jsPropertySyntax) {
      if (dataProp instanceof codegen_1.Name) {
        const isNumber = dataPropType === Type.Num;
        return jsPropertySyntax ? isNumber ? (0, codegen_1._)`"[" + ${dataProp} + "]"` : (0, codegen_1._)`"['" + ${dataProp} + "']"` : isNumber ? (0, codegen_1._)`"/" + ${dataProp}` : (0, codegen_1._)`"/" + ${dataProp}.replace(/~/g, "~0").replace(/\\//g, "~1")`;
      }
      return jsPropertySyntax ? (0, codegen_1.getProperty)(dataProp).toString() : "/" + escapeJsonPointer(dataProp);
    }
    exports.getErrorPath = getErrorPath;
    function checkStrictMode(it, msg, mode = it.opts.strictSchema) {
      if (!mode)
        return;
      msg = `strict mode: ${msg}`;
      if (mode === true)
        throw new Error(msg);
      it.self.logger.warn(msg);
    }
    exports.checkStrictMode = checkStrictMode;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/names.js
var require_names2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/names.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var names = {
      // validation function arguments
      data: new codegen_1.Name("data"),
      // data passed to validation function
      // args passed from referencing schema
      valCxt: new codegen_1.Name("valCxt"),
      // validation/data context - should not be used directly, it is destructured to the names below
      instancePath: new codegen_1.Name("instancePath"),
      parentData: new codegen_1.Name("parentData"),
      parentDataProperty: new codegen_1.Name("parentDataProperty"),
      rootData: new codegen_1.Name("rootData"),
      // root data - same as the data passed to the first/top validation function
      dynamicAnchors: new codegen_1.Name("dynamicAnchors"),
      // used to support recursiveRef and dynamicRef
      // function scoped variables
      vErrors: new codegen_1.Name("vErrors"),
      // null or array of validation errors
      errors: new codegen_1.Name("errors"),
      // counter of validation errors
      this: new codegen_1.Name("this"),
      // "globals"
      self: new codegen_1.Name("self"),
      scope: new codegen_1.Name("scope"),
      // JTD serialize/parse name for JSON string and position
      json: new codegen_1.Name("json"),
      jsonPos: new codegen_1.Name("jsonPos"),
      jsonLen: new codegen_1.Name("jsonLen"),
      jsonPart: new codegen_1.Name("jsonPart")
    };
    exports.default = names;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/errors.js
var require_errors2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendErrors = exports.resetErrorsCount = exports.reportExtraError = exports.reportError = exports.keyword$DataError = exports.keywordError = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var names_1 = require_names2();
    exports.keywordError = {
      message: ({ keyword }) => (0, codegen_1.str)`must pass "${keyword}" keyword validation`
    };
    exports.keyword$DataError = {
      message: ({ keyword, schemaType }) => schemaType ? (0, codegen_1.str)`"${keyword}" keyword must be ${schemaType} ($data)` : (0, codegen_1.str)`"${keyword}" keyword is invalid ($data)`
    };
    function reportError(cxt, error = exports.keywordError, errorPaths, overrideAllErrors) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      if (overrideAllErrors !== null && overrideAllErrors !== void 0 ? overrideAllErrors : compositeRule || allErrors) {
        addError(gen, errObj);
      } else {
        returnErrors(it, (0, codegen_1._)`[${errObj}]`);
      }
    }
    exports.reportError = reportError;
    function reportExtraError(cxt, error = exports.keywordError, errorPaths) {
      const { it } = cxt;
      const { gen, compositeRule, allErrors } = it;
      const errObj = errorObjectCode(cxt, error, errorPaths);
      addError(gen, errObj);
      if (!(compositeRule || allErrors)) {
        returnErrors(it, names_1.default.vErrors);
      }
    }
    exports.reportExtraError = reportExtraError;
    function resetErrorsCount(gen, errsCount) {
      gen.assign(names_1.default.errors, errsCount);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} !== null`, () => gen.if(errsCount, () => gen.assign((0, codegen_1._)`${names_1.default.vErrors}.length`, errsCount), () => gen.assign(names_1.default.vErrors, null)));
    }
    exports.resetErrorsCount = resetErrorsCount;
    function extendErrors({ gen, keyword, schemaValue, data, errsCount, it }) {
      if (errsCount === void 0)
        throw new Error("ajv implementation error");
      const err = gen.name("err");
      gen.forRange("i", errsCount, names_1.default.errors, (i) => {
        gen.const(err, (0, codegen_1._)`${names_1.default.vErrors}[${i}]`);
        gen.if((0, codegen_1._)`${err}.instancePath === undefined`, () => gen.assign((0, codegen_1._)`${err}.instancePath`, (0, codegen_1.strConcat)(names_1.default.instancePath, it.errorPath)));
        gen.assign((0, codegen_1._)`${err}.schemaPath`, (0, codegen_1.str)`${it.errSchemaPath}/${keyword}`);
        if (it.opts.verbose) {
          gen.assign((0, codegen_1._)`${err}.schema`, schemaValue);
          gen.assign((0, codegen_1._)`${err}.data`, data);
        }
      });
    }
    exports.extendErrors = extendErrors;
    function addError(gen, errObj) {
      const err = gen.const("err", errObj);
      gen.if((0, codegen_1._)`${names_1.default.vErrors} === null`, () => gen.assign(names_1.default.vErrors, (0, codegen_1._)`[${err}]`), (0, codegen_1._)`${names_1.default.vErrors}.push(${err})`);
      gen.code((0, codegen_1._)`${names_1.default.errors}++`);
    }
    function returnErrors(it, errs) {
      const { gen, validateName, schemaEnv } = it;
      if (schemaEnv.$async) {
        gen.throw((0, codegen_1._)`new ${it.ValidationError}(${errs})`);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, errs);
        gen.return(false);
      }
    }
    var E = {
      keyword: new codegen_1.Name("keyword"),
      schemaPath: new codegen_1.Name("schemaPath"),
      // also used in JTD errors
      params: new codegen_1.Name("params"),
      propertyName: new codegen_1.Name("propertyName"),
      message: new codegen_1.Name("message"),
      schema: new codegen_1.Name("schema"),
      parentSchema: new codegen_1.Name("parentSchema")
    };
    function errorObjectCode(cxt, error, errorPaths) {
      const { createErrors } = cxt.it;
      if (createErrors === false)
        return (0, codegen_1._)`{}`;
      return errorObject(cxt, error, errorPaths);
    }
    function errorObject(cxt, error, errorPaths = {}) {
      const { gen, it } = cxt;
      const keyValues = [
        errorInstancePath(it, errorPaths),
        errorSchemaPath(cxt, errorPaths)
      ];
      extraErrorProps(cxt, error, keyValues);
      return gen.object(...keyValues);
    }
    function errorInstancePath({ errorPath }, { instancePath }) {
      const instPath = instancePath ? (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(instancePath, util_1.Type.Str)}` : errorPath;
      return [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, instPath)];
    }
    function errorSchemaPath({ keyword, it: { errSchemaPath } }, { schemaPath, parentSchema }) {
      let schPath = parentSchema ? errSchemaPath : (0, codegen_1.str)`${errSchemaPath}/${keyword}`;
      if (schemaPath) {
        schPath = (0, codegen_1.str)`${schPath}${(0, util_1.getErrorPath)(schemaPath, util_1.Type.Str)}`;
      }
      return [E.schemaPath, schPath];
    }
    function extraErrorProps(cxt, { params, message }, keyValues) {
      const { keyword, data, schemaValue, it } = cxt;
      const { opts, propertyName, topSchemaRef, schemaPath } = it;
      keyValues.push([E.keyword, keyword], [E.params, typeof params == "function" ? params(cxt) : params || (0, codegen_1._)`{}`]);
      if (opts.messages) {
        keyValues.push([E.message, typeof message == "function" ? message(cxt) : message]);
      }
      if (opts.verbose) {
        keyValues.push([E.schema, schemaValue], [E.parentSchema, (0, codegen_1._)`${topSchemaRef}${schemaPath}`], [names_1.default.data, data]);
      }
      if (propertyName)
        keyValues.push([E.propertyName, propertyName]);
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/boolSchema.js
var require_boolSchema2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/boolSchema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.boolOrEmptySchema = exports.topBoolOrEmptySchema = void 0;
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var boolError = {
      message: "boolean schema is false"
    };
    function topBoolOrEmptySchema(it) {
      const { gen, schema, validateName } = it;
      if (schema === false) {
        falseSchemaError(it, false);
      } else if (typeof schema == "object" && schema.$async === true) {
        gen.return(names_1.default.data);
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, null);
        gen.return(true);
      }
    }
    exports.topBoolOrEmptySchema = topBoolOrEmptySchema;
    function boolOrEmptySchema(it, valid) {
      const { gen, schema } = it;
      if (schema === false) {
        gen.var(valid, false);
        falseSchemaError(it);
      } else {
        gen.var(valid, true);
      }
    }
    exports.boolOrEmptySchema = boolOrEmptySchema;
    function falseSchemaError(it, overrideAllErrors) {
      const { gen, data } = it;
      const cxt = {
        gen,
        keyword: "false schema",
        data,
        schema: false,
        schemaCode: false,
        schemaValue: false,
        params: {},
        it
      };
      (0, errors_1.reportError)(cxt, boolError, void 0, overrideAllErrors);
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/rules.js
var require_rules2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/rules.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRules = exports.isJSONType = void 0;
    var _jsonTypes = ["string", "number", "integer", "boolean", "null", "object", "array"];
    var jsonTypes = new Set(_jsonTypes);
    function isJSONType(x) {
      return typeof x == "string" && jsonTypes.has(x);
    }
    exports.isJSONType = isJSONType;
    function getRules() {
      const groups = {
        number: { type: "number", rules: [] },
        string: { type: "string", rules: [] },
        array: { type: "array", rules: [] },
        object: { type: "object", rules: [] }
      };
      return {
        types: { ...groups, integer: true, boolean: true, null: true },
        rules: [{ rules: [] }, groups.number, groups.string, groups.array, groups.object],
        post: { rules: [] },
        all: {},
        keywords: {}
      };
    }
    exports.getRules = getRules;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/applicability.js
var require_applicability2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/applicability.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldUseRule = exports.shouldUseGroup = exports.schemaHasRulesForType = void 0;
    function schemaHasRulesForType({ schema, self }, type) {
      const group = self.RULES.types[type];
      return group && group !== true && shouldUseGroup(schema, group);
    }
    exports.schemaHasRulesForType = schemaHasRulesForType;
    function shouldUseGroup(schema, group) {
      return group.rules.some((rule) => shouldUseRule(schema, rule));
    }
    exports.shouldUseGroup = shouldUseGroup;
    function shouldUseRule(schema, rule) {
      var _a13;
      return schema[rule.keyword] !== void 0 || ((_a13 = rule.definition.implements) === null || _a13 === void 0 ? void 0 : _a13.some((kwd) => schema[kwd] !== void 0));
    }
    exports.shouldUseRule = shouldUseRule;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/dataType.js
var require_dataType2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/dataType.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.reportTypeError = exports.checkDataTypes = exports.checkDataType = exports.coerceAndCheckDataType = exports.getJSONTypes = exports.getSchemaTypes = exports.DataType = void 0;
    var rules_1 = require_rules2();
    var applicability_1 = require_applicability2();
    var errors_1 = require_errors2();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var DataType;
    (function(DataType2) {
      DataType2[DataType2["Correct"] = 0] = "Correct";
      DataType2[DataType2["Wrong"] = 1] = "Wrong";
    })(DataType || (exports.DataType = DataType = {}));
    function getSchemaTypes(schema) {
      const types = getJSONTypes(schema.type);
      const hasNull = types.includes("null");
      if (hasNull) {
        if (schema.nullable === false)
          throw new Error("type: null contradicts nullable: false");
      } else {
        if (!types.length && schema.nullable !== void 0) {
          throw new Error('"nullable" cannot be used without "type"');
        }
        if (schema.nullable === true)
          types.push("null");
      }
      return types;
    }
    exports.getSchemaTypes = getSchemaTypes;
    function getJSONTypes(ts) {
      const types = Array.isArray(ts) ? ts : ts ? [ts] : [];
      if (types.every(rules_1.isJSONType))
        return types;
      throw new Error("type must be JSONType or JSONType[]: " + types.join(","));
    }
    exports.getJSONTypes = getJSONTypes;
    function coerceAndCheckDataType(it, types) {
      const { gen, data, opts } = it;
      const coerceTo = coerceToTypes(types, opts.coerceTypes);
      const checkTypes = types.length > 0 && !(coerceTo.length === 0 && types.length === 1 && (0, applicability_1.schemaHasRulesForType)(it, types[0]));
      if (checkTypes) {
        const wrongType = checkDataTypes(types, data, opts.strictNumbers, DataType.Wrong);
        gen.if(wrongType, () => {
          if (coerceTo.length)
            coerceData(it, types, coerceTo);
          else
            reportTypeError(it);
        });
      }
      return checkTypes;
    }
    exports.coerceAndCheckDataType = coerceAndCheckDataType;
    var COERCIBLE = /* @__PURE__ */ new Set(["string", "number", "integer", "boolean", "null"]);
    function coerceToTypes(types, coerceTypes) {
      return coerceTypes ? types.filter((t2) => COERCIBLE.has(t2) || coerceTypes === "array" && t2 === "array") : [];
    }
    function coerceData(it, types, coerceTo) {
      const { gen, data, opts } = it;
      const dataType = gen.let("dataType", (0, codegen_1._)`typeof ${data}`);
      const coerced = gen.let("coerced", (0, codegen_1._)`undefined`);
      if (opts.coerceTypes === "array") {
        gen.if((0, codegen_1._)`${dataType} == 'object' && Array.isArray(${data}) && ${data}.length == 1`, () => gen.assign(data, (0, codegen_1._)`${data}[0]`).assign(dataType, (0, codegen_1._)`typeof ${data}`).if(checkDataTypes(types, data, opts.strictNumbers), () => gen.assign(coerced, data)));
      }
      gen.if((0, codegen_1._)`${coerced} !== undefined`);
      for (const t2 of coerceTo) {
        if (COERCIBLE.has(t2) || t2 === "array" && opts.coerceTypes === "array") {
          coerceSpecificType(t2);
        }
      }
      gen.else();
      reportTypeError(it);
      gen.endIf();
      gen.if((0, codegen_1._)`${coerced} !== undefined`, () => {
        gen.assign(data, coerced);
        assignParentData(it, coerced);
      });
      function coerceSpecificType(t2) {
        switch (t2) {
          case "string":
            gen.elseIf((0, codegen_1._)`${dataType} == "number" || ${dataType} == "boolean"`).assign(coerced, (0, codegen_1._)`"" + ${data}`).elseIf((0, codegen_1._)`${data} === null`).assign(coerced, (0, codegen_1._)`""`);
            return;
          case "number":
            gen.elseIf((0, codegen_1._)`${dataType} == "boolean" || ${data} === null
              || (${dataType} == "string" && ${data} && ${data} == +${data})`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "integer":
            gen.elseIf((0, codegen_1._)`${dataType} === "boolean" || ${data} === null
              || (${dataType} === "string" && ${data} && ${data} == +${data} && !(${data} % 1))`).assign(coerced, (0, codegen_1._)`+${data}`);
            return;
          case "boolean":
            gen.elseIf((0, codegen_1._)`${data} === "false" || ${data} === 0 || ${data} === null`).assign(coerced, false).elseIf((0, codegen_1._)`${data} === "true" || ${data} === 1`).assign(coerced, true);
            return;
          case "null":
            gen.elseIf((0, codegen_1._)`${data} === "" || ${data} === 0 || ${data} === false`);
            gen.assign(coerced, null);
            return;
          case "array":
            gen.elseIf((0, codegen_1._)`${dataType} === "string" || ${dataType} === "number"
              || ${dataType} === "boolean" || ${data} === null`).assign(coerced, (0, codegen_1._)`[${data}]`);
        }
      }
    }
    function assignParentData({ gen, parentData, parentDataProperty }, expr) {
      gen.if((0, codegen_1._)`${parentData} !== undefined`, () => gen.assign((0, codegen_1._)`${parentData}[${parentDataProperty}]`, expr));
    }
    function checkDataType(dataType, data, strictNums, correct = DataType.Correct) {
      const EQ = correct === DataType.Correct ? codegen_1.operators.EQ : codegen_1.operators.NEQ;
      let cond;
      switch (dataType) {
        case "null":
          return (0, codegen_1._)`${data} ${EQ} null`;
        case "array":
          cond = (0, codegen_1._)`Array.isArray(${data})`;
          break;
        case "object":
          cond = (0, codegen_1._)`${data} && typeof ${data} == "object" && !Array.isArray(${data})`;
          break;
        case "integer":
          cond = numCond((0, codegen_1._)`!(${data} % 1) && !isNaN(${data})`);
          break;
        case "number":
          cond = numCond();
          break;
        default:
          return (0, codegen_1._)`typeof ${data} ${EQ} ${dataType}`;
      }
      return correct === DataType.Correct ? cond : (0, codegen_1.not)(cond);
      function numCond(_cond = codegen_1.nil) {
        return (0, codegen_1.and)((0, codegen_1._)`typeof ${data} == "number"`, _cond, strictNums ? (0, codegen_1._)`isFinite(${data})` : codegen_1.nil);
      }
    }
    exports.checkDataType = checkDataType;
    function checkDataTypes(dataTypes, data, strictNums, correct) {
      if (dataTypes.length === 1) {
        return checkDataType(dataTypes[0], data, strictNums, correct);
      }
      let cond;
      const types = (0, util_1.toHash)(dataTypes);
      if (types.array && types.object) {
        const notObj = (0, codegen_1._)`typeof ${data} != "object"`;
        cond = types.null ? notObj : (0, codegen_1._)`!${data} || ${notObj}`;
        delete types.null;
        delete types.array;
        delete types.object;
      } else {
        cond = codegen_1.nil;
      }
      if (types.number)
        delete types.integer;
      for (const t2 in types)
        cond = (0, codegen_1.and)(cond, checkDataType(t2, data, strictNums, correct));
      return cond;
    }
    exports.checkDataTypes = checkDataTypes;
    var typeError = {
      message: ({ schema }) => `must be ${schema}`,
      params: ({ schema, schemaValue }) => typeof schema == "string" ? (0, codegen_1._)`{type: ${schema}}` : (0, codegen_1._)`{type: ${schemaValue}}`
    };
    function reportTypeError(it) {
      const cxt = getTypeErrorContext(it);
      (0, errors_1.reportError)(cxt, typeError);
    }
    exports.reportTypeError = reportTypeError;
    function getTypeErrorContext(it) {
      const { gen, data, schema } = it;
      const schemaCode = (0, util_1.schemaRefOrVal)(it, schema, "type");
      return {
        gen,
        keyword: "type",
        data,
        schema: schema.type,
        schemaCode,
        schemaValue: schemaCode,
        parentSchema: schema,
        params: {},
        it
      };
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/defaults.js
var require_defaults2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/defaults.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assignDefaults = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    function assignDefaults(it, ty) {
      const { properties, items } = it.schema;
      if (ty === "object" && properties) {
        for (const key in properties) {
          assignDefault(it, key, properties[key].default);
        }
      } else if (ty === "array" && Array.isArray(items)) {
        items.forEach((sch, i) => assignDefault(it, i, sch.default));
      }
    }
    exports.assignDefaults = assignDefaults;
    function assignDefault(it, prop, defaultValue) {
      const { gen, compositeRule, data, opts } = it;
      if (defaultValue === void 0)
        return;
      const childData = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(prop)}`;
      if (compositeRule) {
        (0, util_1.checkStrictMode)(it, `default is ignored for: ${childData}`);
        return;
      }
      let condition = (0, codegen_1._)`${childData} === undefined`;
      if (opts.useDefaults === "empty") {
        condition = (0, codegen_1._)`${condition} || ${childData} === null || ${childData} === ""`;
      }
      gen.if(condition, (0, codegen_1._)`${childData} = ${(0, codegen_1.stringify)(defaultValue)}`);
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/code.js
var require_code4 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/code.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateUnion = exports.validateArray = exports.usePattern = exports.callValidateCode = exports.schemaProperties = exports.allSchemaProperties = exports.noPropertyInData = exports.propertyInData = exports.isOwnProperty = exports.hasPropFunc = exports.reportMissingProp = exports.checkMissingProp = exports.checkReportMissingProp = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var names_1 = require_names2();
    var util_2 = require_util2();
    function checkReportMissingProp(cxt, prop) {
      const { gen, data, it } = cxt;
      gen.if(noPropertyInData(gen, data, prop, it.opts.ownProperties), () => {
        cxt.setParams({ missingProperty: (0, codegen_1._)`${prop}` }, true);
        cxt.error();
      });
    }
    exports.checkReportMissingProp = checkReportMissingProp;
    function checkMissingProp({ gen, data, it: { opts } }, properties, missing) {
      return (0, codegen_1.or)(...properties.map((prop) => (0, codegen_1.and)(noPropertyInData(gen, data, prop, opts.ownProperties), (0, codegen_1._)`${missing} = ${prop}`)));
    }
    exports.checkMissingProp = checkMissingProp;
    function reportMissingProp(cxt, missing) {
      cxt.setParams({ missingProperty: missing }, true);
      cxt.error();
    }
    exports.reportMissingProp = reportMissingProp;
    function hasPropFunc(gen) {
      return gen.scopeValue("func", {
        // eslint-disable-next-line @typescript-eslint/unbound-method
        ref: Object.prototype.hasOwnProperty,
        code: (0, codegen_1._)`Object.prototype.hasOwnProperty`
      });
    }
    exports.hasPropFunc = hasPropFunc;
    function isOwnProperty(gen, data, property) {
      return (0, codegen_1._)`${hasPropFunc(gen)}.call(${data}, ${property})`;
    }
    exports.isOwnProperty = isOwnProperty;
    function propertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} !== undefined`;
      return ownProperties ? (0, codegen_1._)`${cond} && ${isOwnProperty(gen, data, property)}` : cond;
    }
    exports.propertyInData = propertyInData;
    function noPropertyInData(gen, data, property, ownProperties) {
      const cond = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(property)} === undefined`;
      return ownProperties ? (0, codegen_1.or)(cond, (0, codegen_1.not)(isOwnProperty(gen, data, property))) : cond;
    }
    exports.noPropertyInData = noPropertyInData;
    function allSchemaProperties(schemaMap) {
      return schemaMap ? Object.keys(schemaMap).filter((p) => p !== "__proto__") : [];
    }
    exports.allSchemaProperties = allSchemaProperties;
    function schemaProperties(it, schemaMap) {
      return allSchemaProperties(schemaMap).filter((p) => !(0, util_1.alwaysValidSchema)(it, schemaMap[p]));
    }
    exports.schemaProperties = schemaProperties;
    function callValidateCode({ schemaCode, data, it: { gen, topSchemaRef, schemaPath, errorPath }, it }, func, context, passSchema) {
      const dataAndSchema = passSchema ? (0, codegen_1._)`${schemaCode}, ${data}, ${topSchemaRef}${schemaPath}` : data;
      const valCxt = [
        [names_1.default.instancePath, (0, codegen_1.strConcat)(names_1.default.instancePath, errorPath)],
        [names_1.default.parentData, it.parentData],
        [names_1.default.parentDataProperty, it.parentDataProperty],
        [names_1.default.rootData, names_1.default.rootData]
      ];
      if (it.opts.dynamicRef)
        valCxt.push([names_1.default.dynamicAnchors, names_1.default.dynamicAnchors]);
      const args = (0, codegen_1._)`${dataAndSchema}, ${gen.object(...valCxt)}`;
      return context !== codegen_1.nil ? (0, codegen_1._)`${func}.call(${context}, ${args})` : (0, codegen_1._)`${func}(${args})`;
    }
    exports.callValidateCode = callValidateCode;
    var newRegExp = (0, codegen_1._)`new RegExp`;
    function usePattern({ gen, it: { opts } }, pattern) {
      const u2 = opts.unicodeRegExp ? "u" : "";
      const { regExp } = opts.code;
      const rx = regExp(pattern, u2);
      return gen.scopeValue("pattern", {
        key: rx.toString(),
        ref: rx,
        code: (0, codegen_1._)`${regExp.code === "new RegExp" ? newRegExp : (0, util_2.useFunc)(gen, regExp)}(${pattern}, ${u2})`
      });
    }
    exports.usePattern = usePattern;
    function validateArray(cxt) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      if (it.allErrors) {
        const validArr = gen.let("valid", true);
        validateItems(() => gen.assign(validArr, false));
        return validArr;
      }
      gen.var(valid, true);
      validateItems(() => gen.break());
      return valid;
      function validateItems(notValid) {
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        gen.forRange("i", 0, len, (i) => {
          cxt.subschema({
            keyword,
            dataProp: i,
            dataPropType: util_1.Type.Num
          }, valid);
          gen.if((0, codegen_1.not)(valid), notValid);
        });
      }
    }
    exports.validateArray = validateArray;
    function validateUnion(cxt) {
      const { gen, schema, keyword, it } = cxt;
      if (!Array.isArray(schema))
        throw new Error("ajv implementation error");
      const alwaysValid = schema.some((sch) => (0, util_1.alwaysValidSchema)(it, sch));
      if (alwaysValid && !it.opts.unevaluated)
        return;
      const valid = gen.let("valid", false);
      const schValid = gen.name("_valid");
      gen.block(() => schema.forEach((_sch, i) => {
        const schCxt = cxt.subschema({
          keyword,
          schemaProp: i,
          compositeRule: true
        }, schValid);
        gen.assign(valid, (0, codegen_1._)`${valid} || ${schValid}`);
        const merged = cxt.mergeValidEvaluated(schCxt, schValid);
        if (!merged)
          gen.if((0, codegen_1.not)(valid));
      }));
      cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
    }
    exports.validateUnion = validateUnion;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/keyword.js
var require_keyword2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/keyword.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateKeywordUsage = exports.validSchemaType = exports.funcKeywordCode = exports.macroKeywordCode = void 0;
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var code_1 = require_code4();
    var errors_1 = require_errors2();
    function macroKeywordCode(cxt, def) {
      const { gen, keyword, schema, parentSchema, it } = cxt;
      const macroSchema = def.macro.call(it.self, schema, parentSchema, it);
      const schemaRef = useKeyword(gen, keyword, macroSchema);
      if (it.opts.validateSchema !== false)
        it.self.validateSchema(macroSchema, true);
      const valid = gen.name("valid");
      cxt.subschema({
        schema: macroSchema,
        schemaPath: codegen_1.nil,
        errSchemaPath: `${it.errSchemaPath}/${keyword}`,
        topSchemaRef: schemaRef,
        compositeRule: true
      }, valid);
      cxt.pass(valid, () => cxt.error(true));
    }
    exports.macroKeywordCode = macroKeywordCode;
    function funcKeywordCode(cxt, def) {
      var _a13;
      const { gen, keyword, schema, parentSchema, $data, it } = cxt;
      checkAsyncKeyword(it, def);
      const validate = !$data && def.compile ? def.compile.call(it.self, schema, parentSchema, it) : def.validate;
      const validateRef = useKeyword(gen, keyword, validate);
      const valid = gen.let("valid");
      cxt.block$data(valid, validateKeyword);
      cxt.ok((_a13 = def.valid) !== null && _a13 !== void 0 ? _a13 : valid);
      function validateKeyword() {
        if (def.errors === false) {
          assignValid();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => cxt.error());
        } else {
          const ruleErrs = def.async ? validateAsync() : validateSync();
          if (def.modifying)
            modifyData(cxt);
          reportErrs(() => addErrs(cxt, ruleErrs));
        }
      }
      function validateAsync() {
        const ruleErrs = gen.let("ruleErrs", null);
        gen.try(() => assignValid((0, codegen_1._)`await `), (e2) => gen.assign(valid, false).if((0, codegen_1._)`${e2} instanceof ${it.ValidationError}`, () => gen.assign(ruleErrs, (0, codegen_1._)`${e2}.errors`), () => gen.throw(e2)));
        return ruleErrs;
      }
      function validateSync() {
        const validateErrs = (0, codegen_1._)`${validateRef}.errors`;
        gen.assign(validateErrs, null);
        assignValid(codegen_1.nil);
        return validateErrs;
      }
      function assignValid(_await = def.async ? (0, codegen_1._)`await ` : codegen_1.nil) {
        const passCxt = it.opts.passContext ? names_1.default.this : names_1.default.self;
        const passSchema = !("compile" in def && !$data || def.schema === false);
        gen.assign(valid, (0, codegen_1._)`${_await}${(0, code_1.callValidateCode)(cxt, validateRef, passCxt, passSchema)}`, def.modifying);
      }
      function reportErrs(errors) {
        var _a14;
        gen.if((0, codegen_1.not)((_a14 = def.valid) !== null && _a14 !== void 0 ? _a14 : valid), errors);
      }
    }
    exports.funcKeywordCode = funcKeywordCode;
    function modifyData(cxt) {
      const { gen, data, it } = cxt;
      gen.if(it.parentData, () => gen.assign(data, (0, codegen_1._)`${it.parentData}[${it.parentDataProperty}]`));
    }
    function addErrs(cxt, errs) {
      const { gen } = cxt;
      gen.if((0, codegen_1._)`Array.isArray(${errs})`, () => {
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`).assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
        (0, errors_1.extendErrors)(cxt);
      }, () => cxt.error());
    }
    function checkAsyncKeyword({ schemaEnv }, def) {
      if (def.async && !schemaEnv.$async)
        throw new Error("async keyword in sync schema");
    }
    function useKeyword(gen, keyword, result) {
      if (result === void 0)
        throw new Error(`keyword "${keyword}" failed to compile`);
      return gen.scopeValue("keyword", typeof result == "function" ? { ref: result } : { ref: result, code: (0, codegen_1.stringify)(result) });
    }
    function validSchemaType(schema, schemaType, allowUndefined = false) {
      return !schemaType.length || schemaType.some((st) => st === "array" ? Array.isArray(schema) : st === "object" ? schema && typeof schema == "object" && !Array.isArray(schema) : typeof schema == st || allowUndefined && typeof schema == "undefined");
    }
    exports.validSchemaType = validSchemaType;
    function validateKeywordUsage({ schema, opts, self, errSchemaPath }, def, keyword) {
      if (Array.isArray(def.keyword) ? !def.keyword.includes(keyword) : def.keyword !== keyword) {
        throw new Error("ajv implementation error");
      }
      const deps = def.dependencies;
      if (deps === null || deps === void 0 ? void 0 : deps.some((kwd) => !Object.prototype.hasOwnProperty.call(schema, kwd))) {
        throw new Error(`parent schema must have dependencies of ${keyword}: ${deps.join(",")}`);
      }
      if (def.validateSchema) {
        const valid = def.validateSchema(schema[keyword]);
        if (!valid) {
          const msg = `keyword "${keyword}" value is invalid at path "${errSchemaPath}": ` + self.errorsText(def.validateSchema.errors);
          if (opts.validateSchema === "log")
            self.logger.error(msg);
          else
            throw new Error(msg);
        }
      }
    }
    exports.validateKeywordUsage = validateKeywordUsage;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/subschema.js
var require_subschema2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/subschema.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.extendSubschemaMode = exports.extendSubschemaData = exports.getSubschema = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    function getSubschema(it, { keyword, schemaProp, schema, schemaPath, errSchemaPath, topSchemaRef }) {
      if (keyword !== void 0 && schema !== void 0) {
        throw new Error('both "keyword" and "schema" passed, only one allowed');
      }
      if (keyword !== void 0) {
        const sch = it.schema[keyword];
        return schemaProp === void 0 ? {
          schema: sch,
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}`
        } : {
          schema: sch[schemaProp],
          schemaPath: (0, codegen_1._)`${it.schemaPath}${(0, codegen_1.getProperty)(keyword)}${(0, codegen_1.getProperty)(schemaProp)}`,
          errSchemaPath: `${it.errSchemaPath}/${keyword}/${(0, util_1.escapeFragment)(schemaProp)}`
        };
      }
      if (schema !== void 0) {
        if (schemaPath === void 0 || errSchemaPath === void 0 || topSchemaRef === void 0) {
          throw new Error('"schemaPath", "errSchemaPath" and "topSchemaRef" are required with "schema"');
        }
        return {
          schema,
          schemaPath,
          topSchemaRef,
          errSchemaPath
        };
      }
      throw new Error('either "keyword" or "schema" must be passed');
    }
    exports.getSubschema = getSubschema;
    function extendSubschemaData(subschema, it, { dataProp, dataPropType: dpType, data, dataTypes, propertyName }) {
      if (data !== void 0 && dataProp !== void 0) {
        throw new Error('both "data" and "dataProp" passed, only one allowed');
      }
      const { gen } = it;
      if (dataProp !== void 0) {
        const { errorPath, dataPathArr, opts } = it;
        const nextData = gen.let("data", (0, codegen_1._)`${it.data}${(0, codegen_1.getProperty)(dataProp)}`, true);
        dataContextProps(nextData);
        subschema.errorPath = (0, codegen_1.str)`${errorPath}${(0, util_1.getErrorPath)(dataProp, dpType, opts.jsPropertySyntax)}`;
        subschema.parentDataProperty = (0, codegen_1._)`${dataProp}`;
        subschema.dataPathArr = [...dataPathArr, subschema.parentDataProperty];
      }
      if (data !== void 0) {
        const nextData = data instanceof codegen_1.Name ? data : gen.let("data", data, true);
        dataContextProps(nextData);
        if (propertyName !== void 0)
          subschema.propertyName = propertyName;
      }
      if (dataTypes)
        subschema.dataTypes = dataTypes;
      function dataContextProps(_nextData) {
        subschema.data = _nextData;
        subschema.dataLevel = it.dataLevel + 1;
        subschema.dataTypes = [];
        it.definedProperties = /* @__PURE__ */ new Set();
        subschema.parentData = it.data;
        subschema.dataNames = [...it.dataNames, _nextData];
      }
    }
    exports.extendSubschemaData = extendSubschemaData;
    function extendSubschemaMode(subschema, { jtdDiscriminator, jtdMetadata, compositeRule, createErrors, allErrors }) {
      if (compositeRule !== void 0)
        subschema.compositeRule = compositeRule;
      if (createErrors !== void 0)
        subschema.createErrors = createErrors;
      if (allErrors !== void 0)
        subschema.allErrors = allErrors;
      subschema.jtdDiscriminator = jtdDiscriminator;
      subschema.jtdMetadata = jtdMetadata;
    }
    exports.extendSubschemaMode = extendSubschemaMode;
  }
});

// node_modules/ajv-formats/node_modules/json-schema-traverse/index.js
var require_json_schema_traverse2 = __commonJS({
  "node_modules/ajv-formats/node_modules/json-schema-traverse/index.js"(exports, module) {
    "use strict";
    var traverse = module.exports = function(schema, opts, cb) {
      if (typeof opts == "function") {
        cb = opts;
        opts = {};
      }
      cb = opts.cb || cb;
      var pre = typeof cb == "function" ? cb : cb.pre || function() {
      };
      var post = cb.post || function() {
      };
      _traverse(opts, pre, post, schema, "", schema);
    };
    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true,
      if: true,
      then: true,
      else: true
    };
    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };
    traverse.propsKeywords = {
      $defs: true,
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };
    traverse.skipKeywords = {
      default: true,
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };
    function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == "object" && !Array.isArray(schema)) {
        pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++)
                _traverse(opts, pre, post, sch[i], jsonPtr + "/" + key + "/" + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == "object") {
              for (var prop in sch)
                _traverse(opts, pre, post, sch[prop], jsonPtr + "/" + key + "/" + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, pre, post, sch, jsonPtr + "/" + key, rootSchema, jsonPtr, key, schema);
          }
        }
        post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
      }
    }
    function escapeJsonPtr(str) {
      return str.replace(/~/g, "~0").replace(/\//g, "~1");
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/resolve.js
var require_resolve2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/resolve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSchemaRefs = exports.resolveUrl = exports.normalizeId = exports._getFullPath = exports.getFullPath = exports.inlineRef = void 0;
    var util_1 = require_util2();
    var equal = require_fast_deep_equal();
    var traverse = require_json_schema_traverse2();
    var SIMPLE_INLINED = /* @__PURE__ */ new Set([
      "type",
      "format",
      "pattern",
      "maxLength",
      "minLength",
      "maxProperties",
      "minProperties",
      "maxItems",
      "minItems",
      "maximum",
      "minimum",
      "uniqueItems",
      "multipleOf",
      "required",
      "enum",
      "const"
    ]);
    function inlineRef(schema, limit = true) {
      if (typeof schema == "boolean")
        return true;
      if (limit === true)
        return !hasRef(schema);
      if (!limit)
        return false;
      return countKeys(schema) <= limit;
    }
    exports.inlineRef = inlineRef;
    var REF_KEYWORDS = /* @__PURE__ */ new Set([
      "$ref",
      "$recursiveRef",
      "$recursiveAnchor",
      "$dynamicRef",
      "$dynamicAnchor"
    ]);
    function hasRef(schema) {
      for (const key in schema) {
        if (REF_KEYWORDS.has(key))
          return true;
        const sch = schema[key];
        if (Array.isArray(sch) && sch.some(hasRef))
          return true;
        if (typeof sch == "object" && hasRef(sch))
          return true;
      }
      return false;
    }
    function countKeys(schema) {
      let count = 0;
      for (const key in schema) {
        if (key === "$ref")
          return Infinity;
        count++;
        if (SIMPLE_INLINED.has(key))
          continue;
        if (typeof schema[key] == "object") {
          (0, util_1.eachItem)(schema[key], (sch) => count += countKeys(sch));
        }
        if (count === Infinity)
          return Infinity;
      }
      return count;
    }
    function getFullPath(resolver, id = "", normalize) {
      if (normalize !== false)
        id = normalizeId(id);
      const p = resolver.parse(id);
      return _getFullPath(resolver, p);
    }
    exports.getFullPath = getFullPath;
    function _getFullPath(resolver, p) {
      const serialized = resolver.serialize(p);
      return serialized.split("#")[0] + "#";
    }
    exports._getFullPath = _getFullPath;
    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, "") : "";
    }
    exports.normalizeId = normalizeId;
    function resolveUrl(resolver, baseId, id) {
      id = normalizeId(id);
      return resolver.resolve(baseId, id);
    }
    exports.resolveUrl = resolveUrl;
    var ANCHOR = /^[a-z_][-a-z0-9._]*$/i;
    function getSchemaRefs(schema, baseId) {
      if (typeof schema == "boolean")
        return {};
      const { schemaId, uriResolver } = this.opts;
      const schId = normalizeId(schema[schemaId] || baseId);
      const baseIds = { "": schId };
      const pathPrefix = getFullPath(uriResolver, schId, false);
      const localRefs = {};
      const schemaRefs = /* @__PURE__ */ new Set();
      traverse(schema, { allKeys: true }, (sch, jsonPtr, _, parentJsonPtr) => {
        if (parentJsonPtr === void 0)
          return;
        const fullPath = pathPrefix + jsonPtr;
        let innerBaseId = baseIds[parentJsonPtr];
        if (typeof sch[schemaId] == "string")
          innerBaseId = addRef.call(this, sch[schemaId]);
        addAnchor.call(this, sch.$anchor);
        addAnchor.call(this, sch.$dynamicAnchor);
        baseIds[jsonPtr] = innerBaseId;
        function addRef(ref) {
          const _resolve = this.opts.uriResolver.resolve;
          ref = normalizeId(innerBaseId ? _resolve(innerBaseId, ref) : ref);
          if (schemaRefs.has(ref))
            throw ambiguos(ref);
          schemaRefs.add(ref);
          let schOrRef = this.refs[ref];
          if (typeof schOrRef == "string")
            schOrRef = this.refs[schOrRef];
          if (typeof schOrRef == "object") {
            checkAmbiguosRef(sch, schOrRef.schema, ref);
          } else if (ref !== normalizeId(fullPath)) {
            if (ref[0] === "#") {
              checkAmbiguosRef(sch, localRefs[ref], ref);
              localRefs[ref] = sch;
            } else {
              this.refs[ref] = fullPath;
            }
          }
          return ref;
        }
        function addAnchor(anchor) {
          if (typeof anchor == "string") {
            if (!ANCHOR.test(anchor))
              throw new Error(`invalid anchor "${anchor}"`);
            addRef.call(this, `#${anchor}`);
          }
        }
      });
      return localRefs;
      function checkAmbiguosRef(sch1, sch2, ref) {
        if (sch2 !== void 0 && !equal(sch1, sch2))
          throw ambiguos(ref);
      }
      function ambiguos(ref) {
        return new Error(`reference "${ref}" resolves to more than one schema`);
      }
    }
    exports.getSchemaRefs = getSchemaRefs;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/index.js
var require_validate2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/validate/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getData = exports.KeywordCxt = exports.validateFunctionCode = void 0;
    var boolSchema_1 = require_boolSchema2();
    var dataType_1 = require_dataType2();
    var applicability_1 = require_applicability2();
    var dataType_2 = require_dataType2();
    var defaults_1 = require_defaults2();
    var keyword_1 = require_keyword2();
    var subschema_1 = require_subschema2();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var resolve_1 = require_resolve2();
    var util_1 = require_util2();
    var errors_1 = require_errors2();
    function validateFunctionCode(it) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          topSchemaObjCode(it);
          return;
        }
      }
      validateFunction(it, () => (0, boolSchema_1.topBoolOrEmptySchema)(it));
    }
    exports.validateFunctionCode = validateFunctionCode;
    function validateFunction({ gen, validateName, schema, schemaEnv, opts }, body) {
      if (opts.code.es5) {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${names_1.default.valCxt}`, schemaEnv.$async, () => {
          gen.code((0, codegen_1._)`"use strict"; ${funcSourceUrl(schema, opts)}`);
          destructureValCxtES5(gen, opts);
          gen.code(body);
        });
      } else {
        gen.func(validateName, (0, codegen_1._)`${names_1.default.data}, ${destructureValCxt(opts)}`, schemaEnv.$async, () => gen.code(funcSourceUrl(schema, opts)).code(body));
      }
    }
    function destructureValCxt(opts) {
      return (0, codegen_1._)`{${names_1.default.instancePath}="", ${names_1.default.parentData}, ${names_1.default.parentDataProperty}, ${names_1.default.rootData}=${names_1.default.data}${opts.dynamicRef ? (0, codegen_1._)`, ${names_1.default.dynamicAnchors}={}` : codegen_1.nil}}={}`;
    }
    function destructureValCxtES5(gen, opts) {
      gen.if(names_1.default.valCxt, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.instancePath}`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentData}`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.parentDataProperty}`);
        gen.var(names_1.default.rootData, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.rootData}`);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`${names_1.default.valCxt}.${names_1.default.dynamicAnchors}`);
      }, () => {
        gen.var(names_1.default.instancePath, (0, codegen_1._)`""`);
        gen.var(names_1.default.parentData, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.parentDataProperty, (0, codegen_1._)`undefined`);
        gen.var(names_1.default.rootData, names_1.default.data);
        if (opts.dynamicRef)
          gen.var(names_1.default.dynamicAnchors, (0, codegen_1._)`{}`);
      });
    }
    function topSchemaObjCode(it) {
      const { schema, opts, gen } = it;
      validateFunction(it, () => {
        if (opts.$comment && schema.$comment)
          commentKeyword(it);
        checkNoDefault(it);
        gen.let(names_1.default.vErrors, null);
        gen.let(names_1.default.errors, 0);
        if (opts.unevaluated)
          resetEvaluated(it);
        typeAndKeywords(it);
        returnResults(it);
      });
      return;
    }
    function resetEvaluated(it) {
      const { gen, validateName } = it;
      it.evaluated = gen.const("evaluated", (0, codegen_1._)`${validateName}.evaluated`);
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicProps`, () => gen.assign((0, codegen_1._)`${it.evaluated}.props`, (0, codegen_1._)`undefined`));
      gen.if((0, codegen_1._)`${it.evaluated}.dynamicItems`, () => gen.assign((0, codegen_1._)`${it.evaluated}.items`, (0, codegen_1._)`undefined`));
    }
    function funcSourceUrl(schema, opts) {
      const schId = typeof schema == "object" && schema[opts.schemaId];
      return schId && (opts.code.source || opts.code.process) ? (0, codegen_1._)`/*# sourceURL=${schId} */` : codegen_1.nil;
    }
    function subschemaCode(it, valid) {
      if (isSchemaObj(it)) {
        checkKeywords(it);
        if (schemaCxtHasRules(it)) {
          subSchemaObjCode(it, valid);
          return;
        }
      }
      (0, boolSchema_1.boolOrEmptySchema)(it, valid);
    }
    function schemaCxtHasRules({ schema, self }) {
      if (typeof schema == "boolean")
        return !schema;
      for (const key in schema)
        if (self.RULES.all[key])
          return true;
      return false;
    }
    function isSchemaObj(it) {
      return typeof it.schema != "boolean";
    }
    function subSchemaObjCode(it, valid) {
      const { schema, gen, opts } = it;
      if (opts.$comment && schema.$comment)
        commentKeyword(it);
      updateContext(it);
      checkAsyncSchema(it);
      const errsCount = gen.const("_errs", names_1.default.errors);
      typeAndKeywords(it, errsCount);
      gen.var(valid, (0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
    }
    function checkKeywords(it) {
      (0, util_1.checkUnknownRules)(it);
      checkRefsAndKeywords(it);
    }
    function typeAndKeywords(it, errsCount) {
      if (it.opts.jtd)
        return schemaKeywords(it, [], false, errsCount);
      const types = (0, dataType_1.getSchemaTypes)(it.schema);
      const checkedTypes = (0, dataType_1.coerceAndCheckDataType)(it, types);
      schemaKeywords(it, types, !checkedTypes, errsCount);
    }
    function checkRefsAndKeywords(it) {
      const { schema, errSchemaPath, opts, self } = it;
      if (schema.$ref && opts.ignoreKeywordsWithRef && (0, util_1.schemaHasRulesButRef)(schema, self.RULES)) {
        self.logger.warn(`$ref: keywords ignored in schema at path "${errSchemaPath}"`);
      }
    }
    function checkNoDefault(it) {
      const { schema, opts } = it;
      if (schema.default !== void 0 && opts.useDefaults && opts.strictSchema) {
        (0, util_1.checkStrictMode)(it, "default is ignored in the schema root");
      }
    }
    function updateContext(it) {
      const schId = it.schema[it.opts.schemaId];
      if (schId)
        it.baseId = (0, resolve_1.resolveUrl)(it.opts.uriResolver, it.baseId, schId);
    }
    function checkAsyncSchema(it) {
      if (it.schema.$async && !it.schemaEnv.$async)
        throw new Error("async schema in sync schema");
    }
    function commentKeyword({ gen, schemaEnv, schema, errSchemaPath, opts }) {
      const msg = schema.$comment;
      if (opts.$comment === true) {
        gen.code((0, codegen_1._)`${names_1.default.self}.logger.log(${msg})`);
      } else if (typeof opts.$comment == "function") {
        const schemaPath = (0, codegen_1.str)`${errSchemaPath}/$comment`;
        const rootName = gen.scopeValue("root", { ref: schemaEnv.root });
        gen.code((0, codegen_1._)`${names_1.default.self}.opts.$comment(${msg}, ${schemaPath}, ${rootName}.schema)`);
      }
    }
    function returnResults(it) {
      const { gen, schemaEnv, validateName, ValidationError, opts } = it;
      if (schemaEnv.$async) {
        gen.if((0, codegen_1._)`${names_1.default.errors} === 0`, () => gen.return(names_1.default.data), () => gen.throw((0, codegen_1._)`new ${ValidationError}(${names_1.default.vErrors})`));
      } else {
        gen.assign((0, codegen_1._)`${validateName}.errors`, names_1.default.vErrors);
        if (opts.unevaluated)
          assignEvaluated(it);
        gen.return((0, codegen_1._)`${names_1.default.errors} === 0`);
      }
    }
    function assignEvaluated({ gen, evaluated, props, items }) {
      if (props instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.props`, props);
      if (items instanceof codegen_1.Name)
        gen.assign((0, codegen_1._)`${evaluated}.items`, items);
    }
    function schemaKeywords(it, types, typeErrors, errsCount) {
      const { gen, schema, data, allErrors, opts, self } = it;
      const { RULES } = self;
      if (schema.$ref && (opts.ignoreKeywordsWithRef || !(0, util_1.schemaHasRulesButRef)(schema, RULES))) {
        gen.block(() => keywordCode(it, "$ref", RULES.all.$ref.definition));
        return;
      }
      if (!opts.jtd)
        checkStrictTypes(it, types);
      gen.block(() => {
        for (const group of RULES.rules)
          groupKeywords(group);
        groupKeywords(RULES.post);
      });
      function groupKeywords(group) {
        if (!(0, applicability_1.shouldUseGroup)(schema, group))
          return;
        if (group.type) {
          gen.if((0, dataType_2.checkDataType)(group.type, data, opts.strictNumbers));
          iterateKeywords(it, group);
          if (types.length === 1 && types[0] === group.type && typeErrors) {
            gen.else();
            (0, dataType_2.reportTypeError)(it);
          }
          gen.endIf();
        } else {
          iterateKeywords(it, group);
        }
        if (!allErrors)
          gen.if((0, codegen_1._)`${names_1.default.errors} === ${errsCount || 0}`);
      }
    }
    function iterateKeywords(it, group) {
      const { gen, schema, opts: { useDefaults } } = it;
      if (useDefaults)
        (0, defaults_1.assignDefaults)(it, group.type);
      gen.block(() => {
        for (const rule of group.rules) {
          if ((0, applicability_1.shouldUseRule)(schema, rule)) {
            keywordCode(it, rule.keyword, rule.definition, group.type);
          }
        }
      });
    }
    function checkStrictTypes(it, types) {
      if (it.schemaEnv.meta || !it.opts.strictTypes)
        return;
      checkContextTypes(it, types);
      if (!it.opts.allowUnionTypes)
        checkMultipleTypes(it, types);
      checkKeywordTypes(it, it.dataTypes);
    }
    function checkContextTypes(it, types) {
      if (!types.length)
        return;
      if (!it.dataTypes.length) {
        it.dataTypes = types;
        return;
      }
      types.forEach((t2) => {
        if (!includesType(it.dataTypes, t2)) {
          strictTypesError(it, `type "${t2}" not allowed by context "${it.dataTypes.join(",")}"`);
        }
      });
      narrowSchemaTypes(it, types);
    }
    function checkMultipleTypes(it, ts) {
      if (ts.length > 1 && !(ts.length === 2 && ts.includes("null"))) {
        strictTypesError(it, "use allowUnionTypes to allow union type keyword");
      }
    }
    function checkKeywordTypes(it, ts) {
      const rules = it.self.RULES.all;
      for (const keyword in rules) {
        const rule = rules[keyword];
        if (typeof rule == "object" && (0, applicability_1.shouldUseRule)(it.schema, rule)) {
          const { type } = rule.definition;
          if (type.length && !type.some((t2) => hasApplicableType(ts, t2))) {
            strictTypesError(it, `missing type "${type.join(",")}" for keyword "${keyword}"`);
          }
        }
      }
    }
    function hasApplicableType(schTs, kwdT) {
      return schTs.includes(kwdT) || kwdT === "number" && schTs.includes("integer");
    }
    function includesType(ts, t2) {
      return ts.includes(t2) || t2 === "integer" && ts.includes("number");
    }
    function narrowSchemaTypes(it, withTypes) {
      const ts = [];
      for (const t2 of it.dataTypes) {
        if (includesType(withTypes, t2))
          ts.push(t2);
        else if (withTypes.includes("integer") && t2 === "number")
          ts.push("integer");
      }
      it.dataTypes = ts;
    }
    function strictTypesError(it, msg) {
      const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
      msg += ` at "${schemaPath}" (strictTypes)`;
      (0, util_1.checkStrictMode)(it, msg, it.opts.strictTypes);
    }
    var KeywordCxt = class {
      constructor(it, def, keyword) {
        (0, keyword_1.validateKeywordUsage)(it, def, keyword);
        this.gen = it.gen;
        this.allErrors = it.allErrors;
        this.keyword = keyword;
        this.data = it.data;
        this.schema = it.schema[keyword];
        this.$data = def.$data && it.opts.$data && this.schema && this.schema.$data;
        this.schemaValue = (0, util_1.schemaRefOrVal)(it, this.schema, keyword, this.$data);
        this.schemaType = def.schemaType;
        this.parentSchema = it.schema;
        this.params = {};
        this.it = it;
        this.def = def;
        if (this.$data) {
          this.schemaCode = it.gen.const("vSchema", getData(this.$data, it));
        } else {
          this.schemaCode = this.schemaValue;
          if (!(0, keyword_1.validSchemaType)(this.schema, def.schemaType, def.allowUndefined)) {
            throw new Error(`${keyword} value must be ${JSON.stringify(def.schemaType)}`);
          }
        }
        if ("code" in def ? def.trackErrors : def.errors !== false) {
          this.errsCount = it.gen.const("_errs", names_1.default.errors);
        }
      }
      result(condition, successAction, failAction) {
        this.failResult((0, codegen_1.not)(condition), successAction, failAction);
      }
      failResult(condition, successAction, failAction) {
        this.gen.if(condition);
        if (failAction)
          failAction();
        else
          this.error();
        if (successAction) {
          this.gen.else();
          successAction();
          if (this.allErrors)
            this.gen.endIf();
        } else {
          if (this.allErrors)
            this.gen.endIf();
          else
            this.gen.else();
        }
      }
      pass(condition, failAction) {
        this.failResult((0, codegen_1.not)(condition), void 0, failAction);
      }
      fail(condition) {
        if (condition === void 0) {
          this.error();
          if (!this.allErrors)
            this.gen.if(false);
          return;
        }
        this.gen.if(condition);
        this.error();
        if (this.allErrors)
          this.gen.endIf();
        else
          this.gen.else();
      }
      fail$data(condition) {
        if (!this.$data)
          return this.fail(condition);
        const { schemaCode } = this;
        this.fail((0, codegen_1._)`${schemaCode} !== undefined && (${(0, codegen_1.or)(this.invalid$data(), condition)})`);
      }
      error(append, errorParams, errorPaths) {
        if (errorParams) {
          this.setParams(errorParams);
          this._error(append, errorPaths);
          this.setParams({});
          return;
        }
        this._error(append, errorPaths);
      }
      _error(append, errorPaths) {
        ;
        (append ? errors_1.reportExtraError : errors_1.reportError)(this, this.def.error, errorPaths);
      }
      $dataError() {
        (0, errors_1.reportError)(this, this.def.$dataError || errors_1.keyword$DataError);
      }
      reset() {
        if (this.errsCount === void 0)
          throw new Error('add "trackErrors" to keyword definition');
        (0, errors_1.resetErrorsCount)(this.gen, this.errsCount);
      }
      ok(cond) {
        if (!this.allErrors)
          this.gen.if(cond);
      }
      setParams(obj, assign) {
        if (assign)
          Object.assign(this.params, obj);
        else
          this.params = obj;
      }
      block$data(valid, codeBlock, $dataValid = codegen_1.nil) {
        this.gen.block(() => {
          this.check$data(valid, $dataValid);
          codeBlock();
        });
      }
      check$data(valid = codegen_1.nil, $dataValid = codegen_1.nil) {
        if (!this.$data)
          return;
        const { gen, schemaCode, schemaType, def } = this;
        gen.if((0, codegen_1.or)((0, codegen_1._)`${schemaCode} === undefined`, $dataValid));
        if (valid !== codegen_1.nil)
          gen.assign(valid, true);
        if (schemaType.length || def.validateSchema) {
          gen.elseIf(this.invalid$data());
          this.$dataError();
          if (valid !== codegen_1.nil)
            gen.assign(valid, false);
        }
        gen.else();
      }
      invalid$data() {
        const { gen, schemaCode, schemaType, def, it } = this;
        return (0, codegen_1.or)(wrong$DataType(), invalid$DataSchema());
        function wrong$DataType() {
          if (schemaType.length) {
            if (!(schemaCode instanceof codegen_1.Name))
              throw new Error("ajv implementation error");
            const st = Array.isArray(schemaType) ? schemaType : [schemaType];
            return (0, codegen_1._)`${(0, dataType_2.checkDataTypes)(st, schemaCode, it.opts.strictNumbers, dataType_2.DataType.Wrong)}`;
          }
          return codegen_1.nil;
        }
        function invalid$DataSchema() {
          if (def.validateSchema) {
            const validateSchemaRef = gen.scopeValue("validate$data", { ref: def.validateSchema });
            return (0, codegen_1._)`!${validateSchemaRef}(${schemaCode})`;
          }
          return codegen_1.nil;
        }
      }
      subschema(appl, valid) {
        const subschema = (0, subschema_1.getSubschema)(this.it, appl);
        (0, subschema_1.extendSubschemaData)(subschema, this.it, appl);
        (0, subschema_1.extendSubschemaMode)(subschema, appl);
        const nextContext = { ...this.it, ...subschema, items: void 0, props: void 0 };
        subschemaCode(nextContext, valid);
        return nextContext;
      }
      mergeEvaluated(schemaCxt, toName) {
        const { it, gen } = this;
        if (!it.opts.unevaluated)
          return;
        if (it.props !== true && schemaCxt.props !== void 0) {
          it.props = util_1.mergeEvaluated.props(gen, schemaCxt.props, it.props, toName);
        }
        if (it.items !== true && schemaCxt.items !== void 0) {
          it.items = util_1.mergeEvaluated.items(gen, schemaCxt.items, it.items, toName);
        }
      }
      mergeValidEvaluated(schemaCxt, valid) {
        const { it, gen } = this;
        if (it.opts.unevaluated && (it.props !== true || it.items !== true)) {
          gen.if(valid, () => this.mergeEvaluated(schemaCxt, codegen_1.Name));
          return true;
        }
      }
    };
    exports.KeywordCxt = KeywordCxt;
    function keywordCode(it, keyword, def, ruleType) {
      const cxt = new KeywordCxt(it, def, keyword);
      if ("code" in def) {
        def.code(cxt, ruleType);
      } else if (cxt.$data && def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      } else if ("macro" in def) {
        (0, keyword_1.macroKeywordCode)(cxt, def);
      } else if (def.compile || def.validate) {
        (0, keyword_1.funcKeywordCode)(cxt, def);
      }
    }
    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, { dataLevel, dataNames, dataPathArr }) {
      let jsonPointer;
      let data;
      if ($data === "")
        return names_1.default.rootData;
      if ($data[0] === "/") {
        if (!JSON_POINTER.test($data))
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        jsonPointer = $data;
        data = names_1.default.rootData;
      } else {
        const matches = RELATIVE_JSON_POINTER.exec($data);
        if (!matches)
          throw new Error(`Invalid JSON-pointer: ${$data}`);
        const up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer === "#") {
          if (up >= dataLevel)
            throw new Error(errorMsg("property/index", up));
          return dataPathArr[dataLevel - up];
        }
        if (up > dataLevel)
          throw new Error(errorMsg("data", up));
        data = dataNames[dataLevel - up];
        if (!jsonPointer)
          return data;
      }
      let expr = data;
      const segments = jsonPointer.split("/");
      for (const segment of segments) {
        if (segment) {
          data = (0, codegen_1._)`${data}${(0, codegen_1.getProperty)((0, util_1.unescapeJsonPointer)(segment))}`;
          expr = (0, codegen_1._)`${expr} && ${data}`;
        }
      }
      return expr;
      function errorMsg(pointerType, up) {
        return `Cannot access ${pointerType} ${up} levels up, current level is ${dataLevel}`;
      }
    }
    exports.getData = getData;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/validation_error.js
var require_validation_error2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/validation_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ValidationError = class extends Error {
      constructor(errors) {
        super("validation failed");
        this.errors = errors;
        this.ajv = this.validation = true;
      }
    };
    exports.default = ValidationError;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/ref_error.js
var require_ref_error2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/ref_error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var resolve_1 = require_resolve2();
    var MissingRefError = class extends Error {
      constructor(resolver, baseId, ref, msg) {
        super(msg || `can't resolve reference ${ref} from id ${baseId}`);
        this.missingRef = (0, resolve_1.resolveUrl)(resolver, baseId, ref);
        this.missingSchema = (0, resolve_1.normalizeId)((0, resolve_1.getFullPath)(resolver, this.missingRef));
      }
    };
    exports.default = MissingRefError;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/compile/index.js
var require_compile2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/compile/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveSchema = exports.getCompilingSchema = exports.resolveRef = exports.compileSchema = exports.SchemaEnv = void 0;
    var codegen_1 = require_codegen2();
    var validation_error_1 = require_validation_error2();
    var names_1 = require_names2();
    var resolve_1 = require_resolve2();
    var util_1 = require_util2();
    var validate_1 = require_validate2();
    var SchemaEnv = class {
      constructor(env) {
        var _a13;
        this.refs = {};
        this.dynamicAnchors = {};
        let schema;
        if (typeof env.schema == "object")
          schema = env.schema;
        this.schema = env.schema;
        this.schemaId = env.schemaId;
        this.root = env.root || this;
        this.baseId = (_a13 = env.baseId) !== null && _a13 !== void 0 ? _a13 : (0, resolve_1.normalizeId)(schema === null || schema === void 0 ? void 0 : schema[env.schemaId || "$id"]);
        this.schemaPath = env.schemaPath;
        this.localRefs = env.localRefs;
        this.meta = env.meta;
        this.$async = schema === null || schema === void 0 ? void 0 : schema.$async;
        this.refs = {};
      }
    };
    exports.SchemaEnv = SchemaEnv;
    function compileSchema(sch) {
      const _sch = getCompilingSchema.call(this, sch);
      if (_sch)
        return _sch;
      const rootId = (0, resolve_1.getFullPath)(this.opts.uriResolver, sch.root.baseId);
      const { es5, lines } = this.opts.code;
      const { ownProperties } = this.opts;
      const gen = new codegen_1.CodeGen(this.scope, { es5, lines, ownProperties });
      let _ValidationError;
      if (sch.$async) {
        _ValidationError = gen.scopeValue("Error", {
          ref: validation_error_1.default,
          code: (0, codegen_1._)`require("ajv/dist/runtime/validation_error").default`
        });
      }
      const validateName = gen.scopeName("validate");
      sch.validateName = validateName;
      const schemaCxt = {
        gen,
        allErrors: this.opts.allErrors,
        data: names_1.default.data,
        parentData: names_1.default.parentData,
        parentDataProperty: names_1.default.parentDataProperty,
        dataNames: [names_1.default.data],
        dataPathArr: [codegen_1.nil],
        // TODO can its length be used as dataLevel if nil is removed?
        dataLevel: 0,
        dataTypes: [],
        definedProperties: /* @__PURE__ */ new Set(),
        topSchemaRef: gen.scopeValue("schema", this.opts.code.source === true ? { ref: sch.schema, code: (0, codegen_1.stringify)(sch.schema) } : { ref: sch.schema }),
        validateName,
        ValidationError: _ValidationError,
        schema: sch.schema,
        schemaEnv: sch,
        rootId,
        baseId: sch.baseId || rootId,
        schemaPath: codegen_1.nil,
        errSchemaPath: sch.schemaPath || (this.opts.jtd ? "" : "#"),
        errorPath: (0, codegen_1._)`""`,
        opts: this.opts,
        self: this
      };
      let sourceCode;
      try {
        this._compilations.add(sch);
        (0, validate_1.validateFunctionCode)(schemaCxt);
        gen.optimize(this.opts.code.optimize);
        const validateCode = gen.toString();
        sourceCode = `${gen.scopeRefs(names_1.default.scope)}return ${validateCode}`;
        if (this.opts.code.process)
          sourceCode = this.opts.code.process(sourceCode, sch);
        const makeValidate = new Function(`${names_1.default.self}`, `${names_1.default.scope}`, sourceCode);
        const validate = makeValidate(this, this.scope.get());
        this.scope.value(validateName, { ref: validate });
        validate.errors = null;
        validate.schema = sch.schema;
        validate.schemaEnv = sch;
        if (sch.$async)
          validate.$async = true;
        if (this.opts.code.source === true) {
          validate.source = { validateName, validateCode, scopeValues: gen._values };
        }
        if (this.opts.unevaluated) {
          const { props, items } = schemaCxt;
          validate.evaluated = {
            props: props instanceof codegen_1.Name ? void 0 : props,
            items: items instanceof codegen_1.Name ? void 0 : items,
            dynamicProps: props instanceof codegen_1.Name,
            dynamicItems: items instanceof codegen_1.Name
          };
          if (validate.source)
            validate.source.evaluated = (0, codegen_1.stringify)(validate.evaluated);
        }
        sch.validate = validate;
        return sch;
      } catch (e2) {
        delete sch.validate;
        delete sch.validateName;
        if (sourceCode)
          this.logger.error("Error compiling schema, function code:", sourceCode);
        throw e2;
      } finally {
        this._compilations.delete(sch);
      }
    }
    exports.compileSchema = compileSchema;
    function resolveRef(root, baseId, ref) {
      var _a13;
      ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, ref);
      const schOrFunc = root.refs[ref];
      if (schOrFunc)
        return schOrFunc;
      let _sch = resolve.call(this, root, ref);
      if (_sch === void 0) {
        const schema = (_a13 = root.localRefs) === null || _a13 === void 0 ? void 0 : _a13[ref];
        const { schemaId } = this.opts;
        if (schema)
          _sch = new SchemaEnv({ schema, schemaId, root, baseId });
      }
      if (_sch === void 0)
        return;
      return root.refs[ref] = inlineOrCompile.call(this, _sch);
    }
    exports.resolveRef = resolveRef;
    function inlineOrCompile(sch) {
      if ((0, resolve_1.inlineRef)(sch.schema, this.opts.inlineRefs))
        return sch.schema;
      return sch.validate ? sch : compileSchema.call(this, sch);
    }
    function getCompilingSchema(schEnv) {
      for (const sch of this._compilations) {
        if (sameSchemaEnv(sch, schEnv))
          return sch;
      }
    }
    exports.getCompilingSchema = getCompilingSchema;
    function sameSchemaEnv(s1, s2) {
      return s1.schema === s2.schema && s1.root === s2.root && s1.baseId === s2.baseId;
    }
    function resolve(root, ref) {
      let sch;
      while (typeof (sch = this.refs[ref]) == "string")
        ref = sch;
      return sch || this.schemas[ref] || resolveSchema.call(this, root, ref);
    }
    function resolveSchema(root, ref) {
      const p = this.opts.uriResolver.parse(ref);
      const refPath = (0, resolve_1._getFullPath)(this.opts.uriResolver, p);
      let baseId = (0, resolve_1.getFullPath)(this.opts.uriResolver, root.baseId, void 0);
      if (Object.keys(root.schema).length > 0 && refPath === baseId) {
        return getJsonPointer.call(this, p, root);
      }
      const id = (0, resolve_1.normalizeId)(refPath);
      const schOrRef = this.refs[id] || this.schemas[id];
      if (typeof schOrRef == "string") {
        const sch = resolveSchema.call(this, root, schOrRef);
        if (typeof (sch === null || sch === void 0 ? void 0 : sch.schema) !== "object")
          return;
        return getJsonPointer.call(this, p, sch);
      }
      if (typeof (schOrRef === null || schOrRef === void 0 ? void 0 : schOrRef.schema) !== "object")
        return;
      if (!schOrRef.validate)
        compileSchema.call(this, schOrRef);
      if (id === (0, resolve_1.normalizeId)(ref)) {
        const { schema } = schOrRef;
        const { schemaId } = this.opts;
        const schId = schema[schemaId];
        if (schId)
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        return new SchemaEnv({ schema, schemaId, root, baseId });
      }
      return getJsonPointer.call(this, p, schOrRef);
    }
    exports.resolveSchema = resolveSchema;
    var PREVENT_SCOPE_CHANGE = /* @__PURE__ */ new Set([
      "properties",
      "patternProperties",
      "enum",
      "dependencies",
      "definitions"
    ]);
    function getJsonPointer(parsedRef, { baseId, schema, root }) {
      var _a13;
      if (((_a13 = parsedRef.fragment) === null || _a13 === void 0 ? void 0 : _a13[0]) !== "/")
        return;
      for (const part of parsedRef.fragment.slice(1).split("/")) {
        if (typeof schema === "boolean")
          return;
        const partSchema = schema[(0, util_1.unescapeFragment)(part)];
        if (partSchema === void 0)
          return;
        schema = partSchema;
        const schId = typeof schema === "object" && schema[this.opts.schemaId];
        if (!PREVENT_SCOPE_CHANGE.has(part) && schId) {
          baseId = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schId);
        }
      }
      let env;
      if (typeof schema != "boolean" && schema.$ref && !(0, util_1.schemaHasRulesButRef)(schema, this.RULES)) {
        const $ref = (0, resolve_1.resolveUrl)(this.opts.uriResolver, baseId, schema.$ref);
        env = resolveSchema.call(this, root, $ref);
      }
      const { schemaId } = this.opts;
      env = env || new SchemaEnv({ schema, schemaId, root, baseId });
      if (env.schema !== env.root.schema)
        return env;
      return void 0;
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/refs/data.json
var require_data2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/refs/data.json"(exports, module) {
    module.exports = {
      $id: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#",
      description: "Meta-schema for $data reference (JSON AnySchema extension proposal)",
      type: "object",
      required: ["$data"],
      properties: {
        $data: {
          type: "string",
          anyOf: [{ format: "relative-json-pointer" }, { format: "json-pointer" }]
        }
      },
      additionalProperties: false
    };
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/uri.js
var require_uri2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/uri.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uri = require_fast_uri();
    uri.code = 'require("ajv/dist/runtime/uri").default';
    exports.default = uri;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/core.js
var require_core3 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = void 0;
    var validate_1 = require_validate2();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen2();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error2();
    var ref_error_1 = require_ref_error2();
    var rules_1 = require_rules2();
    var compile_1 = require_compile2();
    var codegen_2 = require_codegen2();
    var resolve_1 = require_resolve2();
    var dataType_1 = require_dataType2();
    var util_1 = require_util2();
    var $dataRefSchema = require_data2();
    var uri_1 = require_uri2();
    var defaultRegExp = (str, flags) => new RegExp(str, flags);
    defaultRegExp.code = "new RegExp";
    var META_IGNORE_OPTIONS = ["removeAdditional", "useDefaults", "coerceTypes"];
    var EXT_SCOPE_NAMES = /* @__PURE__ */ new Set([
      "validate",
      "serialize",
      "parse",
      "wrapper",
      "root",
      "schema",
      "keyword",
      "pattern",
      "formats",
      "validate$data",
      "func",
      "obj",
      "Error"
    ]);
    var removedOptions = {
      errorDataPath: "",
      format: "`validateFormats: false` can be used instead.",
      nullable: '"nullable" keyword is supported by default.',
      jsonPointers: "Deprecated jsPropertySyntax can be used instead.",
      extendRefs: "Deprecated ignoreKeywordsWithRef can be used instead.",
      missingRefs: "Pass empty schema with $id that should be ignored to ajv.addSchema.",
      processCode: "Use option `code: {process: (code, schemaEnv: object) => string}`",
      sourceCode: "Use option `code: {source: true}`",
      strictDefaults: "It is default now, see option `strict`.",
      strictKeywords: "It is default now, see option `strict`.",
      uniqueItems: '"uniqueItems" keyword is always validated.',
      unknownFormats: "Disable strict mode or pass `true` to `ajv.addFormat` (or `formats` option).",
      cache: "Map is used as cache, schema object as key.",
      serialize: "Map is used as cache, schema object as key.",
      ajvErrors: "It is default now."
    };
    var deprecatedOptions = {
      ignoreKeywordsWithRef: "",
      jsPropertySyntax: "",
      unicode: '"minLength"/"maxLength" account for unicode characters by default.'
    };
    var MAX_EXPRESSION = 200;
    function requiredOptions(o) {
      var _a13, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;
      const s = o.strict;
      const _optz = (_a13 = o.code) === null || _a13 === void 0 ? void 0 : _a13.optimize;
      const optimize = _optz === true || _optz === void 0 ? 1 : _optz || 0;
      const regExp = (_c = (_b = o.code) === null || _b === void 0 ? void 0 : _b.regExp) !== null && _c !== void 0 ? _c : defaultRegExp;
      const uriResolver = (_d = o.uriResolver) !== null && _d !== void 0 ? _d : uri_1.default;
      return {
        strictSchema: (_f = (_e = o.strictSchema) !== null && _e !== void 0 ? _e : s) !== null && _f !== void 0 ? _f : true,
        strictNumbers: (_h = (_g = o.strictNumbers) !== null && _g !== void 0 ? _g : s) !== null && _h !== void 0 ? _h : true,
        strictTypes: (_k = (_j = o.strictTypes) !== null && _j !== void 0 ? _j : s) !== null && _k !== void 0 ? _k : "log",
        strictTuples: (_m = (_l = o.strictTuples) !== null && _l !== void 0 ? _l : s) !== null && _m !== void 0 ? _m : "log",
        strictRequired: (_p = (_o = o.strictRequired) !== null && _o !== void 0 ? _o : s) !== null && _p !== void 0 ? _p : false,
        code: o.code ? { ...o.code, optimize, regExp } : { optimize, regExp },
        loopRequired: (_q = o.loopRequired) !== null && _q !== void 0 ? _q : MAX_EXPRESSION,
        loopEnum: (_r = o.loopEnum) !== null && _r !== void 0 ? _r : MAX_EXPRESSION,
        meta: (_s = o.meta) !== null && _s !== void 0 ? _s : true,
        messages: (_t = o.messages) !== null && _t !== void 0 ? _t : true,
        inlineRefs: (_u = o.inlineRefs) !== null && _u !== void 0 ? _u : true,
        schemaId: (_v = o.schemaId) !== null && _v !== void 0 ? _v : "$id",
        addUsedSchema: (_w = o.addUsedSchema) !== null && _w !== void 0 ? _w : true,
        validateSchema: (_x = o.validateSchema) !== null && _x !== void 0 ? _x : true,
        validateFormats: (_y = o.validateFormats) !== null && _y !== void 0 ? _y : true,
        unicodeRegExp: (_z = o.unicodeRegExp) !== null && _z !== void 0 ? _z : true,
        int32range: (_0 = o.int32range) !== null && _0 !== void 0 ? _0 : true,
        uriResolver
      };
    }
    var Ajv2 = class {
      constructor(opts = {}) {
        this.schemas = {};
        this.refs = {};
        this.formats = {};
        this._compilations = /* @__PURE__ */ new Set();
        this._loading = {};
        this._cache = /* @__PURE__ */ new Map();
        opts = this.opts = { ...opts, ...requiredOptions(opts) };
        const { es5, lines } = this.opts.code;
        this.scope = new codegen_2.ValueScope({ scope: {}, prefixes: EXT_SCOPE_NAMES, es5, lines });
        this.logger = getLogger(opts.logger);
        const formatOpt = opts.validateFormats;
        opts.validateFormats = false;
        this.RULES = (0, rules_1.getRules)();
        checkOptions.call(this, removedOptions, opts, "NOT SUPPORTED");
        checkOptions.call(this, deprecatedOptions, opts, "DEPRECATED", "warn");
        this._metaOpts = getMetaSchemaOptions.call(this);
        if (opts.formats)
          addInitialFormats.call(this);
        this._addVocabularies();
        this._addDefaultMetaSchema();
        if (opts.keywords)
          addInitialKeywords.call(this, opts.keywords);
        if (typeof opts.meta == "object")
          this.addMetaSchema(opts.meta);
        addInitialSchemas.call(this);
        opts.validateFormats = formatOpt;
      }
      _addVocabularies() {
        this.addKeyword("$async");
      }
      _addDefaultMetaSchema() {
        const { $data, meta, schemaId } = this.opts;
        let _dataRefSchema = $dataRefSchema;
        if (schemaId === "id") {
          _dataRefSchema = { ...$dataRefSchema };
          _dataRefSchema.id = _dataRefSchema.$id;
          delete _dataRefSchema.$id;
        }
        if (meta && $data)
          this.addMetaSchema(_dataRefSchema, _dataRefSchema[schemaId], false);
      }
      defaultMeta() {
        const { meta, schemaId } = this.opts;
        return this.opts.defaultMeta = typeof meta == "object" ? meta[schemaId] || meta : void 0;
      }
      validate(schemaKeyRef, data) {
        let v;
        if (typeof schemaKeyRef == "string") {
          v = this.getSchema(schemaKeyRef);
          if (!v)
            throw new Error(`no schema with key or ref "${schemaKeyRef}"`);
        } else {
          v = this.compile(schemaKeyRef);
        }
        const valid = v(data);
        if (!("$async" in v))
          this.errors = v.errors;
        return valid;
      }
      compile(schema, _meta) {
        const sch = this._addSchema(schema, _meta);
        return sch.validate || this._compileSchemaEnv(sch);
      }
      compileAsync(schema, meta) {
        if (typeof this.opts.loadSchema != "function") {
          throw new Error("options.loadSchema should be a function");
        }
        const { loadSchema } = this.opts;
        return runCompileAsync.call(this, schema, meta);
        async function runCompileAsync(_schema, _meta) {
          await loadMetaSchema.call(this, _schema.$schema);
          const sch = this._addSchema(_schema, _meta);
          return sch.validate || _compileAsync.call(this, sch);
        }
        async function loadMetaSchema($ref) {
          if ($ref && !this.getSchema($ref)) {
            await runCompileAsync.call(this, { $ref }, true);
          }
        }
        async function _compileAsync(sch) {
          try {
            return this._compileSchemaEnv(sch);
          } catch (e2) {
            if (!(e2 instanceof ref_error_1.default))
              throw e2;
            checkLoaded.call(this, e2);
            await loadMissingSchema.call(this, e2.missingSchema);
            return _compileAsync.call(this, sch);
          }
        }
        function checkLoaded({ missingSchema: ref, missingRef }) {
          if (this.refs[ref]) {
            throw new Error(`AnySchema ${ref} is loaded but ${missingRef} cannot be resolved`);
          }
        }
        async function loadMissingSchema(ref) {
          const _schema = await _loadSchema.call(this, ref);
          if (!this.refs[ref])
            await loadMetaSchema.call(this, _schema.$schema);
          if (!this.refs[ref])
            this.addSchema(_schema, ref, meta);
        }
        async function _loadSchema(ref) {
          const p = this._loading[ref];
          if (p)
            return p;
          try {
            return await (this._loading[ref] = loadSchema(ref));
          } finally {
            delete this._loading[ref];
          }
        }
      }
      // Adds schema to the instance
      addSchema(schema, key, _meta, _validateSchema = this.opts.validateSchema) {
        if (Array.isArray(schema)) {
          for (const sch of schema)
            this.addSchema(sch, void 0, _meta, _validateSchema);
          return this;
        }
        let id;
        if (typeof schema === "object") {
          const { schemaId } = this.opts;
          id = schema[schemaId];
          if (id !== void 0 && typeof id != "string") {
            throw new Error(`schema ${schemaId} must be string`);
          }
        }
        key = (0, resolve_1.normalizeId)(key || id);
        this._checkUnique(key);
        this.schemas[key] = this._addSchema(schema, _meta, key, _validateSchema, true);
        return this;
      }
      // Add schema that will be used to validate other schemas
      // options in META_IGNORE_OPTIONS are alway set to false
      addMetaSchema(schema, key, _validateSchema = this.opts.validateSchema) {
        this.addSchema(schema, key, true, _validateSchema);
        return this;
      }
      //  Validate schema against its meta-schema
      validateSchema(schema, throwOrLogError) {
        if (typeof schema == "boolean")
          return true;
        let $schema;
        $schema = schema.$schema;
        if ($schema !== void 0 && typeof $schema != "string") {
          throw new Error("$schema must be a string");
        }
        $schema = $schema || this.opts.defaultMeta || this.defaultMeta();
        if (!$schema) {
          this.logger.warn("meta-schema not available");
          this.errors = null;
          return true;
        }
        const valid = this.validate($schema, schema);
        if (!valid && throwOrLogError) {
          const message = "schema is invalid: " + this.errorsText();
          if (this.opts.validateSchema === "log")
            this.logger.error(message);
          else
            throw new Error(message);
        }
        return valid;
      }
      // Get compiled schema by `key` or `ref`.
      // (`key` that was passed to `addSchema` or full schema reference - `schema.$id` or resolved id)
      getSchema(keyRef) {
        let sch;
        while (typeof (sch = getSchEnv.call(this, keyRef)) == "string")
          keyRef = sch;
        if (sch === void 0) {
          const { schemaId } = this.opts;
          const root = new compile_1.SchemaEnv({ schema: {}, schemaId });
          sch = compile_1.resolveSchema.call(this, root, keyRef);
          if (!sch)
            return;
          this.refs[keyRef] = sch;
        }
        return sch.validate || this._compileSchemaEnv(sch);
      }
      // Remove cached schema(s).
      // If no parameter is passed all schemas but meta-schemas are removed.
      // If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
      // Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
      removeSchema(schemaKeyRef) {
        if (schemaKeyRef instanceof RegExp) {
          this._removeAllSchemas(this.schemas, schemaKeyRef);
          this._removeAllSchemas(this.refs, schemaKeyRef);
          return this;
        }
        switch (typeof schemaKeyRef) {
          case "undefined":
            this._removeAllSchemas(this.schemas);
            this._removeAllSchemas(this.refs);
            this._cache.clear();
            return this;
          case "string": {
            const sch = getSchEnv.call(this, schemaKeyRef);
            if (typeof sch == "object")
              this._cache.delete(sch.schema);
            delete this.schemas[schemaKeyRef];
            delete this.refs[schemaKeyRef];
            return this;
          }
          case "object": {
            const cacheKey = schemaKeyRef;
            this._cache.delete(cacheKey);
            let id = schemaKeyRef[this.opts.schemaId];
            if (id) {
              id = (0, resolve_1.normalizeId)(id);
              delete this.schemas[id];
              delete this.refs[id];
            }
            return this;
          }
          default:
            throw new Error("ajv.removeSchema: invalid parameter");
        }
      }
      // add "vocabulary" - a collection of keywords
      addVocabulary(definitions) {
        for (const def of definitions)
          this.addKeyword(def);
        return this;
      }
      addKeyword(kwdOrDef, def) {
        let keyword;
        if (typeof kwdOrDef == "string") {
          keyword = kwdOrDef;
          if (typeof def == "object") {
            this.logger.warn("these parameters are deprecated, see docs for addKeyword");
            def.keyword = keyword;
          }
        } else if (typeof kwdOrDef == "object" && def === void 0) {
          def = kwdOrDef;
          keyword = def.keyword;
          if (Array.isArray(keyword) && !keyword.length) {
            throw new Error("addKeywords: keyword must be string or non-empty array");
          }
        } else {
          throw new Error("invalid addKeywords parameters");
        }
        checkKeyword.call(this, keyword, def);
        if (!def) {
          (0, util_1.eachItem)(keyword, (kwd) => addRule.call(this, kwd));
          return this;
        }
        keywordMetaschema.call(this, def);
        const definition = {
          ...def,
          type: (0, dataType_1.getJSONTypes)(def.type),
          schemaType: (0, dataType_1.getJSONTypes)(def.schemaType)
        };
        (0, util_1.eachItem)(keyword, definition.type.length === 0 ? (k) => addRule.call(this, k, definition) : (k) => definition.type.forEach((t2) => addRule.call(this, k, definition, t2)));
        return this;
      }
      getKeyword(keyword) {
        const rule = this.RULES.all[keyword];
        return typeof rule == "object" ? rule.definition : !!rule;
      }
      // Remove keyword
      removeKeyword(keyword) {
        const { RULES } = this;
        delete RULES.keywords[keyword];
        delete RULES.all[keyword];
        for (const group of RULES.rules) {
          const i = group.rules.findIndex((rule) => rule.keyword === keyword);
          if (i >= 0)
            group.rules.splice(i, 1);
        }
        return this;
      }
      // Add format
      addFormat(name, format) {
        if (typeof format == "string")
          format = new RegExp(format);
        this.formats[name] = format;
        return this;
      }
      errorsText(errors = this.errors, { separator = ", ", dataVar = "data" } = {}) {
        if (!errors || errors.length === 0)
          return "No errors";
        return errors.map((e2) => `${dataVar}${e2.instancePath} ${e2.message}`).reduce((text, msg) => text + separator + msg);
      }
      $dataMetaSchema(metaSchema, keywordsJsonPointers) {
        const rules = this.RULES.all;
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        for (const jsonPointer of keywordsJsonPointers) {
          const segments = jsonPointer.split("/").slice(1);
          let keywords = metaSchema;
          for (const seg of segments)
            keywords = keywords[seg];
          for (const key in rules) {
            const rule = rules[key];
            if (typeof rule != "object")
              continue;
            const { $data } = rule.definition;
            const schema = keywords[key];
            if ($data && schema)
              keywords[key] = schemaOrData(schema);
          }
        }
        return metaSchema;
      }
      _removeAllSchemas(schemas, regex) {
        for (const keyRef in schemas) {
          const sch = schemas[keyRef];
          if (!regex || regex.test(keyRef)) {
            if (typeof sch == "string") {
              delete schemas[keyRef];
            } else if (sch && !sch.meta) {
              this._cache.delete(sch.schema);
              delete schemas[keyRef];
            }
          }
        }
      }
      _addSchema(schema, meta, baseId, validateSchema = this.opts.validateSchema, addSchema = this.opts.addUsedSchema) {
        let id;
        const { schemaId } = this.opts;
        if (typeof schema == "object") {
          id = schema[schemaId];
        } else {
          if (this.opts.jtd)
            throw new Error("schema must be object");
          else if (typeof schema != "boolean")
            throw new Error("schema must be object or boolean");
        }
        let sch = this._cache.get(schema);
        if (sch !== void 0)
          return sch;
        baseId = (0, resolve_1.normalizeId)(id || baseId);
        const localRefs = resolve_1.getSchemaRefs.call(this, schema, baseId);
        sch = new compile_1.SchemaEnv({ schema, schemaId, meta, baseId, localRefs });
        this._cache.set(sch.schema, sch);
        if (addSchema && !baseId.startsWith("#")) {
          if (baseId)
            this._checkUnique(baseId);
          this.refs[baseId] = sch;
        }
        if (validateSchema)
          this.validateSchema(schema, true);
        return sch;
      }
      _checkUnique(id) {
        if (this.schemas[id] || this.refs[id]) {
          throw new Error(`schema with key or id "${id}" already exists`);
        }
      }
      _compileSchemaEnv(sch) {
        if (sch.meta)
          this._compileMetaSchema(sch);
        else
          compile_1.compileSchema.call(this, sch);
        if (!sch.validate)
          throw new Error("ajv implementation error");
        return sch.validate;
      }
      _compileMetaSchema(sch) {
        const currentOpts = this.opts;
        this.opts = this._metaOpts;
        try {
          compile_1.compileSchema.call(this, sch);
        } finally {
          this.opts = currentOpts;
        }
      }
    };
    Ajv2.ValidationError = validation_error_1.default;
    Ajv2.MissingRefError = ref_error_1.default;
    exports.default = Ajv2;
    function checkOptions(checkOpts, options, msg, log = "error") {
      for (const key in checkOpts) {
        const opt = key;
        if (opt in options)
          this.logger[log](`${msg}: option ${key}. ${checkOpts[opt]}`);
      }
    }
    function getSchEnv(keyRef) {
      keyRef = (0, resolve_1.normalizeId)(keyRef);
      return this.schemas[keyRef] || this.refs[keyRef];
    }
    function addInitialSchemas() {
      const optsSchemas = this.opts.schemas;
      if (!optsSchemas)
        return;
      if (Array.isArray(optsSchemas))
        this.addSchema(optsSchemas);
      else
        for (const key in optsSchemas)
          this.addSchema(optsSchemas[key], key);
    }
    function addInitialFormats() {
      for (const name in this.opts.formats) {
        const format = this.opts.formats[name];
        if (format)
          this.addFormat(name, format);
      }
    }
    function addInitialKeywords(defs) {
      if (Array.isArray(defs)) {
        this.addVocabulary(defs);
        return;
      }
      this.logger.warn("keywords option as map is deprecated, pass array");
      for (const keyword in defs) {
        const def = defs[keyword];
        if (!def.keyword)
          def.keyword = keyword;
        this.addKeyword(def);
      }
    }
    function getMetaSchemaOptions() {
      const metaOpts = { ...this.opts };
      for (const opt of META_IGNORE_OPTIONS)
        delete metaOpts[opt];
      return metaOpts;
    }
    var noLogs = { log() {
    }, warn() {
    }, error() {
    } };
    function getLogger(logger) {
      if (logger === false)
        return noLogs;
      if (logger === void 0)
        return console;
      if (logger.log && logger.warn && logger.error)
        return logger;
      throw new Error("logger must implement log, warn and error methods");
    }
    var KEYWORD_NAME = /^[a-z_$][a-z0-9_$:-]*$/i;
    function checkKeyword(keyword, def) {
      const { RULES } = this;
      (0, util_1.eachItem)(keyword, (kwd) => {
        if (RULES.keywords[kwd])
          throw new Error(`Keyword ${kwd} is already defined`);
        if (!KEYWORD_NAME.test(kwd))
          throw new Error(`Keyword ${kwd} has invalid name`);
      });
      if (!def)
        return;
      if (def.$data && !("code" in def || "validate" in def)) {
        throw new Error('$data keyword must have "code" or "validate" function');
      }
    }
    function addRule(keyword, definition, dataType) {
      var _a13;
      const post = definition === null || definition === void 0 ? void 0 : definition.post;
      if (dataType && post)
        throw new Error('keyword with "post" flag cannot have "type"');
      const { RULES } = this;
      let ruleGroup = post ? RULES.post : RULES.rules.find(({ type: t2 }) => t2 === dataType);
      if (!ruleGroup) {
        ruleGroup = { type: dataType, rules: [] };
        RULES.rules.push(ruleGroup);
      }
      RULES.keywords[keyword] = true;
      if (!definition)
        return;
      const rule = {
        keyword,
        definition: {
          ...definition,
          type: (0, dataType_1.getJSONTypes)(definition.type),
          schemaType: (0, dataType_1.getJSONTypes)(definition.schemaType)
        }
      };
      if (definition.before)
        addBeforeRule.call(this, ruleGroup, rule, definition.before);
      else
        ruleGroup.rules.push(rule);
      RULES.all[keyword] = rule;
      (_a13 = definition.implements) === null || _a13 === void 0 ? void 0 : _a13.forEach((kwd) => this.addKeyword(kwd));
    }
    function addBeforeRule(ruleGroup, rule, before) {
      const i = ruleGroup.rules.findIndex((_rule) => _rule.keyword === before);
      if (i >= 0) {
        ruleGroup.rules.splice(i, 0, rule);
      } else {
        ruleGroup.rules.push(rule);
        this.logger.warn(`rule ${before} is not defined`);
      }
    }
    function keywordMetaschema(def) {
      let { metaSchema } = def;
      if (metaSchema === void 0)
        return;
      if (def.$data && this.opts.$data)
        metaSchema = schemaOrData(metaSchema);
      def.validateSchema = this.compile(metaSchema, true);
    }
    var $dataRef = {
      $ref: "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#"
    };
    function schemaOrData(schema) {
      return { anyOf: [schema, $dataRef] };
    }
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/id.js
var require_id2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var def = {
      keyword: "id",
      code() {
        throw new Error('NOT SUPPORTED: keyword "id", use "$id" for schema ID');
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/ref.js
var require_ref2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/ref.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.callRef = exports.getValidate = void 0;
    var ref_error_1 = require_ref_error2();
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var compile_1 = require_compile2();
    var util_1 = require_util2();
    var def = {
      keyword: "$ref",
      schemaType: "string",
      code(cxt) {
        const { gen, schema: $ref, it } = cxt;
        const { baseId, schemaEnv: env, validateName, opts, self } = it;
        const { root } = env;
        if (($ref === "#" || $ref === "#/") && baseId === root.baseId)
          return callRootRef();
        const schOrEnv = compile_1.resolveRef.call(self, root, baseId, $ref);
        if (schOrEnv === void 0)
          throw new ref_error_1.default(it.opts.uriResolver, baseId, $ref);
        if (schOrEnv instanceof compile_1.SchemaEnv)
          return callValidate(schOrEnv);
        return inlineRefSchema(schOrEnv);
        function callRootRef() {
          if (env === root)
            return callRef(cxt, validateName, env, env.$async);
          const rootName = gen.scopeValue("root", { ref: root });
          return callRef(cxt, (0, codegen_1._)`${rootName}.validate`, root, root.$async);
        }
        function callValidate(sch) {
          const v = getValidate(cxt, sch);
          callRef(cxt, v, sch, sch.$async);
        }
        function inlineRefSchema(sch) {
          const schName = gen.scopeValue("schema", opts.code.source === true ? { ref: sch, code: (0, codegen_1.stringify)(sch) } : { ref: sch });
          const valid = gen.name("valid");
          const schCxt = cxt.subschema({
            schema: sch,
            dataTypes: [],
            schemaPath: codegen_1.nil,
            topSchemaRef: schName,
            errSchemaPath: $ref
          }, valid);
          cxt.mergeEvaluated(schCxt);
          cxt.ok(valid);
        }
      }
    };
    function getValidate(cxt, sch) {
      const { gen } = cxt;
      return sch.validate ? gen.scopeValue("validate", { ref: sch.validate }) : (0, codegen_1._)`${gen.scopeValue("wrapper", { ref: sch })}.validate`;
    }
    exports.getValidate = getValidate;
    function callRef(cxt, v, sch, $async) {
      const { gen, it } = cxt;
      const { allErrors, schemaEnv: env, opts } = it;
      const passCxt = opts.passContext ? names_1.default.this : codegen_1.nil;
      if ($async)
        callAsyncRef();
      else
        callSyncRef();
      function callAsyncRef() {
        if (!env.$async)
          throw new Error("async schema referenced by sync schema");
        const valid = gen.let("valid");
        gen.try(() => {
          gen.code((0, codegen_1._)`await ${(0, code_1.callValidateCode)(cxt, v, passCxt)}`);
          addEvaluatedFrom(v);
          if (!allErrors)
            gen.assign(valid, true);
        }, (e2) => {
          gen.if((0, codegen_1._)`!(${e2} instanceof ${it.ValidationError})`, () => gen.throw(e2));
          addErrorsFrom(e2);
          if (!allErrors)
            gen.assign(valid, false);
        });
        cxt.ok(valid);
      }
      function callSyncRef() {
        cxt.result((0, code_1.callValidateCode)(cxt, v, passCxt), () => addEvaluatedFrom(v), () => addErrorsFrom(v));
      }
      function addErrorsFrom(source) {
        const errs = (0, codegen_1._)`${source}.errors`;
        gen.assign(names_1.default.vErrors, (0, codegen_1._)`${names_1.default.vErrors} === null ? ${errs} : ${names_1.default.vErrors}.concat(${errs})`);
        gen.assign(names_1.default.errors, (0, codegen_1._)`${names_1.default.vErrors}.length`);
      }
      function addEvaluatedFrom(source) {
        var _a13;
        if (!it.opts.unevaluated)
          return;
        const schEvaluated = (_a13 = sch === null || sch === void 0 ? void 0 : sch.validate) === null || _a13 === void 0 ? void 0 : _a13.evaluated;
        if (it.props !== true) {
          if (schEvaluated && !schEvaluated.dynamicProps) {
            if (schEvaluated.props !== void 0) {
              it.props = util_1.mergeEvaluated.props(gen, schEvaluated.props, it.props);
            }
          } else {
            const props = gen.var("props", (0, codegen_1._)`${source}.evaluated.props`);
            it.props = util_1.mergeEvaluated.props(gen, props, it.props, codegen_1.Name);
          }
        }
        if (it.items !== true) {
          if (schEvaluated && !schEvaluated.dynamicItems) {
            if (schEvaluated.items !== void 0) {
              it.items = util_1.mergeEvaluated.items(gen, schEvaluated.items, it.items);
            }
          } else {
            const items = gen.var("items", (0, codegen_1._)`${source}.evaluated.items`);
            it.items = util_1.mergeEvaluated.items(gen, items, it.items, codegen_1.Name);
          }
        }
      }
    }
    exports.callRef = callRef;
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/index.js
var require_core4 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var id_1 = require_id2();
    var ref_1 = require_ref2();
    var core = [
      "$schema",
      "$id",
      "$defs",
      "$vocabulary",
      { keyword: "$comment" },
      "definitions",
      id_1.default,
      ref_1.default
    ];
    exports.default = core;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitNumber.js
var require_limitNumber2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitNumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var ops = codegen_1.operators;
    var KWDs = {
      maximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      minimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      exclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      exclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`must be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    var def = {
      keyword: Object.keys(KWDs),
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        cxt.fail$data((0, codegen_1._)`${data} ${KWDs[keyword].fail} ${schemaCode} || isNaN(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/multipleOf.js
var require_multipleOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/multipleOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must be multiple of ${schemaCode}`,
      params: ({ schemaCode }) => (0, codegen_1._)`{multipleOf: ${schemaCode}}`
    };
    var def = {
      keyword: "multipleOf",
      type: "number",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, it } = cxt;
        const prec = it.opts.multipleOfPrecision;
        const res = gen.let("res");
        const invalid = prec ? (0, codegen_1._)`Math.abs(Math.round(${res}) - ${res}) > 1e-${prec}` : (0, codegen_1._)`${res} !== parseInt(${res})`;
        cxt.fail$data((0, codegen_1._)`(${schemaCode} === 0 || (${res} = ${data}/${schemaCode}, ${invalid}))`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/ucs2length.js
var require_ucs2length2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/ucs2length.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function ucs2length(str) {
      const len = str.length;
      let length = 0;
      let pos = 0;
      let value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 55296 && value <= 56319 && pos < len) {
          value = str.charCodeAt(pos);
          if ((value & 64512) === 56320)
            pos++;
        }
      }
      return length;
    }
    exports.default = ucs2length;
    ucs2length.code = 'require("ajv/dist/runtime/ucs2length").default';
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitLength.js
var require_limitLength2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitLength.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var ucs2length_1 = require_ucs2length2();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxLength" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} characters`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxLength", "minLength"],
      type: "string",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode, it } = cxt;
        const op = keyword === "maxLength" ? codegen_1.operators.GT : codegen_1.operators.LT;
        const len = it.opts.unicode === false ? (0, codegen_1._)`${data}.length` : (0, codegen_1._)`${(0, util_1.useFunc)(cxt.gen, ucs2length_1.default)}(${data})`;
        cxt.fail$data((0, codegen_1._)`${len} ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/pattern.js
var require_pattern2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/pattern.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match pattern "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{pattern: ${schemaCode}}`
    };
    var def = {
      keyword: "pattern",
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { data, $data, schema, schemaCode, it } = cxt;
        const u2 = it.opts.unicodeRegExp ? "u" : "";
        const regExp = $data ? (0, codegen_1._)`(new RegExp(${schemaCode}, ${u2}))` : (0, code_1.usePattern)(cxt, schema);
        cxt.fail$data((0, codegen_1._)`!${regExp}.test(${data})`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitProperties.js
var require_limitProperties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxProperties" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} properties`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxProperties", "minProperties"],
      type: "object",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxProperties" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`Object.keys(${data}).length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/required.js
var require_required2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/required.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { missingProperty } }) => (0, codegen_1.str)`must have required property '${missingProperty}'`,
      params: ({ params: { missingProperty } }) => (0, codegen_1._)`{missingProperty: ${missingProperty}}`
    };
    var def = {
      keyword: "required",
      type: "object",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, schema, schemaCode, data, $data, it } = cxt;
        const { opts } = it;
        if (!$data && schema.length === 0)
          return;
        const useLoop = schema.length >= opts.loopRequired;
        if (it.allErrors)
          allErrorsMode();
        else
          exitOnErrorMode();
        if (opts.strictRequired) {
          const props = cxt.parentSchema.properties;
          const { definedProperties } = cxt.it;
          for (const requiredKey of schema) {
            if ((props === null || props === void 0 ? void 0 : props[requiredKey]) === void 0 && !definedProperties.has(requiredKey)) {
              const schemaPath = it.schemaEnv.baseId + it.errSchemaPath;
              const msg = `required property "${requiredKey}" is not defined at "${schemaPath}" (strictRequired)`;
              (0, util_1.checkStrictMode)(it, msg, it.opts.strictRequired);
            }
          }
        }
        function allErrorsMode() {
          if (useLoop || $data) {
            cxt.block$data(codegen_1.nil, loopAllRequired);
          } else {
            for (const prop of schema) {
              (0, code_1.checkReportMissingProp)(cxt, prop);
            }
          }
        }
        function exitOnErrorMode() {
          const missing = gen.let("missing");
          if (useLoop || $data) {
            const valid = gen.let("valid", true);
            cxt.block$data(valid, () => loopUntilMissing(missing, valid));
            cxt.ok(valid);
          } else {
            gen.if((0, code_1.checkMissingProp)(cxt, schema, missing));
            (0, code_1.reportMissingProp)(cxt, missing);
            gen.else();
          }
        }
        function loopAllRequired() {
          gen.forOf("prop", schemaCode, (prop) => {
            cxt.setParams({ missingProperty: prop });
            gen.if((0, code_1.noPropertyInData)(gen, data, prop, opts.ownProperties), () => cxt.error());
          });
        }
        function loopUntilMissing(missing, valid) {
          cxt.setParams({ missingProperty: missing });
          gen.forOf(missing, schemaCode, () => {
            gen.assign(valid, (0, code_1.propertyInData)(gen, data, missing, opts.ownProperties));
            gen.if((0, codegen_1.not)(valid), () => {
              cxt.error();
              gen.break();
            });
          }, codegen_1.nil);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitItems.js
var require_limitItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/limitItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message({ keyword, schemaCode }) {
        const comp = keyword === "maxItems" ? "more" : "fewer";
        return (0, codegen_1.str)`must NOT have ${comp} than ${schemaCode} items`;
      },
      params: ({ schemaCode }) => (0, codegen_1._)`{limit: ${schemaCode}}`
    };
    var def = {
      keyword: ["maxItems", "minItems"],
      type: "array",
      schemaType: "number",
      $data: true,
      error,
      code(cxt) {
        const { keyword, data, schemaCode } = cxt;
        const op = keyword === "maxItems" ? codegen_1.operators.GT : codegen_1.operators.LT;
        cxt.fail$data((0, codegen_1._)`${data}.length ${op} ${schemaCode}`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/runtime/equal.js
var require_equal2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/runtime/equal.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var equal = require_fast_deep_equal();
    equal.code = 'require("ajv/dist/runtime/equal").default';
    exports.default = equal;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js
var require_uniqueItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/uniqueItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dataType_1 = require_dataType2();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var equal_1 = require_equal2();
    var error = {
      message: ({ params: { i, j } }) => (0, codegen_1.str)`must NOT have duplicate items (items ## ${j} and ${i} are identical)`,
      params: ({ params: { i, j } }) => (0, codegen_1._)`{i: ${i}, j: ${j}}`
    };
    var def = {
      keyword: "uniqueItems",
      type: "array",
      schemaType: "boolean",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, parentSchema, schemaCode, it } = cxt;
        if (!$data && !schema)
          return;
        const valid = gen.let("valid");
        const itemTypes = parentSchema.items ? (0, dataType_1.getSchemaTypes)(parentSchema.items) : [];
        cxt.block$data(valid, validateUniqueItems, (0, codegen_1._)`${schemaCode} === false`);
        cxt.ok(valid);
        function validateUniqueItems() {
          const i = gen.let("i", (0, codegen_1._)`${data}.length`);
          const j = gen.let("j");
          cxt.setParams({ i, j });
          gen.assign(valid, true);
          gen.if((0, codegen_1._)`${i} > 1`, () => (canOptimize() ? loopN : loopN2)(i, j));
        }
        function canOptimize() {
          return itemTypes.length > 0 && !itemTypes.some((t2) => t2 === "object" || t2 === "array");
        }
        function loopN(i, j) {
          const item = gen.name("item");
          const wrongType = (0, dataType_1.checkDataTypes)(itemTypes, item, it.opts.strictNumbers, dataType_1.DataType.Wrong);
          const indices = gen.const("indices", (0, codegen_1._)`{}`);
          gen.for((0, codegen_1._)`;${i}--;`, () => {
            gen.let(item, (0, codegen_1._)`${data}[${i}]`);
            gen.if(wrongType, (0, codegen_1._)`continue`);
            if (itemTypes.length > 1)
              gen.if((0, codegen_1._)`typeof ${item} == "string"`, (0, codegen_1._)`${item} += "_"`);
            gen.if((0, codegen_1._)`typeof ${indices}[${item}] == "number"`, () => {
              gen.assign(j, (0, codegen_1._)`${indices}[${item}]`);
              cxt.error();
              gen.assign(valid, false).break();
            }).code((0, codegen_1._)`${indices}[${item}] = ${i}`);
          });
        }
        function loopN2(i, j) {
          const eql = (0, util_1.useFunc)(gen, equal_1.default);
          const outer = gen.name("outer");
          gen.label(outer).for((0, codegen_1._)`;${i}--;`, () => gen.for((0, codegen_1._)`${j} = ${i}; ${j}--;`, () => gen.if((0, codegen_1._)`${eql}(${data}[${i}], ${data}[${j}])`, () => {
            cxt.error();
            gen.assign(valid, false).break(outer);
          })));
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/const.js
var require_const2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/const.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var equal_1 = require_equal2();
    var error = {
      message: "must be equal to constant",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValue: ${schemaCode}}`
    };
    var def = {
      keyword: "const",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schemaCode, schema } = cxt;
        if ($data || schema && typeof schema == "object") {
          cxt.fail$data((0, codegen_1._)`!${(0, util_1.useFunc)(gen, equal_1.default)}(${data}, ${schemaCode})`);
        } else {
          cxt.fail((0, codegen_1._)`${schema} !== ${data}`);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/enum.js
var require_enum2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/enum.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var equal_1 = require_equal2();
    var error = {
      message: "must be equal to one of the allowed values",
      params: ({ schemaCode }) => (0, codegen_1._)`{allowedValues: ${schemaCode}}`
    };
    var def = {
      keyword: "enum",
      schemaType: "array",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        if (!$data && schema.length === 0)
          throw new Error("enum must have non-empty array");
        const useLoop = schema.length >= it.opts.loopEnum;
        let eql;
        const getEql = () => eql !== null && eql !== void 0 ? eql : eql = (0, util_1.useFunc)(gen, equal_1.default);
        let valid;
        if (useLoop || $data) {
          valid = gen.let("valid");
          cxt.block$data(valid, loopEnum);
        } else {
          if (!Array.isArray(schema))
            throw new Error("ajv implementation error");
          const vSchema = gen.const("vSchema", schemaCode);
          valid = (0, codegen_1.or)(...schema.map((_x, i) => equalCode(vSchema, i)));
        }
        cxt.pass(valid);
        function loopEnum() {
          gen.assign(valid, false);
          gen.forOf("v", schemaCode, (v) => gen.if((0, codegen_1._)`${getEql()}(${data}, ${v})`, () => gen.assign(valid, true).break()));
        }
        function equalCode(vSchema, i) {
          const sch = schema[i];
          return typeof sch === "object" && sch !== null ? (0, codegen_1._)`${getEql()}(${data}, ${vSchema}[${i}])` : (0, codegen_1._)`${data} === ${sch}`;
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/index.js
var require_validation2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/validation/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var limitNumber_1 = require_limitNumber2();
    var multipleOf_1 = require_multipleOf2();
    var limitLength_1 = require_limitLength2();
    var pattern_1 = require_pattern2();
    var limitProperties_1 = require_limitProperties2();
    var required_1 = require_required2();
    var limitItems_1 = require_limitItems2();
    var uniqueItems_1 = require_uniqueItems2();
    var const_1 = require_const2();
    var enum_1 = require_enum2();
    var validation = [
      // number
      limitNumber_1.default,
      multipleOf_1.default,
      // string
      limitLength_1.default,
      pattern_1.default,
      // object
      limitProperties_1.default,
      required_1.default,
      // array
      limitItems_1.default,
      uniqueItems_1.default,
      // any
      { keyword: "type", schemaType: ["string", "array"] },
      { keyword: "nullable", schemaType: "boolean" },
      const_1.default,
      enum_1.default
    ];
    exports.default = validation;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js
var require_additionalItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateAdditionalItems = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "additionalItems",
      type: "array",
      schemaType: ["boolean", "object"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { parentSchema, it } = cxt;
        const { items } = parentSchema;
        if (!Array.isArray(items)) {
          (0, util_1.checkStrictMode)(it, '"additionalItems" is ignored when "items" is not an array of schemas');
          return;
        }
        validateAdditionalItems(cxt, items);
      }
    };
    function validateAdditionalItems(cxt, items) {
      const { gen, schema, data, keyword, it } = cxt;
      it.items = true;
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      if (schema === false) {
        cxt.setParams({ len: items.length });
        cxt.pass((0, codegen_1._)`${len} <= ${items.length}`);
      } else if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
        const valid = gen.var("valid", (0, codegen_1._)`${len} <= ${items.length}`);
        gen.if((0, codegen_1.not)(valid), () => validateItems(valid));
        cxt.ok(valid);
      }
      function validateItems(valid) {
        gen.forRange("i", items.length, len, (i) => {
          cxt.subschema({ keyword, dataProp: i, dataPropType: util_1.Type.Num }, valid);
          if (!it.allErrors)
            gen.if((0, codegen_1.not)(valid), () => gen.break());
        });
      }
    }
    exports.validateAdditionalItems = validateAdditionalItems;
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items.js
var require_items2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateTuple = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var code_1 = require_code4();
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "array", "boolean"],
      before: "uniqueItems",
      code(cxt) {
        const { schema, it } = cxt;
        if (Array.isArray(schema))
          return validateTuple(cxt, "additionalItems", schema);
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    function validateTuple(cxt, extraItems, schArr = cxt.schema) {
      const { gen, parentSchema, data, keyword, it } = cxt;
      checkStrictTuple(parentSchema);
      if (it.opts.unevaluated && schArr.length && it.items !== true) {
        it.items = util_1.mergeEvaluated.items(gen, schArr.length, it.items);
      }
      const valid = gen.name("valid");
      const len = gen.const("len", (0, codegen_1._)`${data}.length`);
      schArr.forEach((sch, i) => {
        if ((0, util_1.alwaysValidSchema)(it, sch))
          return;
        gen.if((0, codegen_1._)`${len} > ${i}`, () => cxt.subschema({
          keyword,
          schemaProp: i,
          dataProp: i
        }, valid));
        cxt.ok(valid);
      });
      function checkStrictTuple(sch) {
        const { opts, errSchemaPath } = it;
        const l = schArr.length;
        const fullTuple = l === sch.minItems && (l === sch.maxItems || sch[extraItems] === false);
        if (opts.strictTuples && !fullTuple) {
          const msg = `"${keyword}" is ${l}-tuple, but minItems or maxItems/${extraItems} are not specified or different at path "${errSchemaPath}"`;
          (0, util_1.checkStrictMode)(it, msg, opts.strictTuples);
        }
      }
    }
    exports.validateTuple = validateTuple;
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js
var require_prefixItems2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/prefixItems.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var items_1 = require_items2();
    var def = {
      keyword: "prefixItems",
      type: "array",
      schemaType: ["array"],
      before: "uniqueItems",
      code: (cxt) => (0, items_1.validateTuple)(cxt, "items")
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items2020.js
var require_items20202 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/items2020.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var code_1 = require_code4();
    var additionalItems_1 = require_additionalItems2();
    var error = {
      message: ({ params: { len } }) => (0, codegen_1.str)`must NOT have more than ${len} items`,
      params: ({ params: { len } }) => (0, codegen_1._)`{limit: ${len}}`
    };
    var def = {
      keyword: "items",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      error,
      code(cxt) {
        const { schema, parentSchema, it } = cxt;
        const { prefixItems } = parentSchema;
        it.items = true;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        if (prefixItems)
          (0, additionalItems_1.validateAdditionalItems)(cxt, prefixItems);
        else
          cxt.ok((0, code_1.validateArray)(cxt));
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/contains.js
var require_contains2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/contains.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1.str)`must contain at least ${min} valid item(s)` : (0, codegen_1.str)`must contain at least ${min} and no more than ${max} valid item(s)`,
      params: ({ params: { min, max } }) => max === void 0 ? (0, codegen_1._)`{minContains: ${min}}` : (0, codegen_1._)`{minContains: ${min}, maxContains: ${max}}`
    };
    var def = {
      keyword: "contains",
      type: "array",
      schemaType: ["object", "boolean"],
      before: "uniqueItems",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        let min;
        let max;
        const { minContains, maxContains } = parentSchema;
        if (it.opts.next) {
          min = minContains === void 0 ? 1 : minContains;
          max = maxContains;
        } else {
          min = 1;
        }
        const len = gen.const("len", (0, codegen_1._)`${data}.length`);
        cxt.setParams({ min, max });
        if (max === void 0 && min === 0) {
          (0, util_1.checkStrictMode)(it, `"minContains" == 0 without "maxContains": "contains" keyword ignored`);
          return;
        }
        if (max !== void 0 && min > max) {
          (0, util_1.checkStrictMode)(it, `"minContains" > "maxContains" is always invalid`);
          cxt.fail();
          return;
        }
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          let cond = (0, codegen_1._)`${len} >= ${min}`;
          if (max !== void 0)
            cond = (0, codegen_1._)`${cond} && ${len} <= ${max}`;
          cxt.pass(cond);
          return;
        }
        it.items = true;
        const valid = gen.name("valid");
        if (max === void 0 && min === 1) {
          validateItems(valid, () => gen.if(valid, () => gen.break()));
        } else if (min === 0) {
          gen.let(valid, true);
          if (max !== void 0)
            gen.if((0, codegen_1._)`${data}.length > 0`, validateItemsWithCount);
        } else {
          gen.let(valid, false);
          validateItemsWithCount();
        }
        cxt.result(valid, () => cxt.reset());
        function validateItemsWithCount() {
          const schValid = gen.name("_valid");
          const count = gen.let("count", 0);
          validateItems(schValid, () => gen.if(schValid, () => checkLimits(count)));
        }
        function validateItems(_valid, block) {
          gen.forRange("i", 0, len, (i) => {
            cxt.subschema({
              keyword: "contains",
              dataProp: i,
              dataPropType: util_1.Type.Num,
              compositeRule: true
            }, _valid);
            block();
          });
        }
        function checkLimits(count) {
          gen.code((0, codegen_1._)`${count}++`);
          if (max === void 0) {
            gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true).break());
          } else {
            gen.if((0, codegen_1._)`${count} > ${max}`, () => gen.assign(valid, false).break());
            if (min === 1)
              gen.assign(valid, true);
            else
              gen.if((0, codegen_1._)`${count} >= ${min}`, () => gen.assign(valid, true));
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/dependencies.js
var require_dependencies2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/dependencies.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateSchemaDeps = exports.validatePropertyDeps = exports.error = void 0;
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var code_1 = require_code4();
    exports.error = {
      message: ({ params: { property, depsCount, deps } }) => {
        const property_ies = depsCount === 1 ? "property" : "properties";
        return (0, codegen_1.str)`must have ${property_ies} ${deps} when property ${property} is present`;
      },
      params: ({ params: { property, depsCount, deps, missingProperty } }) => (0, codegen_1._)`{property: ${property},
    missingProperty: ${missingProperty},
    depsCount: ${depsCount},
    deps: ${deps}}`
      // TODO change to reference
    };
    var def = {
      keyword: "dependencies",
      type: "object",
      schemaType: "object",
      error: exports.error,
      code(cxt) {
        const [propDeps, schDeps] = splitDependencies(cxt);
        validatePropertyDeps(cxt, propDeps);
        validateSchemaDeps(cxt, schDeps);
      }
    };
    function splitDependencies({ schema }) {
      const propertyDeps = {};
      const schemaDeps = {};
      for (const key in schema) {
        if (key === "__proto__")
          continue;
        const deps = Array.isArray(schema[key]) ? propertyDeps : schemaDeps;
        deps[key] = schema[key];
      }
      return [propertyDeps, schemaDeps];
    }
    function validatePropertyDeps(cxt, propertyDeps = cxt.schema) {
      const { gen, data, it } = cxt;
      if (Object.keys(propertyDeps).length === 0)
        return;
      const missing = gen.let("missing");
      for (const prop in propertyDeps) {
        const deps = propertyDeps[prop];
        if (deps.length === 0)
          continue;
        const hasProperty = (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties);
        cxt.setParams({
          property: prop,
          depsCount: deps.length,
          deps: deps.join(", ")
        });
        if (it.allErrors) {
          gen.if(hasProperty, () => {
            for (const depProp of deps) {
              (0, code_1.checkReportMissingProp)(cxt, depProp);
            }
          });
        } else {
          gen.if((0, codegen_1._)`${hasProperty} && (${(0, code_1.checkMissingProp)(cxt, deps, missing)})`);
          (0, code_1.reportMissingProp)(cxt, missing);
          gen.else();
        }
      }
    }
    exports.validatePropertyDeps = validatePropertyDeps;
    function validateSchemaDeps(cxt, schemaDeps = cxt.schema) {
      const { gen, data, keyword, it } = cxt;
      const valid = gen.name("valid");
      for (const prop in schemaDeps) {
        if ((0, util_1.alwaysValidSchema)(it, schemaDeps[prop]))
          continue;
        gen.if(
          (0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties),
          () => {
            const schCxt = cxt.subschema({ keyword, schemaProp: prop }, valid);
            cxt.mergeValidEvaluated(schCxt, valid);
          },
          () => gen.var(valid, true)
          // TODO var
        );
        cxt.ok(valid);
      }
    }
    exports.validateSchemaDeps = validateSchemaDeps;
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js
var require_propertyNames2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/propertyNames.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: "property name must be valid",
      params: ({ params }) => (0, codegen_1._)`{propertyName: ${params.propertyName}}`
    };
    var def = {
      keyword: "propertyNames",
      type: "object",
      schemaType: ["object", "boolean"],
      error,
      code(cxt) {
        const { gen, schema, data, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema))
          return;
        const valid = gen.name("valid");
        gen.forIn("key", data, (key) => {
          cxt.setParams({ propertyName: key });
          cxt.subschema({
            keyword: "propertyNames",
            data: key,
            dataTypes: ["string"],
            propertyName: key,
            compositeRule: true
          }, valid);
          gen.if((0, codegen_1.not)(valid), () => {
            cxt.error(true);
            if (!it.allErrors)
              gen.break();
          });
        });
        cxt.ok(valid);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js
var require_additionalProperties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/additionalProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var names_1 = require_names2();
    var util_1 = require_util2();
    var error = {
      message: "must NOT have additional properties",
      params: ({ params }) => (0, codegen_1._)`{additionalProperty: ${params.additionalProperty}}`
    };
    var def = {
      keyword: "additionalProperties",
      type: ["object"],
      schemaType: ["boolean", "object"],
      allowUndefined: true,
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, data, errsCount, it } = cxt;
        if (!errsCount)
          throw new Error("ajv implementation error");
        const { allErrors, opts } = it;
        it.props = true;
        if (opts.removeAdditional !== "all" && (0, util_1.alwaysValidSchema)(it, schema))
          return;
        const props = (0, code_1.allSchemaProperties)(parentSchema.properties);
        const patProps = (0, code_1.allSchemaProperties)(parentSchema.patternProperties);
        checkAdditionalProperties();
        cxt.ok((0, codegen_1._)`${errsCount} === ${names_1.default.errors}`);
        function checkAdditionalProperties() {
          gen.forIn("key", data, (key) => {
            if (!props.length && !patProps.length)
              additionalPropertyCode(key);
            else
              gen.if(isAdditional(key), () => additionalPropertyCode(key));
          });
        }
        function isAdditional(key) {
          let definedProp;
          if (props.length > 8) {
            const propsSchema = (0, util_1.schemaRefOrVal)(it, parentSchema.properties, "properties");
            definedProp = (0, code_1.isOwnProperty)(gen, propsSchema, key);
          } else if (props.length) {
            definedProp = (0, codegen_1.or)(...props.map((p) => (0, codegen_1._)`${key} === ${p}`));
          } else {
            definedProp = codegen_1.nil;
          }
          if (patProps.length) {
            definedProp = (0, codegen_1.or)(definedProp, ...patProps.map((p) => (0, codegen_1._)`${(0, code_1.usePattern)(cxt, p)}.test(${key})`));
          }
          return (0, codegen_1.not)(definedProp);
        }
        function deleteAdditional(key) {
          gen.code((0, codegen_1._)`delete ${data}[${key}]`);
        }
        function additionalPropertyCode(key) {
          if (opts.removeAdditional === "all" || opts.removeAdditional && schema === false) {
            deleteAdditional(key);
            return;
          }
          if (schema === false) {
            cxt.setParams({ additionalProperty: key });
            cxt.error();
            if (!allErrors)
              gen.break();
            return;
          }
          if (typeof schema == "object" && !(0, util_1.alwaysValidSchema)(it, schema)) {
            const valid = gen.name("valid");
            if (opts.removeAdditional === "failing") {
              applyAdditionalSchema(key, valid, false);
              gen.if((0, codegen_1.not)(valid), () => {
                cxt.reset();
                deleteAdditional(key);
              });
            } else {
              applyAdditionalSchema(key, valid);
              if (!allErrors)
                gen.if((0, codegen_1.not)(valid), () => gen.break());
            }
          }
        }
        function applyAdditionalSchema(key, valid, errors) {
          const subschema = {
            keyword: "additionalProperties",
            dataProp: key,
            dataPropType: util_1.Type.Str
          };
          if (errors === false) {
            Object.assign(subschema, {
              compositeRule: true,
              createErrors: false,
              allErrors: false
            });
          }
          cxt.subschema(subschema, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/properties.js
var require_properties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var validate_1 = require_validate2();
    var code_1 = require_code4();
    var util_1 = require_util2();
    var additionalProperties_1 = require_additionalProperties2();
    var def = {
      keyword: "properties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, parentSchema, data, it } = cxt;
        if (it.opts.removeAdditional === "all" && parentSchema.additionalProperties === void 0) {
          additionalProperties_1.default.code(new validate_1.KeywordCxt(it, additionalProperties_1.default, "additionalProperties"));
        }
        const allProps = (0, code_1.allSchemaProperties)(schema);
        for (const prop of allProps) {
          it.definedProperties.add(prop);
        }
        if (it.opts.unevaluated && allProps.length && it.props !== true) {
          it.props = util_1.mergeEvaluated.props(gen, (0, util_1.toHash)(allProps), it.props);
        }
        const properties = allProps.filter((p) => !(0, util_1.alwaysValidSchema)(it, schema[p]));
        if (properties.length === 0)
          return;
        const valid = gen.name("valid");
        for (const prop of properties) {
          if (hasDefault(prop)) {
            applyPropertySchema(prop);
          } else {
            gen.if((0, code_1.propertyInData)(gen, data, prop, it.opts.ownProperties));
            applyPropertySchema(prop);
            if (!it.allErrors)
              gen.else().var(valid, true);
            gen.endIf();
          }
          cxt.it.definedProperties.add(prop);
          cxt.ok(valid);
        }
        function hasDefault(prop) {
          return it.opts.useDefaults && !it.compositeRule && schema[prop].default !== void 0;
        }
        function applyPropertySchema(prop) {
          cxt.subschema({
            keyword: "properties",
            schemaProp: prop,
            dataProp: prop
          }, valid);
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js
var require_patternProperties2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/patternProperties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code4();
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var util_2 = require_util2();
    var def = {
      keyword: "patternProperties",
      type: "object",
      schemaType: "object",
      code(cxt) {
        const { gen, schema, data, parentSchema, it } = cxt;
        const { opts } = it;
        const patterns = (0, code_1.allSchemaProperties)(schema);
        const alwaysValidPatterns = patterns.filter((p) => (0, util_1.alwaysValidSchema)(it, schema[p]));
        if (patterns.length === 0 || alwaysValidPatterns.length === patterns.length && (!it.opts.unevaluated || it.props === true)) {
          return;
        }
        const checkProperties = opts.strictSchema && !opts.allowMatchingProperties && parentSchema.properties;
        const valid = gen.name("valid");
        if (it.props !== true && !(it.props instanceof codegen_1.Name)) {
          it.props = (0, util_2.evaluatedPropsToName)(gen, it.props);
        }
        const { props } = it;
        validatePatternProperties();
        function validatePatternProperties() {
          for (const pat of patterns) {
            if (checkProperties)
              checkMatchingProperties(pat);
            if (it.allErrors) {
              validateProperties(pat);
            } else {
              gen.var(valid, true);
              validateProperties(pat);
              gen.if(valid);
            }
          }
        }
        function checkMatchingProperties(pat) {
          for (const prop in checkProperties) {
            if (new RegExp(pat).test(prop)) {
              (0, util_1.checkStrictMode)(it, `property ${prop} matches pattern ${pat} (use allowMatchingProperties)`);
            }
          }
        }
        function validateProperties(pat) {
          gen.forIn("key", data, (key) => {
            gen.if((0, codegen_1._)`${(0, code_1.usePattern)(cxt, pat)}.test(${key})`, () => {
              const alwaysValid = alwaysValidPatterns.includes(pat);
              if (!alwaysValid) {
                cxt.subschema({
                  keyword: "patternProperties",
                  schemaProp: pat,
                  dataProp: key,
                  dataPropType: util_2.Type.Str
                }, valid);
              }
              if (it.opts.unevaluated && props !== true) {
                gen.assign((0, codegen_1._)`${props}[${key}]`, true);
              } else if (!alwaysValid && !it.allErrors) {
                gen.if((0, codegen_1.not)(valid), () => gen.break());
              }
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/not.js
var require_not2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/not.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "not",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      code(cxt) {
        const { gen, schema, it } = cxt;
        if ((0, util_1.alwaysValidSchema)(it, schema)) {
          cxt.fail();
          return;
        }
        const valid = gen.name("valid");
        cxt.subschema({
          keyword: "not",
          compositeRule: true,
          createErrors: false,
          allErrors: false
        }, valid);
        cxt.failResult(valid, () => cxt.reset(), () => cxt.error());
      },
      error: { message: "must NOT be valid" }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/anyOf.js
var require_anyOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/anyOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var code_1 = require_code4();
    var def = {
      keyword: "anyOf",
      schemaType: "array",
      trackErrors: true,
      code: code_1.validateUnion,
      error: { message: "must match a schema in anyOf" }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/oneOf.js
var require_oneOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/oneOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: "must match exactly one schema in oneOf",
      params: ({ params }) => (0, codegen_1._)`{passingSchemas: ${params.passing}}`
    };
    var def = {
      keyword: "oneOf",
      schemaType: "array",
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, schema, parentSchema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        if (it.opts.discriminator && parentSchema.discriminator)
          return;
        const schArr = schema;
        const valid = gen.let("valid", false);
        const passing = gen.let("passing", null);
        const schValid = gen.name("_valid");
        cxt.setParams({ passing });
        gen.block(validateOneOf);
        cxt.result(valid, () => cxt.reset(), () => cxt.error(true));
        function validateOneOf() {
          schArr.forEach((sch, i) => {
            let schCxt;
            if ((0, util_1.alwaysValidSchema)(it, sch)) {
              gen.var(schValid, true);
            } else {
              schCxt = cxt.subschema({
                keyword: "oneOf",
                schemaProp: i,
                compositeRule: true
              }, schValid);
            }
            if (i > 0) {
              gen.if((0, codegen_1._)`${schValid} && ${valid}`).assign(valid, false).assign(passing, (0, codegen_1._)`[${passing}, ${i}]`).else();
            }
            gen.if(schValid, () => {
              gen.assign(valid, true);
              gen.assign(passing, i);
              if (schCxt)
                cxt.mergeEvaluated(schCxt, codegen_1.Name);
            });
          });
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/allOf.js
var require_allOf2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/allOf.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: "allOf",
      schemaType: "array",
      code(cxt) {
        const { gen, schema, it } = cxt;
        if (!Array.isArray(schema))
          throw new Error("ajv implementation error");
        const valid = gen.name("valid");
        schema.forEach((sch, i) => {
          if ((0, util_1.alwaysValidSchema)(it, sch))
            return;
          const schCxt = cxt.subschema({ keyword: "allOf", schemaProp: i }, valid);
          cxt.ok(valid);
          cxt.mergeEvaluated(schCxt);
        });
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/if.js
var require_if2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/if.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var util_1 = require_util2();
    var error = {
      message: ({ params }) => (0, codegen_1.str)`must match "${params.ifClause}" schema`,
      params: ({ params }) => (0, codegen_1._)`{failingKeyword: ${params.ifClause}}`
    };
    var def = {
      keyword: "if",
      schemaType: ["object", "boolean"],
      trackErrors: true,
      error,
      code(cxt) {
        const { gen, parentSchema, it } = cxt;
        if (parentSchema.then === void 0 && parentSchema.else === void 0) {
          (0, util_1.checkStrictMode)(it, '"if" without "then" and "else" is ignored');
        }
        const hasThen = hasSchema(it, "then");
        const hasElse = hasSchema(it, "else");
        if (!hasThen && !hasElse)
          return;
        const valid = gen.let("valid", true);
        const schValid = gen.name("_valid");
        validateIf();
        cxt.reset();
        if (hasThen && hasElse) {
          const ifClause = gen.let("ifClause");
          cxt.setParams({ ifClause });
          gen.if(schValid, validateClause("then", ifClause), validateClause("else", ifClause));
        } else if (hasThen) {
          gen.if(schValid, validateClause("then"));
        } else {
          gen.if((0, codegen_1.not)(schValid), validateClause("else"));
        }
        cxt.pass(valid, () => cxt.error(true));
        function validateIf() {
          const schCxt = cxt.subschema({
            keyword: "if",
            compositeRule: true,
            createErrors: false,
            allErrors: false
          }, schValid);
          cxt.mergeEvaluated(schCxt);
        }
        function validateClause(keyword, ifClause) {
          return () => {
            const schCxt = cxt.subschema({ keyword }, schValid);
            gen.assign(valid, schValid);
            cxt.mergeValidEvaluated(schCxt, valid);
            if (ifClause)
              gen.assign(ifClause, (0, codegen_1._)`${keyword}`);
            else
              cxt.setParams({ ifClause: keyword });
          };
        }
      }
    };
    function hasSchema(it, keyword) {
      const schema = it.schema[keyword];
      return schema !== void 0 && !(0, util_1.alwaysValidSchema)(it, schema);
    }
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/thenElse.js
var require_thenElse2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/thenElse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var util_1 = require_util2();
    var def = {
      keyword: ["then", "else"],
      schemaType: ["object", "boolean"],
      code({ keyword, parentSchema, it }) {
        if (parentSchema.if === void 0)
          (0, util_1.checkStrictMode)(it, `"${keyword}" without "if" is ignored`);
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/index.js
var require_applicator2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/applicator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var additionalItems_1 = require_additionalItems2();
    var prefixItems_1 = require_prefixItems2();
    var items_1 = require_items2();
    var items2020_1 = require_items20202();
    var contains_1 = require_contains2();
    var dependencies_1 = require_dependencies2();
    var propertyNames_1 = require_propertyNames2();
    var additionalProperties_1 = require_additionalProperties2();
    var properties_1 = require_properties2();
    var patternProperties_1 = require_patternProperties2();
    var not_1 = require_not2();
    var anyOf_1 = require_anyOf2();
    var oneOf_1 = require_oneOf2();
    var allOf_1 = require_allOf2();
    var if_1 = require_if2();
    var thenElse_1 = require_thenElse2();
    function getApplicator(draft2020 = false) {
      const applicator = [
        // any
        not_1.default,
        anyOf_1.default,
        oneOf_1.default,
        allOf_1.default,
        if_1.default,
        thenElse_1.default,
        // object
        propertyNames_1.default,
        additionalProperties_1.default,
        dependencies_1.default,
        properties_1.default,
        patternProperties_1.default
      ];
      if (draft2020)
        applicator.push(prefixItems_1.default, items2020_1.default);
      else
        applicator.push(additionalItems_1.default, items_1.default);
      applicator.push(contains_1.default);
      return applicator;
    }
    exports.default = getApplicator;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/format.js
var require_format3 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var error = {
      message: ({ schemaCode }) => (0, codegen_1.str)`must match format "${schemaCode}"`,
      params: ({ schemaCode }) => (0, codegen_1._)`{format: ${schemaCode}}`
    };
    var def = {
      keyword: "format",
      type: ["number", "string"],
      schemaType: "string",
      $data: true,
      error,
      code(cxt, ruleType) {
        const { gen, data, $data, schema, schemaCode, it } = cxt;
        const { opts, errSchemaPath, schemaEnv, self } = it;
        if (!opts.validateFormats)
          return;
        if ($data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fDef = gen.const("fDef", (0, codegen_1._)`${fmts}[${schemaCode}]`);
          const fType = gen.let("fType");
          const format = gen.let("format");
          gen.if((0, codegen_1._)`typeof ${fDef} == "object" && !(${fDef} instanceof RegExp)`, () => gen.assign(fType, (0, codegen_1._)`${fDef}.type || "string"`).assign(format, (0, codegen_1._)`${fDef}.validate`), () => gen.assign(fType, (0, codegen_1._)`"string"`).assign(format, fDef));
          cxt.fail$data((0, codegen_1.or)(unknownFmt(), invalidFmt()));
          function unknownFmt() {
            if (opts.strictSchema === false)
              return codegen_1.nil;
            return (0, codegen_1._)`${schemaCode} && !${format}`;
          }
          function invalidFmt() {
            const callFormat = schemaEnv.$async ? (0, codegen_1._)`(${fDef}.async ? await ${format}(${data}) : ${format}(${data}))` : (0, codegen_1._)`${format}(${data})`;
            const validData = (0, codegen_1._)`(typeof ${format} == "function" ? ${callFormat} : ${format}.test(${data}))`;
            return (0, codegen_1._)`${format} && ${format} !== true && ${fType} === ${ruleType} && !${validData}`;
          }
        }
        function validateFormat() {
          const formatDef = self.formats[schema];
          if (!formatDef) {
            unknownFormat();
            return;
          }
          if (formatDef === true)
            return;
          const [fmtType, format, fmtRef] = getFormat(formatDef);
          if (fmtType === ruleType)
            cxt.pass(validCondition());
          function unknownFormat() {
            if (opts.strictSchema === false) {
              self.logger.warn(unknownMsg());
              return;
            }
            throw new Error(unknownMsg());
            function unknownMsg() {
              return `unknown format "${schema}" ignored in schema at path "${errSchemaPath}"`;
            }
          }
          function getFormat(fmtDef) {
            const code = fmtDef instanceof RegExp ? (0, codegen_1.regexpCode)(fmtDef) : opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(schema)}` : void 0;
            const fmt = gen.scopeValue("formats", { key: schema, ref: fmtDef, code });
            if (typeof fmtDef == "object" && !(fmtDef instanceof RegExp)) {
              return [fmtDef.type || "string", fmtDef.validate, (0, codegen_1._)`${fmt}.validate`];
            }
            return ["string", fmtDef, fmt];
          }
          function validCondition() {
            if (typeof formatDef == "object" && !(formatDef instanceof RegExp) && formatDef.async) {
              if (!schemaEnv.$async)
                throw new Error("async format in sync schema");
              return (0, codegen_1._)`await ${fmtRef}(${data})`;
            }
            return typeof format == "function" ? (0, codegen_1._)`${fmtRef}(${data})` : (0, codegen_1._)`${fmtRef}.test(${data})`;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/index.js
var require_format4 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/format/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var format_1 = require_format3();
    var format = [format_1.default];
    exports.default = format;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/metadata.js
var require_metadata2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/metadata.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.contentVocabulary = exports.metadataVocabulary = void 0;
    exports.metadataVocabulary = [
      "title",
      "description",
      "default",
      "deprecated",
      "readOnly",
      "writeOnly",
      "examples"
    ];
    exports.contentVocabulary = [
      "contentMediaType",
      "contentEncoding",
      "contentSchema"
    ];
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/draft7.js
var require_draft72 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/draft7.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core_1 = require_core4();
    var validation_1 = require_validation2();
    var applicator_1 = require_applicator2();
    var format_1 = require_format4();
    var metadata_1 = require_metadata2();
    var draft7Vocabularies = [
      core_1.default,
      validation_1.default,
      (0, applicator_1.default)(),
      format_1.default,
      metadata_1.metadataVocabulary,
      metadata_1.contentVocabulary
    ];
    exports.default = draft7Vocabularies;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/types.js
var require_types2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DiscrError = void 0;
    var DiscrError;
    (function(DiscrError2) {
      DiscrError2["Tag"] = "tag";
      DiscrError2["Mapping"] = "mapping";
    })(DiscrError || (exports.DiscrError = DiscrError = {}));
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/index.js
var require_discriminator2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/vocabularies/discriminator/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var codegen_1 = require_codegen2();
    var types_1 = require_types2();
    var compile_1 = require_compile2();
    var ref_error_1 = require_ref_error2();
    var util_1 = require_util2();
    var error = {
      message: ({ params: { discrError, tagName } }) => discrError === types_1.DiscrError.Tag ? `tag "${tagName}" must be string` : `value of tag "${tagName}" must be in oneOf`,
      params: ({ params: { discrError, tag, tagName } }) => (0, codegen_1._)`{error: ${discrError}, tag: ${tagName}, tagValue: ${tag}}`
    };
    var def = {
      keyword: "discriminator",
      type: "object",
      schemaType: "object",
      error,
      code(cxt) {
        const { gen, data, schema, parentSchema, it } = cxt;
        const { oneOf } = parentSchema;
        if (!it.opts.discriminator) {
          throw new Error("discriminator: requires discriminator option");
        }
        const tagName = schema.propertyName;
        if (typeof tagName != "string")
          throw new Error("discriminator: requires propertyName");
        if (schema.mapping)
          throw new Error("discriminator: mapping is not supported");
        if (!oneOf)
          throw new Error("discriminator: requires oneOf keyword");
        const valid = gen.let("valid", false);
        const tag = gen.const("tag", (0, codegen_1._)`${data}${(0, codegen_1.getProperty)(tagName)}`);
        gen.if((0, codegen_1._)`typeof ${tag} == "string"`, () => validateMapping(), () => cxt.error(false, { discrError: types_1.DiscrError.Tag, tag, tagName }));
        cxt.ok(valid);
        function validateMapping() {
          const mapping = getMapping();
          gen.if(false);
          for (const tagValue in mapping) {
            gen.elseIf((0, codegen_1._)`${tag} === ${tagValue}`);
            gen.assign(valid, applyTagSchema(mapping[tagValue]));
          }
          gen.else();
          cxt.error(false, { discrError: types_1.DiscrError.Mapping, tag, tagName });
          gen.endIf();
        }
        function applyTagSchema(schemaProp) {
          const _valid = gen.name("valid");
          const schCxt = cxt.subschema({ keyword: "oneOf", schemaProp }, _valid);
          cxt.mergeEvaluated(schCxt, codegen_1.Name);
          return _valid;
        }
        function getMapping() {
          var _a13;
          const oneOfMapping = {};
          const topRequired = hasRequired(parentSchema);
          let tagRequired = true;
          for (let i = 0; i < oneOf.length; i++) {
            let sch = oneOf[i];
            if ((sch === null || sch === void 0 ? void 0 : sch.$ref) && !(0, util_1.schemaHasRulesButRef)(sch, it.self.RULES)) {
              const ref = sch.$ref;
              sch = compile_1.resolveRef.call(it.self, it.schemaEnv.root, it.baseId, ref);
              if (sch instanceof compile_1.SchemaEnv)
                sch = sch.schema;
              if (sch === void 0)
                throw new ref_error_1.default(it.opts.uriResolver, it.baseId, ref);
            }
            const propSch = (_a13 = sch === null || sch === void 0 ? void 0 : sch.properties) === null || _a13 === void 0 ? void 0 : _a13[tagName];
            if (typeof propSch != "object") {
              throw new Error(`discriminator: oneOf subschemas (or referenced schemas) must have "properties/${tagName}"`);
            }
            tagRequired = tagRequired && (topRequired || hasRequired(sch));
            addMappings(propSch, i);
          }
          if (!tagRequired)
            throw new Error(`discriminator: "${tagName}" must be required`);
          return oneOfMapping;
          function hasRequired({ required }) {
            return Array.isArray(required) && required.includes(tagName);
          }
          function addMappings(sch, i) {
            if (sch.const) {
              addMapping(sch.const, i);
            } else if (sch.enum) {
              for (const tagValue of sch.enum) {
                addMapping(tagValue, i);
              }
            } else {
              throw new Error(`discriminator: "properties/${tagName}" must have "const" or "enum"`);
            }
          }
          function addMapping(tagValue, i) {
            if (typeof tagValue != "string" || tagValue in oneOfMapping) {
              throw new Error(`discriminator: "${tagName}" values must be unique strings`);
            }
            oneOfMapping[tagValue] = i;
          }
        }
      }
    };
    exports.default = def;
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/refs/json-schema-draft-07.json
var require_json_schema_draft_072 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/refs/json-schema-draft-07.json"(exports, module) {
    module.exports = {
      $schema: "http://json-schema.org/draft-07/schema#",
      $id: "http://json-schema.org/draft-07/schema#",
      title: "Core schema meta-schema",
      definitions: {
        schemaArray: {
          type: "array",
          minItems: 1,
          items: { $ref: "#" }
        },
        nonNegativeInteger: {
          type: "integer",
          minimum: 0
        },
        nonNegativeIntegerDefault0: {
          allOf: [{ $ref: "#/definitions/nonNegativeInteger" }, { default: 0 }]
        },
        simpleTypes: {
          enum: ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        stringArray: {
          type: "array",
          items: { type: "string" },
          uniqueItems: true,
          default: []
        }
      },
      type: ["object", "boolean"],
      properties: {
        $id: {
          type: "string",
          format: "uri-reference"
        },
        $schema: {
          type: "string",
          format: "uri"
        },
        $ref: {
          type: "string",
          format: "uri-reference"
        },
        $comment: {
          type: "string"
        },
        title: {
          type: "string"
        },
        description: {
          type: "string"
        },
        default: true,
        readOnly: {
          type: "boolean",
          default: false
        },
        examples: {
          type: "array",
          items: true
        },
        multipleOf: {
          type: "number",
          exclusiveMinimum: 0
        },
        maximum: {
          type: "number"
        },
        exclusiveMaximum: {
          type: "number"
        },
        minimum: {
          type: "number"
        },
        exclusiveMinimum: {
          type: "number"
        },
        maxLength: { $ref: "#/definitions/nonNegativeInteger" },
        minLength: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        pattern: {
          type: "string",
          format: "regex"
        },
        additionalItems: { $ref: "#" },
        items: {
          anyOf: [{ $ref: "#" }, { $ref: "#/definitions/schemaArray" }],
          default: true
        },
        maxItems: { $ref: "#/definitions/nonNegativeInteger" },
        minItems: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        uniqueItems: {
          type: "boolean",
          default: false
        },
        contains: { $ref: "#" },
        maxProperties: { $ref: "#/definitions/nonNegativeInteger" },
        minProperties: { $ref: "#/definitions/nonNegativeIntegerDefault0" },
        required: { $ref: "#/definitions/stringArray" },
        additionalProperties: { $ref: "#" },
        definitions: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        properties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          default: {}
        },
        patternProperties: {
          type: "object",
          additionalProperties: { $ref: "#" },
          propertyNames: { format: "regex" },
          default: {}
        },
        dependencies: {
          type: "object",
          additionalProperties: {
            anyOf: [{ $ref: "#" }, { $ref: "#/definitions/stringArray" }]
          }
        },
        propertyNames: { $ref: "#" },
        const: true,
        enum: {
          type: "array",
          items: true,
          minItems: 1,
          uniqueItems: true
        },
        type: {
          anyOf: [
            { $ref: "#/definitions/simpleTypes" },
            {
              type: "array",
              items: { $ref: "#/definitions/simpleTypes" },
              minItems: 1,
              uniqueItems: true
            }
          ]
        },
        format: { type: "string" },
        contentMediaType: { type: "string" },
        contentEncoding: { type: "string" },
        if: { $ref: "#" },
        then: { $ref: "#" },
        else: { $ref: "#" },
        allOf: { $ref: "#/definitions/schemaArray" },
        anyOf: { $ref: "#/definitions/schemaArray" },
        oneOf: { $ref: "#/definitions/schemaArray" },
        not: { $ref: "#" }
      },
      default: true
    };
  }
});

// node_modules/ajv-formats/node_modules/ajv/dist/ajv.js
var require_ajv2 = __commonJS({
  "node_modules/ajv-formats/node_modules/ajv/dist/ajv.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MissingRefError = exports.ValidationError = exports.CodeGen = exports.Name = exports.nil = exports.stringify = exports.str = exports._ = exports.KeywordCxt = exports.Ajv = void 0;
    var core_1 = require_core3();
    var draft7_1 = require_draft72();
    var discriminator_1 = require_discriminator2();
    var draft7MetaSchema = require_json_schema_draft_072();
    var META_SUPPORT_DATA = ["/properties"];
    var META_SCHEMA_ID = "http://json-schema.org/draft-07/schema";
    var Ajv2 = class extends core_1.default {
      _addVocabularies() {
        super._addVocabularies();
        draft7_1.default.forEach((v) => this.addVocabulary(v));
        if (this.opts.discriminator)
          this.addKeyword(discriminator_1.default);
      }
      _addDefaultMetaSchema() {
        super._addDefaultMetaSchema();
        if (!this.opts.meta)
          return;
        const metaSchema = this.opts.$data ? this.$dataMetaSchema(draft7MetaSchema, META_SUPPORT_DATA) : draft7MetaSchema;
        this.addMetaSchema(metaSchema, META_SCHEMA_ID, false);
        this.refs["http://json-schema.org/schema"] = META_SCHEMA_ID;
      }
      defaultMeta() {
        return this.opts.defaultMeta = super.defaultMeta() || (this.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : void 0);
      }
    };
    exports.Ajv = Ajv2;
    module.exports = exports = Ajv2;
    module.exports.Ajv = Ajv2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = Ajv2;
    var validate_1 = require_validate2();
    Object.defineProperty(exports, "KeywordCxt", { enumerable: true, get: function() {
      return validate_1.KeywordCxt;
    } });
    var codegen_1 = require_codegen2();
    Object.defineProperty(exports, "_", { enumerable: true, get: function() {
      return codegen_1._;
    } });
    Object.defineProperty(exports, "str", { enumerable: true, get: function() {
      return codegen_1.str;
    } });
    Object.defineProperty(exports, "stringify", { enumerable: true, get: function() {
      return codegen_1.stringify;
    } });
    Object.defineProperty(exports, "nil", { enumerable: true, get: function() {
      return codegen_1.nil;
    } });
    Object.defineProperty(exports, "Name", { enumerable: true, get: function() {
      return codegen_1.Name;
    } });
    Object.defineProperty(exports, "CodeGen", { enumerable: true, get: function() {
      return codegen_1.CodeGen;
    } });
    var validation_error_1 = require_validation_error2();
    Object.defineProperty(exports, "ValidationError", { enumerable: true, get: function() {
      return validation_error_1.default;
    } });
    var ref_error_1 = require_ref_error2();
    Object.defineProperty(exports, "MissingRefError", { enumerable: true, get: function() {
      return ref_error_1.default;
    } });
  }
});

// node_modules/ajv-formats/dist/limit.js
var require_limit = __commonJS({
  "node_modules/ajv-formats/dist/limit.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatLimitDefinition = void 0;
    var ajv_1 = require_ajv2();
    var codegen_1 = require_codegen2();
    var ops = codegen_1.operators;
    var KWDs = {
      formatMaximum: { okStr: "<=", ok: ops.LTE, fail: ops.GT },
      formatMinimum: { okStr: ">=", ok: ops.GTE, fail: ops.LT },
      formatExclusiveMaximum: { okStr: "<", ok: ops.LT, fail: ops.GTE },
      formatExclusiveMinimum: { okStr: ">", ok: ops.GT, fail: ops.LTE }
    };
    var error = {
      message: ({ keyword, schemaCode }) => (0, codegen_1.str)`should be ${KWDs[keyword].okStr} ${schemaCode}`,
      params: ({ keyword, schemaCode }) => (0, codegen_1._)`{comparison: ${KWDs[keyword].okStr}, limit: ${schemaCode}}`
    };
    exports.formatLimitDefinition = {
      keyword: Object.keys(KWDs),
      type: "string",
      schemaType: "string",
      $data: true,
      error,
      code(cxt) {
        const { gen, data, schemaCode, keyword, it } = cxt;
        const { opts, self } = it;
        if (!opts.validateFormats)
          return;
        const fCxt = new ajv_1.KeywordCxt(it, self.RULES.all.format.definition, "format");
        if (fCxt.$data)
          validate$DataFormat();
        else
          validateFormat();
        function validate$DataFormat() {
          const fmts = gen.scopeValue("formats", {
            ref: self.formats,
            code: opts.code.formats
          });
          const fmt = gen.const("fmt", (0, codegen_1._)`${fmts}[${fCxt.schemaCode}]`);
          cxt.fail$data((0, codegen_1.or)((0, codegen_1._)`typeof ${fmt} != "object"`, (0, codegen_1._)`${fmt} instanceof RegExp`, (0, codegen_1._)`typeof ${fmt}.compare != "function"`, compareCode(fmt)));
        }
        function validateFormat() {
          const format = fCxt.schema;
          const fmtDef = self.formats[format];
          if (!fmtDef || fmtDef === true)
            return;
          if (typeof fmtDef != "object" || fmtDef instanceof RegExp || typeof fmtDef.compare != "function") {
            throw new Error(`"${keyword}": format "${format}" does not define "compare" function`);
          }
          const fmt = gen.scopeValue("formats", {
            key: format,
            ref: fmtDef,
            code: opts.code.formats ? (0, codegen_1._)`${opts.code.formats}${(0, codegen_1.getProperty)(format)}` : void 0
          });
          cxt.fail$data(compareCode(fmt));
        }
        function compareCode(fmt) {
          return (0, codegen_1._)`${fmt}.compare(${data}, ${schemaCode}) ${KWDs[keyword].fail} 0`;
        }
      },
      dependencies: ["format"]
    };
    var formatLimitPlugin = (ajv) => {
      ajv.addKeyword(exports.formatLimitDefinition);
      return ajv;
    };
    exports.default = formatLimitPlugin;
  }
});

// node_modules/ajv-formats/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/ajv-formats/dist/index.js"(exports, module) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var formats_1 = require_formats();
    var limit_1 = require_limit();
    var codegen_1 = require_codegen2();
    var fullName = new codegen_1.Name("fullFormats");
    var fastName = new codegen_1.Name("fastFormats");
    var formatsPlugin = (ajv, opts = { keywords: true }) => {
      if (Array.isArray(opts)) {
        addFormats(ajv, opts, formats_1.fullFormats, fullName);
        return ajv;
      }
      const [formats, exportName] = opts.mode === "fast" ? [formats_1.fastFormats, fastName] : [formats_1.fullFormats, fullName];
      const list = opts.formats || formats_1.formatNames;
      addFormats(ajv, list, formats, exportName);
      if (opts.keywords)
        (0, limit_1.default)(ajv);
      return ajv;
    };
    formatsPlugin.get = (name, mode = "full") => {
      const formats = mode === "fast" ? formats_1.fastFormats : formats_1.fullFormats;
      const f = formats[name];
      if (!f)
        throw new Error(`Unknown format "${name}"`);
      return f;
    };
    function addFormats(ajv, list, fs, exportName) {
      var _a13;
      var _b;
      (_a13 = (_b = ajv.opts.code).formats) !== null && _a13 !== void 0 ? _a13 : _b.formats = (0, codegen_1._)`require("ajv-formats/dist/formats").${exportName}`;
      for (const f of list)
        ajv.addFormat(f, fs[f]);
    }
    module.exports = exports = formatsPlugin;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.default = formatsPlugin;
  }
});

// node_modules/fast-unique-numbers/build/es2019/factories/add-unique-number.js
var createAddUniqueNumber;
var init_add_unique_number = __esm({
  "node_modules/fast-unique-numbers/build/es2019/factories/add-unique-number.js"() {
    createAddUniqueNumber = (generateUniqueNumber3) => {
      return (set2) => {
        const number4 = generateUniqueNumber3(set2);
        set2.add(number4);
        return number4;
      };
    };
  }
});

// node_modules/fast-unique-numbers/build/es2019/factories/cache.js
var createCache;
var init_cache = __esm({
  "node_modules/fast-unique-numbers/build/es2019/factories/cache.js"() {
    createCache = (lastNumberWeakMap) => {
      return (collection, nextNumber) => {
        lastNumberWeakMap.set(collection, nextNumber);
        return nextNumber;
      };
    };
  }
});

// node_modules/fast-unique-numbers/build/es2019/factories/generate-unique-number.js
var MAX_SAFE_INTEGER, TWO_TO_THE_POWER_OF_TWENTY_NINE, TWO_TO_THE_POWER_OF_THIRTY, createGenerateUniqueNumber;
var init_generate_unique_number = __esm({
  "node_modules/fast-unique-numbers/build/es2019/factories/generate-unique-number.js"() {
    MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER === void 0 ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
    TWO_TO_THE_POWER_OF_TWENTY_NINE = 536870912;
    TWO_TO_THE_POWER_OF_THIRTY = TWO_TO_THE_POWER_OF_TWENTY_NINE * 2;
    createGenerateUniqueNumber = (cache3, lastNumberWeakMap) => {
      return (collection) => {
        const lastNumber = lastNumberWeakMap.get(collection);
        let nextNumber = lastNumber === void 0 ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY ? lastNumber + 1 : 0;
        if (!collection.has(nextNumber)) {
          return cache3(collection, nextNumber);
        }
        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE) {
          while (collection.has(nextNumber)) {
            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY);
          }
          return cache3(collection, nextNumber);
        }
        if (collection.size > MAX_SAFE_INTEGER) {
          throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");
        }
        while (collection.has(nextNumber)) {
          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER);
        }
        return cache3(collection, nextNumber);
      };
    };
  }
});

// node_modules/fast-unique-numbers/build/es2019/module.js
var LAST_NUMBER_WEAK_MAP, cache, generateUniqueNumber, addUniqueNumber;
var init_module = __esm({
  "node_modules/fast-unique-numbers/build/es2019/module.js"() {
    init_add_unique_number();
    init_cache();
    init_generate_unique_number();
    LAST_NUMBER_WEAK_MAP = /* @__PURE__ */ new WeakMap();
    cache = createCache(LAST_NUMBER_WEAK_MAP);
    generateUniqueNumber = createGenerateUniqueNumber(cache, LAST_NUMBER_WEAK_MAP);
    addUniqueNumber = createAddUniqueNumber(generateUniqueNumber);
  }
});

// node_modules/broker-factory/build/es2019/factories/create-broker.js
var createBrokerFactory;
var init_create_broker = __esm({
  "node_modules/broker-factory/build/es2019/factories/create-broker.js"() {
    createBrokerFactory = (createOrGetOngoingRequests, extendBrokerImplementation, generateUniqueNumber3, isMessagePort2) => (brokerImplementation) => {
      const fullBrokerImplementation = extendBrokerImplementation(brokerImplementation);
      return (sender) => {
        const ongoingRequests = createOrGetOngoingRequests(sender);
        sender.addEventListener("message", ({ data: message }) => {
          const { id } = message;
          if (id !== null && ongoingRequests.has(id)) {
            const { reject, resolve } = ongoingRequests.get(id);
            ongoingRequests.delete(id);
            if (message.error === void 0) {
              resolve(message.result);
            } else {
              reject(new Error(message.error.message));
            }
          }
        });
        if (isMessagePort2(sender)) {
          sender.start();
        }
        const call = (method, params = null, transferables = []) => {
          return new Promise((resolve, reject) => {
            const id = generateUniqueNumber3(ongoingRequests);
            ongoingRequests.set(id, { reject, resolve });
            if (params === null) {
              sender.postMessage({ id, method }, transferables);
            } else {
              sender.postMessage({ id, method, params }, transferables);
            }
          });
        };
        const notify = (method, params, transferables = []) => {
          sender.postMessage({ id: null, method, params }, transferables);
        };
        let functions = {};
        for (const [key, handler2] of Object.entries(fullBrokerImplementation)) {
          functions = { ...functions, [key]: handler2({ call, notify }) };
        }
        return { ...functions };
      };
    };
  }
});

// node_modules/broker-factory/build/es2019/factories/create-or-get-ongoing-requests.js
var createCreateOrGetOngoingRequests;
var init_create_or_get_ongoing_requests = __esm({
  "node_modules/broker-factory/build/es2019/factories/create-or-get-ongoing-requests.js"() {
    createCreateOrGetOngoingRequests = (ongoingRequestsMap) => (sender) => {
      if (ongoingRequestsMap.has(sender)) {
        return ongoingRequestsMap.get(sender);
      }
      const ongoingRequests = /* @__PURE__ */ new Map();
      ongoingRequestsMap.set(sender, ongoingRequests);
      return ongoingRequests;
    };
  }
});

// node_modules/broker-factory/build/es2019/factories/extend-broker-implementation.js
var createExtendBrokerImplementation;
var init_extend_broker_implementation = __esm({
  "node_modules/broker-factory/build/es2019/factories/extend-broker-implementation.js"() {
    createExtendBrokerImplementation = (portMap) => (partialBrokerImplementation) => ({
      ...partialBrokerImplementation,
      connect: ({ call }) => {
        return async () => {
          const { port1, port2 } = new MessageChannel();
          const portId = await call("connect", { port: port1 }, [port1]);
          portMap.set(port2, portId);
          return port2;
        };
      },
      disconnect: ({ call }) => {
        return async (port) => {
          const portId = portMap.get(port);
          if (portId === void 0) {
            throw new Error("The given port is not connected.");
          }
          await call("disconnect", { portId });
        };
      },
      isSupported: ({ call }) => {
        return () => call("isSupported");
      }
    });
  }
});

// node_modules/broker-factory/build/es2019/guards/message-port.js
var isMessagePort;
var init_message_port = __esm({
  "node_modules/broker-factory/build/es2019/guards/message-port.js"() {
    isMessagePort = (sender) => {
      return typeof sender.start === "function";
    };
  }
});

// node_modules/broker-factory/build/es2019/interfaces/broker-actions.js
var init_broker_actions = __esm({
  "node_modules/broker-factory/build/es2019/interfaces/broker-actions.js"() {
  }
});

// node_modules/broker-factory/build/es2019/interfaces/broker-definition.js
var init_broker_definition = __esm({
  "node_modules/broker-factory/build/es2019/interfaces/broker-definition.js"() {
  }
});

// node_modules/broker-factory/build/es2019/interfaces/default-broker-definition.js
var init_default_broker_definition = __esm({
  "node_modules/broker-factory/build/es2019/interfaces/default-broker-definition.js"() {
  }
});

// node_modules/broker-factory/build/es2019/interfaces/worker-event.js
var init_worker_event = __esm({
  "node_modules/broker-factory/build/es2019/interfaces/worker-event.js"() {
  }
});

// node_modules/broker-factory/build/es2019/interfaces/index.js
var init_interfaces = __esm({
  "node_modules/broker-factory/build/es2019/interfaces/index.js"() {
    init_broker_actions();
    init_broker_definition();
    init_default_broker_definition();
    init_worker_event();
  }
});

// node_modules/broker-factory/build/es2019/types/broker-implementation.js
var init_broker_implementation = __esm({
  "node_modules/broker-factory/build/es2019/types/broker-implementation.js"() {
  }
});

// node_modules/broker-factory/build/es2019/types/index.js
var init_types = __esm({
  "node_modules/broker-factory/build/es2019/types/index.js"() {
    init_broker_implementation();
  }
});

// node_modules/broker-factory/build/es2019/module.js
var createBroker;
var init_module2 = __esm({
  "node_modules/broker-factory/build/es2019/module.js"() {
    init_module();
    init_create_broker();
    init_create_or_get_ongoing_requests();
    init_extend_broker_implementation();
    init_message_port();
    init_interfaces();
    init_types();
    createBroker = createBrokerFactory(createCreateOrGetOngoingRequests(/* @__PURE__ */ new WeakMap()), createExtendBrokerImplementation(/* @__PURE__ */ new WeakMap()), generateUniqueNumber, isMessagePort);
  }
});

// node_modules/media-encoder-host-broker/build/es2019/interfaces/media-encoder-host-broker-definition.js
var init_media_encoder_host_broker_definition = __esm({
  "node_modules/media-encoder-host-broker/build/es2019/interfaces/media-encoder-host-broker-definition.js"() {
  }
});

// node_modules/media-encoder-host-broker/build/es2019/interfaces/index.js
var init_interfaces2 = __esm({
  "node_modules/media-encoder-host-broker/build/es2019/interfaces/index.js"() {
    init_media_encoder_host_broker_definition();
  }
});

// node_modules/media-encoder-host-broker/build/es2019/types/media-encoder-host-broker-loader.js
var init_media_encoder_host_broker_loader = __esm({
  "node_modules/media-encoder-host-broker/build/es2019/types/media-encoder-host-broker-loader.js"() {
  }
});

// node_modules/media-encoder-host-broker/build/es2019/types/media-encoder-host-broker-wrapper.js
var init_media_encoder_host_broker_wrapper = __esm({
  "node_modules/media-encoder-host-broker/build/es2019/types/media-encoder-host-broker-wrapper.js"() {
  }
});

// node_modules/media-encoder-host-broker/build/es2019/types/index.js
var init_types2 = __esm({
  "node_modules/media-encoder-host-broker/build/es2019/types/index.js"() {
    init_media_encoder_host_broker_loader();
    init_media_encoder_host_broker_wrapper();
  }
});

// node_modules/media-encoder-host-broker/build/es2019/module.js
var encoderIds, wrap, load;
var init_module3 = __esm({
  "node_modules/media-encoder-host-broker/build/es2019/module.js"() {
    init_module2();
    init_module();
    init_interfaces2();
    init_types2();
    encoderIds = /* @__PURE__ */ new Set();
    wrap = createBroker({
      deregister: ({ call }) => {
        return (port) => {
          return call("deregister", { port }, [port]);
        };
      },
      encode: ({ call }) => {
        return async (encoderId, timeslice) => {
          const arrayBuffers = await call("encode", { encoderId, timeslice });
          encoderIds.delete(encoderId);
          return arrayBuffers;
        };
      },
      instantiate: ({ call }) => {
        return async (mimeType, sampleRate) => {
          const encoderId = addUniqueNumber(encoderIds);
          const port = await call("instantiate", { encoderId, mimeType, sampleRate });
          return { encoderId, port };
        };
      },
      register: ({ call }) => {
        return (port) => {
          return call("register", { port }, [port]);
        };
      }
    });
    load = (url4) => {
      const worker3 = new Worker(url4);
      return wrap(worker3);
    };
  }
});

// node_modules/media-encoder-host/build/es2019/worker/worker.js
var worker;
var init_worker = __esm({
  "node_modules/media-encoder-host/build/es2019/worker/worker.js"() {
    worker = `(()=>{var e={455:function(e,t){!function(e){"use strict";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,o=536870912,s=2*o,a=function(e,t){return function(r){var a=t.get(r),i=void 0===a?r.size:a<s?a+1:0;if(!r.has(i))return e(r,i);if(r.size<o){for(;r.has(i);)i=Math.floor(Math.random()*s);return e(r,i)}if(r.size>n)throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");for(;r.has(i);)i=Math.floor(Math.random()*n);return e(r,i)}},i=new WeakMap,c=r(i),l=a(c,i),d=t(l);e.addUniqueNumber=d,e.generateUniqueNumber=l}(t)}},t={};function r(n){var o=t[n];if(void 0!==o)return o.exports;var s=t[n]={exports:{}};return e[n].call(s.exports,s,s.exports,r),s.exports}(()=>{"use strict";var e=r(455);const t=new WeakMap,n=new WeakMap,o=(r=>{const o=(s=r,{...s,connect:e=>{let{call:r}=e;return async()=>{const{port1:e,port2:n}=new MessageChannel,o=await r("connect",{port:e},[e]);return t.set(n,o),n}},disconnect:e=>{let{call:r}=e;return async e=>{const n=t.get(e);if(void 0===n)throw new Error("The given port is not connected.");await r("disconnect",{portId:n})}},isSupported:e=>{let{call:t}=e;return()=>t("isSupported")}});var s;return t=>{const r=(e=>{if(n.has(e))return n.get(e);const t=new Map;return n.set(e,t),t})(t);t.addEventListener("message",(e=>{let{data:t}=e;const{id:n}=t;if(null!==n&&r.has(n)){const{reject:e,resolve:o}=r.get(n);r.delete(n),void 0===t.error?o(t.result):e(new Error(t.error.message))}})),(e=>"function"==typeof e.start)(t)&&t.start();const s=function(n){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];return new Promise(((a,i)=>{const c=(0,e.generateUniqueNumber)(r);r.set(c,{reject:i,resolve:a}),null===o?t.postMessage({id:c,method:n},s):t.postMessage({id:c,method:n,params:o},s)}))},a=function(e,r){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];t.postMessage({id:null,method:e,params:r},n)};let i={};for(const[e,t]of Object.entries(o))i={...i,[e]:t({call:s,notify:a})};return{...i}}})({characterize:e=>{let{call:t}=e;return()=>t("characterize")},encode:e=>{let{call:t}=e;return(e,r)=>t("encode",{recordingId:e,timeslice:r})},record:e=>{let{call:t}=e;return async(e,r,n)=>{await t("record",{recordingId:e,sampleRate:r,typedArrays:n},n.map((e=>{let{buffer:t}=e;return t})))}}}),s=-32603,a=-32602,i=-32601,c=(e,t)=>Object.assign(new Error(e),{status:t}),l=e=>c('The handler of the method called "'.concat(e,'" returned an unexpected result.'),s),d=(e,t)=>async r=>{let{data:{id:n,method:o,params:a}}=r;const d=t[o];try{if(void 0===d)throw(e=>c('The requested method called "'.concat(e,'" is not supported.'),i))(o);const t=void 0===a?d():d(a);if(void 0===t)throw(e=>c('The handler of the method called "'.concat(e,'" returned no required result.'),s))(o);const r=t instanceof Promise?await t:t;if(null===n){if(void 0!==r.result)throw l(o)}else{if(void 0===r.result)throw l(o);const{result:t,transferables:s=[]}=r;e.postMessage({id:n,result:t},s)}}catch(t){const{message:r,status:o=-32603}=t;e.postMessage({error:{code:o,message:r},id:n})}},u=new Map,h=(t,r,n)=>({...r,connect:n=>{let{port:o}=n;o.start();const s=t(o,r),a=(0,e.generateUniqueNumber)(u);return u.set(a,(()=>{s(),o.close(),u.delete(a)})),{result:a}},disconnect:e=>{let{portId:t}=e;const r=u.get(t);if(void 0===r)throw(e=>c('The specified parameter called "portId" with the given value "'.concat(e,'" does not identify a port connected to this worker.'),a))(t);return r(),{result:null}},isSupported:async()=>{if(await new Promise((e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=t=>{let{data:r}=t;return e(null!==r)},n.postMessage(t,[t])}))){const e=n();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),f=function(e,t){const r=h(f,t,arguments.length>2&&void 0!==arguments[2]?arguments[2]:()=>!0),n=d(e,r);return e.addEventListener("message",n),()=>e.removeEventListener("message",n)},p=e=>{e.onmessage=null,e.close()},w=new Map,m=new WeakMap,g=((e,t)=>r=>{const n=t.get(r);if(void 0===n)throw new Error("There is no encoder stored which wraps this port.");e.delete(n),t.delete(r)})(w,m),v=new Map,y=(e=>t=>{const r=e.get(t);if(void 0===r)throw new Error("There was no instance of an encoder stored with the given id.");return r})(v),M=((e,t)=>r=>{const n=t(r);return e.delete(r),n})(v,y),E=((e,t)=>r=>{const[n,o,s,a]=t(r);return s?new Promise((t=>{o.onmessage=s=>{let{data:i}=s;0===i.length?(e(o),t(n.encode(r,null))):n.record(r,a,i)}})):n.encode(r,null)})(p,M),b=(e=>t=>{for(const[r,n]of Array.from(e.values()))if(r.test(t))return n;throw new Error("There is no encoder registered which could handle the given mimeType.")})(w),T=((e,t,r)=>(n,o,s)=>{if(t.has(n))throw new Error('There is already an encoder registered with an id called "'.concat(n,'".'));const a=r(o),{port1:i,port2:c}=new MessageChannel,l=[a,i,!0,s];return t.set(n,l),i.onmessage=t=>{let{data:r}=t;0===r.length?(e(i),l[2]=!1):a.record(n,s,r.map((e=>"number"==typeof e?new Float32Array(e):e)))},c})(p,v,b),I=((e,t,r)=>async n=>{const o=r(n),s=await o.characterize(),a=s.toString();if(e.has(a)||t.has(n))throw new Error("There is already an encoder stored which handles exactly the same mime types.");return e.set(a,[s,o]),t.set(n,a),s})(w,m,o),A=(e=>(t,r)=>{const[n]=e(t);return n.encode(t,r)})(y);f(self,{deregister:async e=>{let{port:t}=e;return{result:g(t)}},encode:async e=>{let{encoderId:t,timeslice:r}=e;const n=null===r?await E(t):await A(t,r);return{result:n,transferables:n}},instantiate:e=>{let{encoderId:t,mimeType:r,sampleRate:n}=e;const o=T(t,r,n);return{result:o,transferables:[o]}},register:async e=>{let{port:t}=e;return{result:await I(t)}}})})()})();`;
  }
});

// node_modules/media-encoder-host/build/es2019/module.js
var blob, url2, mediaEncoderHost, connect, deregister, disconnect, encode, instantiate, isSupported, register;
var init_module4 = __esm({
  "node_modules/media-encoder-host/build/es2019/module.js"() {
    init_module3();
    init_worker();
    blob = new Blob([worker], { type: "application/javascript; charset=utf-8" });
    url2 = URL.createObjectURL(blob);
    mediaEncoderHost = load(url2);
    connect = mediaEncoderHost.connect;
    deregister = mediaEncoderHost.deregister;
    disconnect = mediaEncoderHost.disconnect;
    encode = mediaEncoderHost.encode;
    instantiate = mediaEncoderHost.instantiate;
    isSupported = mediaEncoderHost.isSupported;
    register = mediaEncoderHost.register;
    URL.revokeObjectURL(url2);
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/blob-event-factory.js
var createBlobEventFactory;
var init_blob_event_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/blob-event-factory.js"() {
    createBlobEventFactory = (nativeBlobEventConstructor2) => {
      return (type, blobEventInit) => {
        if (nativeBlobEventConstructor2 === null) {
          const { data, ...eventInit } = blobEventInit;
          const fakeBlobEvent = new Event(type, eventInit);
          fakeBlobEvent.data = data;
          return fakeBlobEvent;
        }
        return new nativeBlobEventConstructor2(type, blobEventInit);
      };
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/decode-web-m-chunk.js
var createDecodeWebMChunk;
var init_decode_web_m_chunk = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/decode-web-m-chunk.js"() {
    createDecodeWebMChunk = (readElementContent2, readElementType2) => {
      return (dataView, elementType, channelCount) => {
        const contents = [];
        let currentElementType = elementType;
        let offset = 0;
        while (offset < dataView.byteLength) {
          if (currentElementType === null) {
            const lengthAndType = readElementType2(dataView, offset);
            if (lengthAndType === null) {
              break;
            }
            const { length, type } = lengthAndType;
            currentElementType = type;
            offset += length;
          } else {
            const contentAndLength = readElementContent2(dataView, offset, currentElementType, channelCount);
            if (contentAndLength === null) {
              break;
            }
            const { content, length } = contentAndLength;
            currentElementType = null;
            offset += length;
            if (content !== null) {
              contents.push(content);
            }
          }
        }
        return { contents, currentElementType, offset };
      };
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/event-target-constructor.js
var createEventTargetConstructor;
var init_event_target_constructor = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/event-target-constructor.js"() {
    createEventTargetConstructor = (createEventTarget2, wrapEventListener3) => {
      return class EventTarget {
        constructor(nativeEventTarget = null) {
          this._listeners = /* @__PURE__ */ new WeakMap();
          this._nativeEventTarget = nativeEventTarget === null ? createEventTarget2() : nativeEventTarget;
        }
        addEventListener(type, listener, options) {
          if (listener !== null) {
            let wrappedEventListener = this._listeners.get(listener);
            if (wrappedEventListener === void 0) {
              wrappedEventListener = wrapEventListener3(this, listener);
              if (typeof listener === "function") {
                this._listeners.set(listener, wrappedEventListener);
              }
            }
            this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);
          }
        }
        dispatchEvent(event) {
          return this._nativeEventTarget.dispatchEvent(event);
        }
        removeEventListener(type, listener, options) {
          const wrappedEventListener = listener === null ? void 0 : this._listeners.get(listener);
          this._nativeEventTarget.removeEventListener(type, wrappedEventListener === void 0 ? null : wrappedEventListener, options);
        }
      };
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/event-target-factory.js
var createEventTargetFactory;
var init_event_target_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/event-target-factory.js"() {
    createEventTargetFactory = (window5) => {
      return () => {
        if (window5 === null) {
          throw new Error("A native EventTarget could not be created.");
        }
        return window5.document.createElement("p");
      };
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/invalid-modification-error.js
var createInvalidModificationError;
var init_invalid_modification_error = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/invalid-modification-error.js"() {
    createInvalidModificationError = (message = "") => {
      try {
        return new DOMException(message, "InvalidModificationError");
      } catch (err) {
        err.code = 13;
        err.message = message;
        err.name = "InvalidModificationError";
        return err;
      }
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/invalid-state-error.js
var createInvalidStateError;
var init_invalid_state_error = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/invalid-state-error.js"() {
    createInvalidStateError = () => {
      try {
        return new DOMException("", "InvalidStateError");
      } catch (err) {
        err.code = 11;
        err.name = "InvalidStateError";
        return err;
      }
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/is-supported-promise.js
var createIsSupportedPromise;
var init_is_supported_promise = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/is-supported-promise.js"() {
    createIsSupportedPromise = (window5) => {
      if (window5 !== null && window5.MediaStream !== void 0 && /*
       * Bug #10: An early experimental implemenation in Safari did not provide the isTypeSupported() function.
       */
      (window5.MediaRecorder === void 0 || window5.MediaRecorder.isTypeSupported !== void 0)) {
        return new Promise((resolve) => {
          if (window5.MediaRecorder === void 0) {
            return resolve(true);
          }
          const canvasElement = document.createElement("canvas");
          canvasElement.getContext("2d");
          if (typeof canvasElement.captureStream !== "function") {
            return resolve(false);
          }
          const mediaStream = canvasElement.captureStream();
          const mimeType = "audio/webm";
          try {
            const mediaRecorder = new window5.MediaRecorder(mediaStream, { mimeType });
            mediaRecorder.addEventListener("dataavailable", ({ data }) => resolve(data.type === mimeType));
            mediaRecorder.start();
            setTimeout(() => mediaRecorder.stop(), 10);
          } catch (err) {
            resolve(err.name === "NotSupportedError");
          }
        });
      }
      return Promise.resolve(false);
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/media-recorder-constructor.js
var createMediaRecorderConstructor;
var init_media_recorder_constructor = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/media-recorder-constructor.js"() {
    createMediaRecorderConstructor = (createNativeMediaRecorder2, createNotSupportedError3, createWebAudioMediaRecorder2, createWebmPcmMediaRecorder2, encoderRegexes2, eventTargetConstructor2, nativeMediaRecorderConstructor2) => {
      return class MediaRecorder extends eventTargetConstructor2 {
        constructor(stream, options = {}) {
          const { mimeType } = options;
          if (nativeMediaRecorderConstructor2 !== null && // Bug #10: Safari does not yet implement the isTypeSupported() method.
          (mimeType === void 0 || nativeMediaRecorderConstructor2.isTypeSupported !== void 0 && nativeMediaRecorderConstructor2.isTypeSupported(mimeType))) {
            const internalMediaRecorder = createNativeMediaRecorder2(nativeMediaRecorderConstructor2, stream, options);
            super(internalMediaRecorder);
            this._internalMediaRecorder = internalMediaRecorder;
          } else if (mimeType !== void 0 && encoderRegexes2.some((regex) => regex.test(mimeType))) {
            super();
            if (nativeMediaRecorderConstructor2 !== null && nativeMediaRecorderConstructor2.isTypeSupported !== void 0 && nativeMediaRecorderConstructor2.isTypeSupported("audio/webm;codecs=pcm")) {
              this._internalMediaRecorder = createWebmPcmMediaRecorder2(this, nativeMediaRecorderConstructor2, stream, mimeType);
            } else {
              this._internalMediaRecorder = createWebAudioMediaRecorder2(this, stream, mimeType);
            }
          } else {
            if (nativeMediaRecorderConstructor2 !== null) {
              createNativeMediaRecorder2(nativeMediaRecorderConstructor2, stream, options);
            }
            throw createNotSupportedError3();
          }
          this._ondataavailable = null;
          this._onerror = null;
          this._onpause = null;
          this._onresume = null;
          this._onstart = null;
          this._onstop = null;
        }
        get mimeType() {
          return this._internalMediaRecorder.mimeType;
        }
        get ondataavailable() {
          return this._ondataavailable === null ? this._ondataavailable : this._ondataavailable[0];
        }
        set ondataavailable(value) {
          if (this._ondataavailable !== null) {
            this.removeEventListener("dataavailable", this._ondataavailable[1]);
          }
          if (typeof value === "function") {
            const boundListener = value.bind(this);
            this.addEventListener("dataavailable", boundListener);
            this._ondataavailable = [value, boundListener];
          } else {
            this._ondataavailable = null;
          }
        }
        get onerror() {
          return this._onerror === null ? this._onerror : this._onerror[0];
        }
        set onerror(value) {
          if (this._onerror !== null) {
            this.removeEventListener("error", this._onerror[1]);
          }
          if (typeof value === "function") {
            const boundListener = value.bind(this);
            this.addEventListener("error", boundListener);
            this._onerror = [value, boundListener];
          } else {
            this._onerror = null;
          }
        }
        get onpause() {
          return this._onpause === null ? this._onpause : this._onpause[0];
        }
        set onpause(value) {
          if (this._onpause !== null) {
            this.removeEventListener("pause", this._onpause[1]);
          }
          if (typeof value === "function") {
            const boundListener = value.bind(this);
            this.addEventListener("pause", boundListener);
            this._onpause = [value, boundListener];
          } else {
            this._onpause = null;
          }
        }
        get onresume() {
          return this._onresume === null ? this._onresume : this._onresume[0];
        }
        set onresume(value) {
          if (this._onresume !== null) {
            this.removeEventListener("resume", this._onresume[1]);
          }
          if (typeof value === "function") {
            const boundListener = value.bind(this);
            this.addEventListener("resume", boundListener);
            this._onresume = [value, boundListener];
          } else {
            this._onresume = null;
          }
        }
        get onstart() {
          return this._onstart === null ? this._onstart : this._onstart[0];
        }
        set onstart(value) {
          if (this._onstart !== null) {
            this.removeEventListener("start", this._onstart[1]);
          }
          if (typeof value === "function") {
            const boundListener = value.bind(this);
            this.addEventListener("start", boundListener);
            this._onstart = [value, boundListener];
          } else {
            this._onstart = null;
          }
        }
        get onstop() {
          return this._onstop === null ? this._onstop : this._onstop[0];
        }
        set onstop(value) {
          if (this._onstop !== null) {
            this.removeEventListener("stop", this._onstop[1]);
          }
          if (typeof value === "function") {
            const boundListener = value.bind(this);
            this.addEventListener("stop", boundListener);
            this._onstop = [value, boundListener];
          } else {
            this._onstop = null;
          }
        }
        get state() {
          return this._internalMediaRecorder.state;
        }
        pause() {
          return this._internalMediaRecorder.pause();
        }
        resume() {
          return this._internalMediaRecorder.resume();
        }
        start(timeslice) {
          return this._internalMediaRecorder.start(timeslice);
        }
        stop() {
          return this._internalMediaRecorder.stop();
        }
        static isTypeSupported(mimeType) {
          return nativeMediaRecorderConstructor2 !== null && // Bug #10: Safari does not yet implement the isTypeSupported() method.
          nativeMediaRecorderConstructor2.isTypeSupported !== void 0 && nativeMediaRecorderConstructor2.isTypeSupported(mimeType) || encoderRegexes2.some((regex) => regex.test(mimeType));
        }
      };
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/native-blob-event-constructor.js
var createNativeBlobEventConstructor;
var init_native_blob_event_constructor = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/native-blob-event-constructor.js"() {
    createNativeBlobEventConstructor = (window5) => {
      if (window5 !== null && window5.BlobEvent !== void 0) {
        return window5.BlobEvent;
      }
      return null;
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/native-media-recorder.js
var createNativeMediaRecorderFactory;
var init_native_media_recorder = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/native-media-recorder.js"() {
    createNativeMediaRecorderFactory = (createInvalidModificationError2, createNotSupportedError3) => {
      return (nativeMediaRecorderConstructor2, stream, mediaRecorderOptions) => {
        const bufferedBlobs = [];
        const dataAvailableListeners = /* @__PURE__ */ new WeakMap();
        const errorListeners = /* @__PURE__ */ new WeakMap();
        const nativeMediaRecorder = new nativeMediaRecorderConstructor2(stream, mediaRecorderOptions);
        const stopListeners = /* @__PURE__ */ new WeakMap();
        let isActive = true;
        nativeMediaRecorder.addEventListener = /* @__PURE__ */ ((addEventListener) => {
          return (type, listener, options) => {
            let patchedEventListener = listener;
            if (typeof listener === "function") {
              if (type === "dataavailable") {
                patchedEventListener = (event) => {
                  setTimeout(() => {
                    if (isActive && nativeMediaRecorder.state === "inactive") {
                      bufferedBlobs.push(event.data);
                    } else {
                      if (bufferedBlobs.length > 0) {
                        const blob3 = event.data;
                        Object.defineProperty(event, "data", {
                          value: new Blob([...bufferedBlobs, blob3], { type: blob3.type })
                        });
                        bufferedBlobs.length = 0;
                      }
                      listener.call(nativeMediaRecorder, event);
                    }
                  });
                };
                dataAvailableListeners.set(listener, patchedEventListener);
              } else if (type === "error") {
                patchedEventListener = (event) => {
                  if (event.error === void 0) {
                    listener.call(nativeMediaRecorder, new ErrorEvent("error", { error: createInvalidModificationError2() }));
                  } else if (event.error.name === "UnknownError") {
                    const message = event.error.message;
                    listener.call(nativeMediaRecorder, new ErrorEvent("error", { error: createInvalidModificationError2(message) }));
                  } else if (event instanceof ErrorEvent) {
                    listener.call(nativeMediaRecorder, event);
                  } else {
                    listener.call(nativeMediaRecorder, new ErrorEvent("error", { error: event.error }));
                  }
                };
                errorListeners.set(listener, patchedEventListener);
              } else if (type === "stop") {
                patchedEventListener = (event) => {
                  isActive = false;
                  setTimeout(() => listener.call(nativeMediaRecorder, event));
                };
                stopListeners.set(listener, patchedEventListener);
              }
            }
            return addEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);
          };
        })(nativeMediaRecorder.addEventListener);
        nativeMediaRecorder.dispatchEvent = /* @__PURE__ */ ((dispatchEvent) => {
          return (event) => {
            let wasActive;
            setTimeout(() => {
              wasActive = isActive;
              isActive = false;
            });
            const returnValue = dispatchEvent.call(nativeMediaRecorder, event);
            setTimeout(() => isActive = wasActive);
            return returnValue;
          };
        })(nativeMediaRecorder.dispatchEvent);
        nativeMediaRecorder.removeEventListener = /* @__PURE__ */ ((removeEventListener) => {
          return (type, listener, options) => {
            let patchedEventListener = listener;
            if (typeof listener === "function") {
              if (type === "dataavailable") {
                const dataAvailableListener = dataAvailableListeners.get(listener);
                if (dataAvailableListener !== void 0) {
                  patchedEventListener = dataAvailableListener;
                }
              } else if (type === "error") {
                const errorListener = errorListeners.get(listener);
                if (errorListener !== void 0) {
                  patchedEventListener = errorListener;
                }
              } else if (type === "stop") {
                const stopListener = stopListeners.get(listener);
                if (stopListener !== void 0) {
                  patchedEventListener = stopListener;
                }
              }
            }
            return removeEventListener.call(nativeMediaRecorder, type, patchedEventListener, options);
          };
        })(nativeMediaRecorder.removeEventListener);
        nativeMediaRecorder.start = /* @__PURE__ */ ((start) => {
          return (timeslice) => {
            if (mediaRecorderOptions.mimeType !== void 0 && mediaRecorderOptions.mimeType.startsWith("audio/") && stream.getVideoTracks().length > 0) {
              throw createNotSupportedError3();
            }
            isActive = timeslice !== void 0;
            return timeslice === void 0 ? start.call(nativeMediaRecorder) : start.call(nativeMediaRecorder, timeslice);
          };
        })(nativeMediaRecorder.start);
        return nativeMediaRecorder;
      };
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/native-media-recorder-constructor.js
var createNativeMediaRecorderConstructor;
var init_native_media_recorder_constructor = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/native-media-recorder-constructor.js"() {
    createNativeMediaRecorderConstructor = (window5) => {
      if (window5 === null) {
        return null;
      }
      return window5.MediaRecorder === void 0 ? null : window5.MediaRecorder;
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/not-supported-error.js
var createNotSupportedError;
var init_not_supported_error = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/not-supported-error.js"() {
    createNotSupportedError = () => {
      try {
        return new DOMException("", "NotSupportedError");
      } catch (err) {
        err.code = 9;
        err.name = "NotSupportedError";
        return err;
      }
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/read-element-content.js
var createReadElementContent;
var init_read_element_content = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/read-element-content.js"() {
    createReadElementContent = (readVariableSizeInteger2) => {
      return (dataView, offset, type, channelCount = 2) => {
        const lengthAndValue = readVariableSizeInteger2(dataView, offset);
        if (lengthAndValue === null) {
          return lengthAndValue;
        }
        const { length, value } = lengthAndValue;
        if (type === "master") {
          return { content: null, length };
        }
        if (offset + length + value > dataView.byteLength) {
          return null;
        }
        if (type === "binary") {
          const numberOfSamples = (value / Float32Array.BYTES_PER_ELEMENT - 1) / channelCount;
          const content = Array.from({ length: channelCount }, () => new Float32Array(numberOfSamples));
          for (let i = 0; i < numberOfSamples; i += 1) {
            const elementOffset = i * channelCount + 1;
            for (let j = 0; j < channelCount; j += 1) {
              content[j][i] = dataView.getFloat32(offset + length + (elementOffset + j) * Float32Array.BYTES_PER_ELEMENT, true);
            }
          }
          return { content, length: length + value };
        }
        return { content: null, length: length + value };
      };
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/read-element-type.js
var createReadElementType;
var init_read_element_type = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/read-element-type.js"() {
    createReadElementType = (readVariableSizeInteger2) => {
      return (dataView, offset) => {
        const lengthAndValue = readVariableSizeInteger2(dataView, offset);
        if (lengthAndValue === null) {
          return lengthAndValue;
        }
        const { length, value } = lengthAndValue;
        if (value === 35) {
          return { length, type: "binary" };
        }
        if (value === 46 || value === 97 || value === 88713574 || value === 106212971 || value === 139690087 || value === 172351395 || value === 256095861) {
          return { length, type: "master" };
        }
        return { length, type: "unknown" };
      };
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/read-variable-size-integer.js
var createReadVariableSizeInteger;
var init_read_variable_size_integer = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/read-variable-size-integer.js"() {
    createReadVariableSizeInteger = (readVariableSizeIntegerLength2) => {
      return (dataView, offset) => {
        const length = readVariableSizeIntegerLength2(dataView, offset);
        if (length === null) {
          return length;
        }
        const firstDataByteOffset = offset + Math.floor((length - 1) / 8);
        if (firstDataByteOffset + length > dataView.byteLength) {
          return null;
        }
        const firstDataByte = dataView.getUint8(firstDataByteOffset);
        let value = firstDataByte & (1 << 8 - length % 8) - 1;
        for (let i = 1; i < length; i += 1) {
          value = (value << 8) + dataView.getUint8(firstDataByteOffset + i);
        }
        return { length, value };
      };
    };
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/factories/add-unique-number.js
var createAddUniqueNumber2;
var init_add_unique_number2 = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/factories/add-unique-number.js"() {
    createAddUniqueNumber2 = (generateUniqueNumber3) => {
      return (set2) => {
        const number4 = generateUniqueNumber3(set2);
        set2.add(number4);
        return number4;
      };
    };
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/factories/cache.js
var createCache2;
var init_cache2 = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/factories/cache.js"() {
    createCache2 = (lastNumberWeakMap) => {
      return (collection, nextNumber) => {
        lastNumberWeakMap.set(collection, nextNumber);
        return nextNumber;
      };
    };
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/factories/generate-unique-number.js
var MAX_SAFE_INTEGER2, TWO_TO_THE_POWER_OF_TWENTY_NINE2, TWO_TO_THE_POWER_OF_THIRTY2, createGenerateUniqueNumber2;
var init_generate_unique_number2 = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/factories/generate-unique-number.js"() {
    MAX_SAFE_INTEGER2 = Number.MAX_SAFE_INTEGER === void 0 ? 9007199254740991 : Number.MAX_SAFE_INTEGER;
    TWO_TO_THE_POWER_OF_TWENTY_NINE2 = 536870912;
    TWO_TO_THE_POWER_OF_THIRTY2 = TWO_TO_THE_POWER_OF_TWENTY_NINE2 * 2;
    createGenerateUniqueNumber2 = (cache3, lastNumberWeakMap) => {
      return (collection) => {
        const lastNumber = lastNumberWeakMap.get(collection);
        let nextNumber = lastNumber === void 0 ? collection.size : lastNumber < TWO_TO_THE_POWER_OF_THIRTY2 ? lastNumber + 1 : 0;
        if (!collection.has(nextNumber)) {
          return cache3(collection, nextNumber);
        }
        if (collection.size < TWO_TO_THE_POWER_OF_TWENTY_NINE2) {
          while (collection.has(nextNumber)) {
            nextNumber = Math.floor(Math.random() * TWO_TO_THE_POWER_OF_THIRTY2);
          }
          return cache3(collection, nextNumber);
        }
        if (collection.size > MAX_SAFE_INTEGER2) {
          throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");
        }
        while (collection.has(nextNumber)) {
          nextNumber = Math.floor(Math.random() * MAX_SAFE_INTEGER2);
        }
        return cache3(collection, nextNumber);
      };
    };
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/add-unique-number-factory.js
var init_add_unique_number_factory = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/add-unique-number-factory.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/add-unique-number-function.js
var init_add_unique_number_function = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/add-unique-number-function.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/cache-factory.js
var init_cache_factory = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/cache-factory.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/cache-function.js
var init_cache_function = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/cache-function.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/generate-unique-number-factory.js
var init_generate_unique_number_factory = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/generate-unique-number-factory.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/generate-unique-number-function.js
var init_generate_unique_number_function = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/generate-unique-number-function.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/index.js
var init_types3 = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/types/index.js"() {
    init_add_unique_number_factory();
    init_add_unique_number_function();
    init_cache_factory();
    init_cache_function();
    init_generate_unique_number_factory();
    init_generate_unique_number_function();
  }
});

// node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/module.js
var LAST_NUMBER_WEAK_MAP2, cache2, generateUniqueNumber2, addUniqueNumber2;
var init_module5 = __esm({
  "node_modules/recorder-audio-worklet/node_modules/fast-unique-numbers/build/es2019/module.js"() {
    init_add_unique_number2();
    init_cache2();
    init_generate_unique_number2();
    init_types3();
    LAST_NUMBER_WEAK_MAP2 = /* @__PURE__ */ new WeakMap();
    cache2 = createCache2(LAST_NUMBER_WEAK_MAP2);
    generateUniqueNumber2 = createGenerateUniqueNumber2(cache2, LAST_NUMBER_WEAK_MAP2);
    addUniqueNumber2 = createAddUniqueNumber2(generateUniqueNumber2);
  }
});

// node_modules/rxjs-interop/dist/esm/symbols.js
var observable;
var init_symbols = __esm({
  "node_modules/rxjs-interop/dist/esm/symbols.js"() {
    observable = Symbol.observable || "@@observable";
  }
});

// node_modules/rxjs-interop/dist/esm/patch.js
function patch(arg) {
  if (!Symbol.observable) {
    if (typeof arg === "function" && arg.prototype && arg.prototype[Symbol.observable]) {
      arg.prototype[observable] = arg.prototype[Symbol.observable];
      delete arg.prototype[Symbol.observable];
    } else {
      arg[observable] = arg[Symbol.observable];
      delete arg[Symbol.observable];
    }
  }
  return arg;
}
var init_patch = __esm({
  "node_modules/rxjs-interop/dist/esm/patch.js"() {
    init_symbols();
  }
});

// node_modules/rxjs-interop/dist/esm/to-observer.js
function toObserver(observer) {
  if (observer) {
    if (observer.next && observer.error && observer.complete) {
      return observer;
    }
    return {
      complete: (observer.complete ?? noop4).bind(observer),
      error: (observer.error ?? rethrow).bind(observer),
      next: (observer.next ?? noop4).bind(observer)
    };
  }
  return {
    complete: noop4,
    error: rethrow,
    next: noop4
  };
}
var noop4, rethrow;
var init_to_observer = __esm({
  "node_modules/rxjs-interop/dist/esm/to-observer.js"() {
    noop4 = () => {
    };
    rethrow = (error) => {
      throw error;
    };
  }
});

// node_modules/rxjs-interop/dist/esm/types.js
var init_types4 = __esm({
  "node_modules/rxjs-interop/dist/esm/types.js"() {
  }
});

// node_modules/rxjs-interop/dist/esm/index.js
var init_esm = __esm({
  "node_modules/rxjs-interop/dist/esm/index.js"() {
    init_patch();
    init_symbols();
    init_to_observer();
    init_types4();
  }
});

// node_modules/subscribable-things/build/es2019/factories/animation-frame.js
var createAnimationFrame;
var init_animation_frame = __esm({
  "node_modules/subscribable-things/build/es2019/factories/animation-frame.js"() {
    createAnimationFrame = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return () => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.cancelAnimationFrame === void 0 || window5.requestAnimationFrame === void 0) {
          return emitNotSupportedError2(observer);
        }
        let animationFrameHandle = window5.requestAnimationFrame(function animationFrameCallback(timestamp) {
          animationFrameHandle = window5.requestAnimationFrame(animationFrameCallback);
          observer.next(timestamp);
        });
        return () => window5.cancelAnimationFrame(animationFrameHandle);
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/attribute.js
var createAttribute;
var init_attribute = __esm({
  "node_modules/subscribable-things/build/es2019/factories/attribute.js"() {
    createAttribute = (mapSubscribableThing2, mutations2, prependSubscribableThing2) => {
      return (htmlElement, name) => {
        const getAttribute = () => htmlElement.getAttribute(name);
        return prependSubscribableThing2(mapSubscribableThing2(mutations2(htmlElement, {
          attributeFilter: [name],
          childList: false,
          subtree: false
        }), () => getAttribute()), getAttribute());
      };
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/geolocation.js
var createGeolocation;
var init_geolocation = __esm({
  "node_modules/subscribable-things/build/es2019/factories/geolocation.js"() {
    createGeolocation = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return (options) => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.navigator === void 0 || window5.navigator.geolocation === void 0 || window5.navigator.geolocation.clearWatch === void 0 || window5.navigator.geolocation.watchPosition === void 0) {
          return emitNotSupportedError2(observer);
        }
        const watchId = window5.navigator.geolocation.watchPosition((position) => observer.next(position), (err) => observer.error(err), options);
        return () => window5.navigator.geolocation.clearWatch(watchId);
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/intersections.js
var createIntersections;
var init_intersections = __esm({
  "node_modules/subscribable-things/build/es2019/factories/intersections.js"() {
    createIntersections = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return (htmlElement, options) => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.IntersectionObserver === void 0) {
          return emitNotSupportedError2(observer);
        }
        const intersectionObserverObserver = new window5.IntersectionObserver((entries) => observer.next(entries), options);
        try {
          intersectionObserverObserver.observe(htmlElement);
        } catch (err) {
          observer.error(err);
        }
        return () => intersectionObserverObserver.disconnect();
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/map-subscribable-thing.js
var createMapSubscribableThing;
var init_map_subscribable_thing = __esm({
  "node_modules/subscribable-things/build/es2019/factories/map-subscribable-thing.js"() {
    createMapSubscribableThing = (wrapSubscribeFunction2) => (subscribableThing, map2) => wrapSubscribeFunction2((observer) => subscribableThing({ ...observer, next: (value) => observer.next(map2(value)) }));
  }
});

// node_modules/subscribable-things/build/es2019/factories/media-devices.js
var createMediaDevices;
var init_media_devices = __esm({
  "node_modules/subscribable-things/build/es2019/factories/media-devices.js"() {
    createMediaDevices = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return () => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.navigator === void 0 || window5.navigator.mediaDevices === void 0 || window5.navigator.mediaDevices.enumerateDevices === void 0) {
          return emitNotSupportedError2(observer);
        }
        let isActive = true;
        const enumerateDevices = () => {
          window5.navigator.mediaDevices.enumerateDevices().then((mediaDevices2) => {
            if (isActive) {
              observer.next(mediaDevices2);
            }
          }, (err) => {
            if (isActive) {
              unsubscribe();
              observer.error(err);
            }
          });
        };
        const unsubscribe = () => {
          isActive = false;
          window5.navigator.mediaDevices.removeEventListener("devicechange", enumerateDevices);
        };
        enumerateDevices();
        window5.navigator.mediaDevices.addEventListener("devicechange", enumerateDevices);
        return unsubscribe;
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/media-query-match.js
var createMediaQueryMatch;
var init_media_query_match = __esm({
  "node_modules/subscribable-things/build/es2019/factories/media-query-match.js"() {
    createMediaQueryMatch = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return (mediaQueryString) => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.matchMedia === void 0) {
          return emitNotSupportedError2(observer);
        }
        const mediaQueryList = window5.matchMedia(mediaQueryString);
        observer.next(mediaQueryList.matches);
        mediaQueryList.onchange = () => observer.next(mediaQueryList.matches);
        return () => {
          mediaQueryList.onchange = null;
        };
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/metrics.js
var createMetrics;
var init_metrics = __esm({
  "node_modules/subscribable-things/build/es2019/factories/metrics.js"() {
    createMetrics = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return (options) => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.PerformanceObserver === void 0) {
          return emitNotSupportedError2(observer);
        }
        const performanceObserver = new window5.PerformanceObserver((entryList) => observer.next(entryList.getEntries()));
        try {
          performanceObserver.observe(options);
        } catch (err) {
          observer.error(err);
        }
        return () => performanceObserver.disconnect();
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/midi-inputs.js
var createMidiInputs;
var init_midi_inputs = __esm({
  "node_modules/subscribable-things/build/es2019/factories/midi-inputs.js"() {
    createMidiInputs = (wrapSubscribeFunction2) => {
      return (midiAccess) => wrapSubscribeFunction2((observer) => {
        let midiInputs2 = Array.from(midiAccess.inputs.values());
        const emitMidiInputs = () => {
          const midiAccessInputs = midiAccess.inputs;
          if (midiInputs2.length !== midiAccessInputs.size || midiInputs2.some(({ id }) => !midiAccessInputs.has(id))) {
            midiInputs2 = Array.from(midiAccessInputs.values());
            observer.next(midiInputs2);
          }
        };
        observer.next(midiInputs2);
        midiAccess.addEventListener("statechange", emitMidiInputs);
        return () => midiAccess.removeEventListener("statechange", emitMidiInputs);
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/midi-outputs.js
var createMidiOutputs;
var init_midi_outputs = __esm({
  "node_modules/subscribable-things/build/es2019/factories/midi-outputs.js"() {
    createMidiOutputs = (wrapSubscribeFunction2) => {
      return (midiAccess) => wrapSubscribeFunction2((observer) => {
        let midiOutputs2 = Array.from(midiAccess.outputs.values());
        const emitMidiOutputs = () => {
          const midiAccessOutputs = midiAccess.outputs;
          if (midiOutputs2.length !== midiAccessOutputs.size || midiOutputs2.some(({ id }) => !midiAccessOutputs.has(id))) {
            midiOutputs2 = Array.from(midiAccessOutputs.values());
            observer.next(midiOutputs2);
          }
        };
        observer.next(midiOutputs2);
        midiAccess.addEventListener("statechange", emitMidiOutputs);
        return () => midiAccess.removeEventListener("statechange", emitMidiOutputs);
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/mutations.js
var createMutations;
var init_mutations = __esm({
  "node_modules/subscribable-things/build/es2019/factories/mutations.js"() {
    createMutations = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return (htmlElement, options) => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.MutationObserver === void 0) {
          return emitNotSupportedError2(observer);
        }
        const mutationObserver = new window5.MutationObserver((records) => observer.next(records));
        try {
          mutationObserver.observe(htmlElement, options);
        } catch (err) {
          observer.error(err);
        }
        return () => mutationObserver.disconnect();
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/on.js
var createOn;
var init_on = __esm({
  "node_modules/subscribable-things/build/es2019/factories/on.js"() {
    createOn = (wrapSubscribeFunction2) => {
      return (target, type, options) => wrapSubscribeFunction2((observer) => {
        const listener = (event) => observer.next(event);
        target.addEventListener(type, listener, options);
        return () => target.removeEventListener(type, listener, options);
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/online.js
var createOnline;
var init_online = __esm({
  "node_modules/subscribable-things/build/es2019/factories/online.js"() {
    createOnline = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return () => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.navigator === void 0 || window5.navigator.onLine === void 0) {
          return emitNotSupportedError2(observer);
        }
        const emitFalse = () => observer.next(false);
        const emitTrue = () => observer.next(true);
        window5.addEventListener("offline", emitFalse);
        window5.addEventListener("online", emitTrue);
        observer.next(window5.navigator.onLine);
        return () => {
          window5.removeEventListener("offline", emitFalse);
          window5.removeEventListener("online", emitTrue);
        };
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/permission-state.js
var createPermissionState;
var init_permission_state = __esm({
  "node_modules/subscribable-things/build/es2019/factories/permission-state.js"() {
    createPermissionState = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return (permissionDescriptor) => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.navigator === void 0 || window5.navigator.permissions === void 0 || window5.navigator.permissions.query === void 0) {
          return emitNotSupportedError2(observer);
        }
        let isActive = true;
        let unsubscribe = () => {
          isActive = false;
        };
        window5.navigator.permissions.query(permissionDescriptor).then((permissionStatus) => {
          if (isActive) {
            observer.next(permissionStatus.state);
          }
          if (isActive) {
            permissionStatus.onchange = () => observer.next(permissionStatus.state);
            unsubscribe = () => {
              permissionStatus.onchange = null;
            };
          }
        }, (err) => {
          if (isActive) {
            observer.error(err);
          }
        });
        return () => unsubscribe();
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/prepend-subscribable-thing.js
var createPrependSubscribableThing;
var init_prepend_subscribable_thing = __esm({
  "node_modules/subscribable-things/build/es2019/factories/prepend-subscribable-thing.js"() {
    createPrependSubscribableThing = (wrapSubscribeFunction2) => (subscribableThing, prependedValue) => wrapSubscribeFunction2((observer) => {
      observer.next(prependedValue);
      return subscribableThing(observer);
    });
  }
});

// node_modules/subscribable-things/build/es2019/factories/reports.js
var createReports;
var init_reports = __esm({
  "node_modules/subscribable-things/build/es2019/factories/reports.js"() {
    createReports = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return (options) => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.ReportingObserver === void 0) {
          return emitNotSupportedError2(observer);
        }
        const reportingObserver = new window5.ReportingObserver((reportList) => observer.next(reportList), options);
        reportingObserver.observe();
        return () => reportingObserver.disconnect();
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/resizes.js
var createResizes;
var init_resizes = __esm({
  "node_modules/subscribable-things/build/es2019/factories/resizes.js"() {
    createResizes = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return (htmlElement, options) => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.ResizeObserver === void 0) {
          return emitNotSupportedError2(observer);
        }
        const resizeObserver = new window5.ResizeObserver((entries) => observer.next(entries));
        try {
          resizeObserver.observe(htmlElement, options);
        } catch (err) {
          observer.error(err);
        }
        return () => resizeObserver.disconnect();
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/unhandled-rejection.js
var createUnhandledRejection;
var init_unhandled_rejection = __esm({
  "node_modules/subscribable-things/build/es2019/factories/unhandled-rejection.js"() {
    createUnhandledRejection = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return (coolingOffPeriod) => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.clearInterval === void 0 || window5.setInterval === void 0) {
          return emitNotSupportedError2(observer);
        }
        const possiblyUnhandledRejections = /* @__PURE__ */ new Map();
        let intervalId = null;
        const deletePossiblyUnhandledRejection = ({ promise: promise2 }) => possiblyUnhandledRejections.delete(promise2);
        const emitUnhandledRejection = () => {
          const latestTimestampToEmit = Date.now() - coolingOffPeriod;
          possiblyUnhandledRejections.forEach(({ reason, timestamp }, promise2) => {
            if (timestamp > latestTimestampToEmit) {
              return;
            }
            possiblyUnhandledRejections.delete(promise2);
            observer.next(reason);
          });
          if (intervalId !== null && possiblyUnhandledRejections.size === 0) {
            window5.clearInterval(intervalId);
            intervalId = null;
          }
        };
        const registerPossiblyUnhandledRejection = (event) => {
          event.preventDefault();
          possiblyUnhandledRejections.set(event.promise, {
            reason: event.reason,
            timestamp: Date.now()
          });
          if (intervalId === null) {
            intervalId = window5.setInterval(emitUnhandledRejection, coolingOffPeriod / 2);
          }
        };
        window5.addEventListener("rejectionhandled", deletePossiblyUnhandledRejection);
        window5.addEventListener("unhandledrejection", registerPossiblyUnhandledRejection);
        return () => {
          if (intervalId !== null) {
            window5.clearInterval(intervalId);
          }
          window5.removeEventListener("rejectionhandled", deletePossiblyUnhandledRejection);
          window5.removeEventListener("unhandledrejection", registerPossiblyUnhandledRejection);
        };
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/video-frame.js
var createVideoFrame;
var init_video_frame = __esm({
  "node_modules/subscribable-things/build/es2019/factories/video-frame.js"() {
    createVideoFrame = (emitNotSupportedError2, wrapSubscribeFunction2) => {
      return (videoElement) => wrapSubscribeFunction2((observer) => {
        if (videoElement.cancelVideoFrameCallback === void 0 || videoElement.requestVideoFrameCallback === void 0) {
          return emitNotSupportedError2(observer);
        }
        let videoFrameHandle = videoElement.requestVideoFrameCallback(function videoFrameCallback(now, metadata) {
          videoFrameHandle = videoElement.requestVideoFrameCallback(videoFrameCallback);
          observer.next({ ...metadata, now });
        });
        return () => videoElement.cancelVideoFrameCallback(videoFrameHandle);
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/wake-lock.js
var createWakeLock;
var init_wake_lock = __esm({
  "node_modules/subscribable-things/build/es2019/factories/wake-lock.js"() {
    createWakeLock = (emitNotSupportedError2, window5, wrapSubscribeFunction2) => {
      return (type) => wrapSubscribeFunction2((observer) => {
        if (window5 === null || window5.navigator === void 0 || window5.navigator.wakeLock === void 0) {
          return emitNotSupportedError2(observer);
        }
        const releaseWakeLock = (wakeLockSentinel) => wakeLockSentinel.release().catch(() => {
        });
        const removeReleaseEventListener = (wakeLockSentinel) => {
          wakeLockSentinel.onrelease = null;
        };
        let isActive = true;
        const unsubscribeWhileRequesting = () => {
          isActive = false;
        };
        let unsubscribe = unsubscribeWhileRequesting;
        const requestWakeLock = () => window5.navigator.wakeLock.request(type).then((wakeLockSentinel) => {
          if (isActive) {
            observer.next(true);
          }
          if (isActive) {
            wakeLockSentinel.onrelease = () => {
              observer.next(false);
              unsubscribe = unsubscribeWhileRequesting;
              removeReleaseEventListener(wakeLockSentinel);
              requestWakeLock();
            };
            unsubscribe = () => {
              removeReleaseEventListener(wakeLockSentinel);
              releaseWakeLock(wakeLockSentinel);
            };
          } else {
            releaseWakeLock(wakeLockSentinel);
          }
        }, (err) => {
          if (isActive) {
            observer.error(err);
          }
        });
        requestWakeLock();
        return () => unsubscribe();
      });
    };
  }
});

// node_modules/subscribable-things/build/es2019/factories/window.js
var createWindow;
var init_window = __esm({
  "node_modules/subscribable-things/build/es2019/factories/window.js"() {
    createWindow = () => typeof window === "undefined" ? null : window;
  }
});

// node_modules/subscribable-things/build/es2019/factories/wrap-subscribe-function.js
var createWrapSubscribeFunction;
var init_wrap_subscribe_function = __esm({
  "node_modules/subscribable-things/build/es2019/factories/wrap-subscribe-function.js"() {
    createWrapSubscribeFunction = (patch2, toObserver2) => {
      const emptyFunction = () => {
      };
      const isNextFunction = (args) => typeof args[0] === "function";
      return (innerSubscribe) => {
        const subscribe = (...args) => {
          const unsubscribe = innerSubscribe(isNextFunction(args) ? toObserver2({ next: args[0] }) : toObserver2(...args));
          if (unsubscribe !== void 0) {
            return unsubscribe;
          }
          return emptyFunction;
        };
        subscribe[Symbol.observable] = () => ({
          subscribe: (...args) => ({ unsubscribe: subscribe(...args) })
        });
        return patch2(subscribe);
      };
    };
  }
});

// node_modules/subscribable-things/build/es2019/functions/emit-not-supported-error.js
var emitNotSupportedError;
var init_emit_not_supported_error = __esm({
  "node_modules/subscribable-things/build/es2019/functions/emit-not-supported-error.js"() {
    emitNotSupportedError = (observer) => {
      observer.error(new Error("The required browser API seems to be not supported."));
      return () => {
      };
    };
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/html-video-element.js
var init_html_video_element = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/html-video-element.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/midi-access.js
var init_midi_access = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/midi-access.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/midi-connection-event.js
var init_midi_connection_event = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/midi-connection-event.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/midi-input.js
var init_midi_input = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/midi-input.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/midi-input-event-map.js
var init_midi_input_event_map = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/midi-input-event-map.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/midi-message-event.js
var init_midi_message_event = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/midi-message-event.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/midi-output.js
var init_midi_output = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/midi-output.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/midi-output-event-map.js
var init_midi_output_event_map = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/midi-output-event-map.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/midi-port.js
var init_midi_port = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/midi-port.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/report.js
var init_report = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/report.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/report-body.js
var init_report_body = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/report-body.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/reporting-observer.js
var init_reporting_observer = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/reporting-observer.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/reporting-observer-options.js
var init_reporting_observer_options = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/reporting-observer-options.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/resize-observer.js
var init_resize_observer = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/resize-observer.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/resize-observer-entry.js
var init_resize_observer_entry = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/resize-observer-entry.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/resize-observer-options.js
var init_resize_observer_options = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/resize-observer-options.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/resize-observer-size.js
var init_resize_observer_size = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/resize-observer-size.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/video-frame-metadata.js
var init_video_frame_metadata = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/video-frame-metadata.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/wake-lock.js
var init_wake_lock2 = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/wake-lock.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/wake-lock-sentinel.js
var init_wake_lock_sentinel = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/wake-lock-sentinel.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/wake-lock-sentinel-event-map.js
var init_wake_lock_sentinel_event_map = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/wake-lock-sentinel-event-map.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/interfaces/index.js
var init_interfaces3 = __esm({
  "node_modules/subscribable-things/build/es2019/interfaces/index.js"() {
    init_html_video_element();
    init_midi_access();
    init_midi_connection_event();
    init_midi_input();
    init_midi_input_event_map();
    init_midi_message_event();
    init_midi_output();
    init_midi_output_event_map();
    init_midi_port();
    init_report();
    init_report_body();
    init_reporting_observer();
    init_reporting_observer_options();
    init_resize_observer();
    init_resize_observer_entry();
    init_resize_observer_options();
    init_resize_observer_size();
    init_video_frame_metadata();
    init_wake_lock2();
    init_wake_lock_sentinel();
    init_wake_lock_sentinel_event_map();
  }
});

// node_modules/subscribable-things/build/es2019/types/animation-frame-factory.js
var init_animation_frame_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/animation-frame-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/animation-frame-function.js
var init_animation_frame_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/animation-frame-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/emit-not-supported-error-function.js
var init_emit_not_supported_error_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/emit-not-supported-error-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/event-handler.js
var init_event_handler = __esm({
  "node_modules/subscribable-things/build/es2019/types/event-handler.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/event-target-with-property-handler.js
var init_event_target_with_property_handler = __esm({
  "node_modules/subscribable-things/build/es2019/types/event-target-with-property-handler.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/event-type.js
var init_event_type = __esm({
  "node_modules/subscribable-things/build/es2019/types/event-type.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/flexible-subscribe-function.js
var init_flexible_subscribe_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/flexible-subscribe-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/intersections-factory.js
var init_intersections_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/intersections-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/intersections-function.js
var init_intersections_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/intersections-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/media-devices-factory.js
var init_media_devices_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/media-devices-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/media-devices-function.js
var init_media_devices_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/media-devices-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/media-query-match-factory.js
var init_media_query_match_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/media-query-match-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/media-query-match-function.js
var init_media_query_match_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/media-query-match-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/metrics-factory.js
var init_metrics_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/metrics-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/metrics-function.js
var init_metrics_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/metrics-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/midi-connection-event-handler.js
var init_midi_connection_event_handler = __esm({
  "node_modules/subscribable-things/build/es2019/types/midi-connection-event-handler.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/midi-inputs-factory.js
var init_midi_inputs_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/midi-inputs-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/midi-inputs-function.js
var init_midi_inputs_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/midi-inputs-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/midi-message-event-handler.js
var init_midi_message_event_handler = __esm({
  "node_modules/subscribable-things/build/es2019/types/midi-message-event-handler.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/midi-outputs-factory.js
var init_midi_outputs_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/midi-outputs-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/midi-outputs-function.js
var init_midi_outputs_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/midi-outputs-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/midi-port-connection-state.js
var init_midi_port_connection_state = __esm({
  "node_modules/subscribable-things/build/es2019/types/midi-port-connection-state.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/midi-port-device-state.js
var init_midi_port_device_state = __esm({
  "node_modules/subscribable-things/build/es2019/types/midi-port-device-state.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/midi-port-type.js
var init_midi_port_type = __esm({
  "node_modules/subscribable-things/build/es2019/types/midi-port-type.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/mutations-factory.js
var init_mutations_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/mutations-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/mutations-function.js
var init_mutations_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/mutations-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/observer-parameters.js
var init_observer_parameters = __esm({
  "node_modules/subscribable-things/build/es2019/types/observer-parameters.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/online-factory.js
var init_online_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/online-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/online-function.js
var init_online_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/online-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/on-factory.js
var init_on_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/on-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/on-function.js
var init_on_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/on-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/optional-unsubscribe-function.js
var init_optional_unsubscribe_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/optional-unsubscribe-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/permission-state-factory.js
var init_permission_state_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/permission-state-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/permission-state-function.js
var init_permission_state_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/permission-state-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/release-event-handler.js
var init_release_event_handler = __esm({
  "node_modules/subscribable-things/build/es2019/types/release-event-handler.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/reports-factory.js
var init_reports_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/reports-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/reports-function.js
var init_reports_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/reports-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/resize-observer-box-options.js
var init_resize_observer_box_options = __esm({
  "node_modules/subscribable-things/build/es2019/types/resize-observer-box-options.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/resizes-factory.js
var init_resizes_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/resizes-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/resizes-function.js
var init_resizes_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/resizes-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/subscribable-thing.js
var init_subscribable_thing = __esm({
  "node_modules/subscribable-things/build/es2019/types/subscribable-thing.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/subscribe-function.js
var init_subscribe_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/subscribe-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/unhandled-rejection-factory.js
var init_unhandled_rejection_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/unhandled-rejection-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/unhandled-rejection-function.js
var init_unhandled_rejection_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/unhandled-rejection-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/unsubscribe-function.js
var init_unsubscribe_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/unsubscribe-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/video-frame-factory.js
var init_video_frame_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/video-frame-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/video-frame-function.js
var init_video_frame_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/video-frame-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/video-frame-request-callback.js
var init_video_frame_request_callback = __esm({
  "node_modules/subscribable-things/build/es2019/types/video-frame-request-callback.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/wake-lock-factory.js
var init_wake_lock_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/wake-lock-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/wake-lock-function.js
var init_wake_lock_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/wake-lock-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/wake-lock-type.js
var init_wake_lock_type = __esm({
  "node_modules/subscribable-things/build/es2019/types/wake-lock-type.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/window.js
var init_window2 = __esm({
  "node_modules/subscribable-things/build/es2019/types/window.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/window-factory.js
var init_window_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/window-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/wrap-subscribe-function-factory.js
var init_wrap_subscribe_function_factory = __esm({
  "node_modules/subscribable-things/build/es2019/types/wrap-subscribe-function-factory.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/wrap-subscribe-function-function.js
var init_wrap_subscribe_function_function = __esm({
  "node_modules/subscribable-things/build/es2019/types/wrap-subscribe-function-function.js"() {
  }
});

// node_modules/subscribable-things/build/es2019/types/index.js
var init_types5 = __esm({
  "node_modules/subscribable-things/build/es2019/types/index.js"() {
    init_animation_frame_factory();
    init_animation_frame_function();
    init_emit_not_supported_error_function();
    init_event_handler();
    init_event_target_with_property_handler();
    init_event_type();
    init_flexible_subscribe_function();
    init_intersections_factory();
    init_intersections_function();
    init_media_devices_factory();
    init_media_devices_function();
    init_media_query_match_factory();
    init_media_query_match_function();
    init_metrics_factory();
    init_metrics_function();
    init_midi_connection_event_handler();
    init_midi_inputs_factory();
    init_midi_inputs_function();
    init_midi_message_event_handler();
    init_midi_outputs_factory();
    init_midi_outputs_function();
    init_midi_port_connection_state();
    init_midi_port_device_state();
    init_midi_port_type();
    init_mutations_factory();
    init_mutations_function();
    init_observer_parameters();
    init_online_factory();
    init_online_function();
    init_on_factory();
    init_on_function();
    init_optional_unsubscribe_function();
    init_permission_state_factory();
    init_permission_state_function();
    init_release_event_handler();
    init_reports_factory();
    init_reports_function();
    init_resize_observer_box_options();
    init_resizes_factory();
    init_resizes_function();
    init_subscribable_thing();
    init_subscribe_function();
    init_unhandled_rejection_factory();
    init_unhandled_rejection_function();
    init_unsubscribe_function();
    init_video_frame_factory();
    init_video_frame_function();
    init_video_frame_request_callback();
    init_wake_lock_factory();
    init_wake_lock_function();
    init_wake_lock_type();
    init_window2();
    init_window_factory();
    init_wrap_subscribe_function_factory();
    init_wrap_subscribe_function_function();
  }
});

// node_modules/subscribable-things/build/es2019/module.js
var window2, wrapSubscribeFunction, animationFrame, mutations, mapSubscribableThing, prependSubscribableThing, attribute, geolocation, intersections, mediaDevices, mediaQueryMatch, metrics, midiInputs, midiOutputs, on, online, permissionState, reports, resizes, unhandledRejection, videoFrame, wakeLock;
var init_module6 = __esm({
  "node_modules/subscribable-things/build/es2019/module.js"() {
    init_esm();
    init_animation_frame();
    init_attribute();
    init_geolocation();
    init_intersections();
    init_map_subscribable_thing();
    init_media_devices();
    init_media_query_match();
    init_metrics();
    init_midi_inputs();
    init_midi_outputs();
    init_mutations();
    init_on();
    init_online();
    init_permission_state();
    init_prepend_subscribable_thing();
    init_reports();
    init_resizes();
    init_unhandled_rejection();
    init_video_frame();
    init_wake_lock();
    init_window();
    init_wrap_subscribe_function();
    init_emit_not_supported_error();
    init_interfaces3();
    init_types5();
    window2 = createWindow();
    wrapSubscribeFunction = createWrapSubscribeFunction(patch, toObserver);
    animationFrame = createAnimationFrame(emitNotSupportedError, window2, wrapSubscribeFunction);
    mutations = createMutations(emitNotSupportedError, window2, wrapSubscribeFunction);
    mapSubscribableThing = createMapSubscribableThing(wrapSubscribeFunction);
    prependSubscribableThing = createPrependSubscribableThing(wrapSubscribeFunction);
    attribute = createAttribute(mapSubscribableThing, mutations, prependSubscribableThing);
    geolocation = createGeolocation(emitNotSupportedError, window2, wrapSubscribeFunction);
    intersections = createIntersections(emitNotSupportedError, window2, wrapSubscribeFunction);
    mediaDevices = createMediaDevices(emitNotSupportedError, window2, wrapSubscribeFunction);
    mediaQueryMatch = createMediaQueryMatch(emitNotSupportedError, window2, wrapSubscribeFunction);
    metrics = createMetrics(emitNotSupportedError, window2, wrapSubscribeFunction);
    midiInputs = createMidiInputs(wrapSubscribeFunction);
    midiOutputs = createMidiOutputs(wrapSubscribeFunction);
    on = createOn(wrapSubscribeFunction);
    online = createOnline(emitNotSupportedError, window2, wrapSubscribeFunction);
    permissionState = createPermissionState(emitNotSupportedError, window2, wrapSubscribeFunction);
    reports = createReports(emitNotSupportedError, window2, wrapSubscribeFunction);
    resizes = createResizes(emitNotSupportedError, window2, wrapSubscribeFunction);
    unhandledRejection = createUnhandledRejection(emitNotSupportedError, window2, wrapSubscribeFunction);
    videoFrame = createVideoFrame(emitNotSupportedError, wrapSubscribeFunction);
    wakeLock = createWakeLock(emitNotSupportedError, window2, wrapSubscribeFunction);
  }
});

// node_modules/dashify/index.js
var require_dashify = __commonJS({
  "node_modules/dashify/index.js"(exports, module) {
    "use strict";
    module.exports = (str, options) => {
      if (typeof str !== "string") throw new TypeError("expected a string");
      return str.trim().replace(/([a-z])([A-Z])/g, "$1-$2").replace(/\W/g, (m) => /[-]/.test(m) ? m : "-").replace(/^-+|-+$/g, "").replace(/-{2,}/g, (m) => options && options.condense ? "-" : m).toLowerCase();
    };
  }
});

// node_modules/indefinite-article/indefinite-article.js
var require_indefinite_article = __commonJS({
  "node_modules/indefinite-article/indefinite-article.js"(exports, module) {
    var indefiniteArticle2 = function(phrase) {
      var i, word;
      var match = /\w+/.exec(phrase);
      if (match)
        word = match[0];
      else
        return "an";
      var l_word = word.toLowerCase();
      var alt_cases = ["honest", "hour", "hono"];
      for (i in alt_cases) {
        if (l_word.indexOf(alt_cases[i]) == 0)
          return "an";
      }
      if (l_word.length == 1) {
        if ("aedhilmnorsx".indexOf(l_word) >= 0)
          return "an";
        else
          return "a";
      }
      if (word.match(/(?!FJO|[HLMNS]Y.|RY[EO]|SQU|(F[LR]?|[HL]|MN?|N|RH?|S[CHKLMNPTVW]?|X(YL)?)[AEIOU])[FHLMNRSX][A-Z]/)) {
        return "an";
      }
      var regexes = [/^e[uw]/, /^onc?e\b/, /^uni([^nmd]|mo)/, /^u[bcfhjkqrst][aeiou]/];
      for (i = 0; i < regexes.length; i++) {
        if (l_word.match(regexes[i]))
          return "a";
      }
      if (word.match(/^U[NK][AIEO]/)) {
        return "a";
      } else if (word == word.toUpperCase()) {
        if ("aedhilmnorsx".indexOf(l_word[0]) >= 0)
          return "an";
        else
          return "a";
      }
      if ("aeiou".indexOf(l_word[0]) >= 0)
        return "an";
      if (l_word.match(/^y(b[lor]|cl[ea]|fere|gg|p[ios]|rou|tt)/))
        return "an";
      return "a";
    };
    if (typeof module !== "undefined" && typeof module.exports !== "undefined") {
      module.exports = indefiniteArticle2;
    } else {
      window.indefiniteArticle = indefiniteArticle2;
    }
  }
});

// node_modules/compilerr/build/es2019/interfaces/augmented-error.js
var init_augmented_error = __esm({
  "node_modules/compilerr/build/es2019/interfaces/augmented-error.js"() {
  }
});

// node_modules/compilerr/build/es2019/interfaces/aws-error.js
var init_aws_error = __esm({
  "node_modules/compilerr/build/es2019/interfaces/aws-error.js"() {
  }
});

// node_modules/compilerr/build/es2019/interfaces/error-template.js
var init_error_template = __esm({
  "node_modules/compilerr/build/es2019/interfaces/error-template.js"() {
  }
});

// node_modules/compilerr/build/es2019/interfaces/param-object.js
var init_param_object = __esm({
  "node_modules/compilerr/build/es2019/interfaces/param-object.js"() {
  }
});

// node_modules/compilerr/build/es2019/interfaces/variable.js
var init_variable = __esm({
  "node_modules/compilerr/build/es2019/interfaces/variable.js"() {
  }
});

// node_modules/compilerr/build/es2019/interfaces/index.js
var init_interfaces4 = __esm({
  "node_modules/compilerr/build/es2019/interfaces/index.js"() {
    init_augmented_error();
    init_aws_error();
    init_error_template();
    init_param_object();
    init_variable();
  }
});

// node_modules/compilerr/build/es2019/types/render-function.js
var init_render_function = __esm({
  "node_modules/compilerr/build/es2019/types/render-function.js"() {
  }
});

// node_modules/compilerr/build/es2019/types/index.js
var init_types6 = __esm({
  "node_modules/compilerr/build/es2019/types/index.js"() {
    init_render_function();
  }
});

// node_modules/compilerr/build/es2019/module.js
var import_dashify, import_indefinite_article, applyModifiers, buildRegex, preRenderString, compile;
var init_module7 = __esm({
  "node_modules/compilerr/build/es2019/module.js"() {
    import_dashify = __toESM(require_dashify());
    import_indefinite_article = __toESM(require_indefinite_article());
    init_interfaces4();
    init_types6();
    applyModifiers = (name, modifiers) => {
      if (modifiers === void 0) {
        return name;
      }
      return modifiers.reduce((modifiedName, modifier) => {
        if (modifier === "capitalize") {
          const head = modifiedName.charAt(0).toUpperCase();
          const tail = modifiedName.slice(1);
          return `${head}${tail}`;
        }
        if (modifier === "dashify") {
          return (0, import_dashify.default)(modifiedName);
        }
        if (modifier === "prependIndefiniteArticle") {
          return `${(0, import_indefinite_article.default)(modifiedName)} ${modifiedName}`;
        }
        return modifiedName;
      }, name);
    };
    buildRegex = (variable) => {
      const expression = variable.name + variable.modifiers.map((modifier) => `\\.${modifier}\\(\\)`).join("");
      return new RegExp(`\\$\\{${expression}}`, "g");
    };
    preRenderString = (string4, parameters) => {
      const expressionRegex = /\${([^.}]+)((\.[^(]+\(\))*)}/g;
      const variables = [];
      let expressionResult = expressionRegex.exec(string4);
      while (expressionResult !== null) {
        const variable = {
          modifiers: [],
          name: expressionResult[1]
        };
        if (expressionResult[3] !== void 0) {
          const modifiersRegex = /\.[^(]+\(\)/g;
          let modifiersRegexResult = modifiersRegex.exec(expressionResult[2]);
          while (modifiersRegexResult !== null) {
            variable.modifiers.push(modifiersRegexResult[0].slice(1, -2));
            modifiersRegexResult = modifiersRegex.exec(expressionResult[2]);
          }
        }
        variables.push(variable);
        expressionResult = expressionRegex.exec(string4);
      }
      const preRenderedParts = variables.reduce((parts, variable) => parts.map((part) => {
        if (typeof part === "string") {
          return part.split(buildRegex(variable)).reduce((prts, prt, index) => {
            if (index === 0) {
              return [prt];
            }
            if (variable.name in parameters) {
              return [...prts, applyModifiers(parameters[variable.name], variable.modifiers), prt];
            }
            return [...prts, (prmtrs) => applyModifiers(prmtrs[variable.name], variable.modifiers), prt];
          }, []);
        }
        return [part];
      }).reduce((prts, part) => [...prts, ...part], []), [string4]);
      return (missingParameters) => preRenderedParts.reduce((renderedParts, preRenderedPart) => {
        if (typeof preRenderedPart === "string") {
          return [...renderedParts, preRenderedPart];
        }
        return [...renderedParts, preRenderedPart(missingParameters)];
      }, []).join("");
    };
    compile = (template, knownParameters = {}) => {
      const renderCode = template.code === void 0 ? void 0 : preRenderString(template.code, knownParameters);
      const renderMessage = template.message === void 0 ? void 0 : preRenderString(template.message, knownParameters);
      function render(causeOrMissingParameters = {}, optionalCause) {
        const hasNoOptionalCause = optionalCause === void 0 && (causeOrMissingParameters instanceof Error || causeOrMissingParameters.code !== void 0 && causeOrMissingParameters.code.slice(-9) === "Exception");
        const { cause, missingParameters } = hasNoOptionalCause ? {
          cause: causeOrMissingParameters,
          missingParameters: {}
        } : {
          cause: optionalCause,
          missingParameters: causeOrMissingParameters
        };
        const err = renderMessage === void 0 ? new Error() : new Error(renderMessage(missingParameters));
        if (cause !== null) {
          err.cause = cause;
        }
        if (renderCode !== void 0) {
          err.code = renderCode(missingParameters);
        }
        if (template.status !== void 0) {
          err.status = template.status;
        }
        return err;
      }
      return render;
    };
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/helpers/error-renderers.js
var JSON_RPC_ERROR_CODES, renderMethodNotFoundError, renderMissingResponseError, renderUnexpectedResultError, renderUnknownPortIdError;
var init_error_renderers = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/helpers/error-renderers.js"() {
    init_module7();
    JSON_RPC_ERROR_CODES = { INTERNAL_ERROR: -32603, INVALID_PARAMS: -32602, METHOD_NOT_FOUND: -32601 };
    renderMethodNotFoundError = compile({
      message: 'The requested method called "${method}" is not supported.',
      status: JSON_RPC_ERROR_CODES.METHOD_NOT_FOUND
    });
    renderMissingResponseError = compile({
      message: 'The handler of the method called "${method}" returned no required result.',
      status: JSON_RPC_ERROR_CODES.INTERNAL_ERROR
    });
    renderUnexpectedResultError = compile({
      message: 'The handler of the method called "${method}" returned an unexpected result.',
      status: JSON_RPC_ERROR_CODES.INTERNAL_ERROR
    });
    renderUnknownPortIdError = compile({
      message: 'The specified parameter called "portId" with the given value "${portId}" does not identify a port connected to this worker.',
      status: JSON_RPC_ERROR_CODES.INVALID_PARAMS
    });
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/helpers/create-message-handler.js
var init_create_message_handler = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/helpers/create-message-handler.js"() {
    init_error_renderers();
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/helpers/is-supporting-transferables.js
var init_is_supporting_transferables = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/helpers/is-supporting-transferables.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/helpers/extend-worker-implementation.js
var init_extend_worker_implementation = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/helpers/extend-worker-implementation.js"() {
    init_module5();
    init_error_renderers();
    init_is_supporting_transferables();
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/broker-event.js
var init_broker_event = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/broker-event.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/broker-message.js
var init_broker_message = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/broker-message.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/default-worker-definition.js
var init_default_worker_definition = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/default-worker-definition.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/error.js
var init_error = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/error.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/error-notification.js
var init_error_notification = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/error-notification.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/error-response.js
var init_error_response = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/error-response.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/notification.js
var init_notification = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/notification.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/receiver.js
var init_receiver = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/receiver.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/request.js
var init_request = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/request.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/value-array.js
var init_value_array = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/value-array.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/value-map.js
var init_value_map = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/value-map.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/worker-definition.js
var init_worker_definition = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/worker-definition.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/worker-error-message.js
var init_worker_error_message = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/worker-error-message.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/worker-result-message.js
var init_worker_result_message = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/worker-result-message.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/index.js
var init_interfaces5 = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/interfaces/index.js"() {
    init_broker_event();
    init_broker_message();
    init_default_worker_definition();
    init_error();
    init_error_notification();
    init_error_response();
    init_notification();
    init_receiver();
    init_request();
    init_value_array();
    init_value_map();
    init_worker_definition();
    init_worker_error_message();
    init_worker_result_message();
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/destroy-worker-function.js
var init_destroy_worker_function = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/destroy-worker-function.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/message.js
var init_message = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/message.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/message-receiver.js
var init_message_receiver = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/message-receiver.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/message-receiver-with-params.js
var init_message_receiver_with_params = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/message-receiver-with-params.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/message-receiver-without-params.js
var init_message_receiver_without_params = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/message-receiver-without-params.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/typed-array.js
var init_typed_array = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/typed-array.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/value.js
var init_value = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/value.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/value-map.js
var init_value_map2 = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/value-map.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/worker-definition.js
var init_worker_definition2 = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/worker-definition.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/worker-implementation.js
var init_worker_implementation = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/worker-implementation.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/worker-message.js
var init_worker_message = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/worker-message.js"() {
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/index.js
var init_types7 = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/types/index.js"() {
    init_destroy_worker_function();
    init_message();
    init_message_receiver();
    init_message_receiver_with_params();
    init_message_receiver_without_params();
    init_typed_array();
    init_value();
    init_value_map2();
    init_worker_definition2();
    init_worker_implementation();
    init_worker_message();
  }
});

// node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/module.js
var init_module8 = __esm({
  "node_modules/recorder-audio-worklet/node_modules/worker-factory/build/es2019/module.js"() {
    init_create_message_handler();
    init_extend_worker_implementation();
    init_is_supporting_transferables();
    init_interfaces5();
    init_types7();
  }
});

// node_modules/recorder-audio-worklet/build/es2019/factories/add-recorder-audio-worklet-module.js
var createAddRecorderAudioWorkletModule;
var init_add_recorder_audio_worklet_module = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/factories/add-recorder-audio-worklet-module.js"() {
    createAddRecorderAudioWorkletModule = (blobConstructor, urlConstructor, worklet2) => {
      return async (addAudioWorkletModule2) => {
        const blob3 = new blobConstructor([worklet2], { type: "application/javascript; charset=utf-8" });
        const url4 = urlConstructor.createObjectURL(blob3);
        try {
          await addAudioWorkletModule2(url4);
        } finally {
          urlConstructor.revokeObjectURL(url4);
        }
      };
    };
  }
});

// node_modules/recorder-audio-worklet/build/es2019/factories/listener.js
var createListener;
var init_listener = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/factories/listener.js"() {
    createListener = (ongoingRequests) => {
      return ({ data: message }) => {
        const { id } = message;
        if (id !== null) {
          const ongoingRequest = ongoingRequests.get(id);
          if (ongoingRequest !== void 0) {
            const { reject, resolve } = ongoingRequest;
            ongoingRequests.delete(id);
            if (message.error === void 0) {
              resolve(message.result);
            } else {
              reject(new Error(message.error.message));
            }
          }
        }
      };
    };
  }
});

// node_modules/recorder-audio-worklet/build/es2019/factories/post-message-factory.js
var createPostMessageFactory;
var init_post_message_factory = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/factories/post-message-factory.js"() {
    createPostMessageFactory = (generateUniqueNumber3) => {
      return (ongoingRequests, port) => {
        return (message, transferables = []) => {
          return new Promise((resolve, reject) => {
            const id = generateUniqueNumber3(ongoingRequests);
            ongoingRequests.set(id, { reject, resolve });
            port.postMessage({ id, ...message }, transferables);
          });
        };
      };
    };
  }
});

// node_modules/recorder-audio-worklet/build/es2019/factories/recorder-audio-worklet-node-factory.js
var createRecorderAudioWorkletNodeFactory;
var init_recorder_audio_worklet_node_factory = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/factories/recorder-audio-worklet-node-factory.js"() {
    createRecorderAudioWorkletNodeFactory = (createListener2, createPostMessage, on2, validateState2) => {
      return (audioWorkletNodeConstructor2, context, options = {}) => {
        const audioWorkletNode = new audioWorkletNodeConstructor2(context, "recorder-audio-worklet-processor", {
          ...options,
          channelCountMode: "explicit",
          numberOfInputs: 1,
          numberOfOutputs: 0
        });
        const ongoingRequests = /* @__PURE__ */ new Map();
        const postMessage = createPostMessage(ongoingRequests, audioWorkletNode.port);
        const unsubscribe = on2(audioWorkletNode.port, "message")(createListener2(ongoingRequests));
        audioWorkletNode.port.start();
        let state = "inactive";
        Object.defineProperties(audioWorkletNode, {
          pause: {
            get() {
              return async () => {
                validateState2(["recording"], state);
                state = "paused";
                return postMessage({
                  method: "pause"
                });
              };
            }
          },
          port: {
            get() {
              throw new Error("The port of a RecorderAudioWorkletNode can't be accessed.");
            }
          },
          record: {
            get() {
              return async (encoderPort) => {
                validateState2(["inactive"], state);
                state = "recording";
                return postMessage({
                  method: "record",
                  params: { encoderPort }
                }, [encoderPort]);
              };
            }
          },
          resume: {
            get() {
              return async () => {
                validateState2(["paused"], state);
                state = "recording";
                return postMessage({
                  method: "resume"
                });
              };
            }
          },
          stop: {
            get() {
              return async () => {
                validateState2(["paused", "recording"], state);
                state = "stopped";
                try {
                  await postMessage({ method: "stop" });
                } finally {
                  unsubscribe();
                }
              };
            }
          }
        });
        return audioWorkletNode;
      };
    };
  }
});

// node_modules/recorder-audio-worklet/build/es2019/functions/validate-state.js
var validateState;
var init_validate_state = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/functions/validate-state.js"() {
    validateState = (expectedStates, currentState) => {
      if (!expectedStates.includes(currentState)) {
        throw new Error(`Expected the state to be ${expectedStates.map((expectedState) => `"${expectedState}"`).join(" or ")} but it was "${currentState}".`);
      }
    };
  }
});

// node_modules/recorder-audio-worklet/build/es2019/worklet/worklet.js
var worklet;
var init_worklet = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/worklet/worklet.js"() {
    worklet = `(()=>{"use strict";class e extends AudioWorkletProcessor{constructor(){super(),this._encoderPort=null,this._state="inactive",this.port.onmessage=e=>{let{data:t}=e;"pause"===t.method?"active"===this._state||"recording"===this._state?(this._state="paused",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):"record"===t.method?"inactive"===this._state?(this._encoderPort=t.params.encoderPort,this._state="active",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):"resume"===t.method?"paused"===this._state?(this._state="active",this._sendAcknowledgement(t.id)):this._sendUnexpectedStateError(t.id):"stop"===t.method?"active"!==this._state&&"paused"!==this._state&&"recording"!==this._state||null===this._encoderPort?this._sendUnexpectedStateError(t.id):(this._stop(this._encoderPort),this._sendAcknowledgement(t.id)):"number"==typeof t.id&&this.port.postMessage({error:{code:-32601,message:"The requested method is not supported."},id:t.id})}}process(e){let[t]=e;if("inactive"===this._state||"paused"===this._state)return!0;if("active"===this._state){if(void 0===t)throw new Error("No channelData was received for the first input.");if(0===t.length)return!0;this._state="recording"}if("recording"===this._state&&null!==this._encoderPort){if(void 0===t)throw new Error("No channelData was received for the first input.");if(0!==t.length)return this._encoderPort.postMessage(t,t.map((e=>{let{buffer:t}=e;return t}))),!0;this._stop(this._encoderPort)}return!1}_sendAcknowledgement(e){this.port.postMessage({id:e,result:null})}_sendUnexpectedStateError(e){this.port.postMessage({error:{code:-32603,message:"The internal state does not allow to process the given message."},id:e})}_stop(e){e.postMessage([]),e.close(),this._encoderPort=null,this._state="stopped"}}e.parameterDescriptors=[],registerProcessor("recorder-audio-worklet-processor",e)})();`;
  }
});

// node_modules/recorder-audio-worklet/build/es2019/interfaces/native-recorder-audio-worklet-node.js
var init_native_recorder_audio_worklet_node = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/interfaces/native-recorder-audio-worklet-node.js"() {
  }
});

// node_modules/recorder-audio-worklet/build/es2019/interfaces/recorder-audio-worklet-node.js
var init_recorder_audio_worklet_node = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/interfaces/recorder-audio-worklet-node.js"() {
  }
});

// node_modules/recorder-audio-worklet/build/es2019/interfaces/index.js
var init_interfaces6 = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/interfaces/index.js"() {
    init_native_recorder_audio_worklet_node();
    init_recorder_audio_worklet_node();
  }
});

// node_modules/recorder-audio-worklet/build/es2019/types/any-recorder-audio-worklet-node-options.js
var init_any_recorder_audio_worklet_node_options = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/types/any-recorder-audio-worklet-node-options.js"() {
  }
});

// node_modules/recorder-audio-worklet/build/es2019/types/native-recorder-audio-worklet-node-options.js
var init_native_recorder_audio_worklet_node_options = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/types/native-recorder-audio-worklet-node-options.js"() {
  }
});

// node_modules/recorder-audio-worklet/build/es2019/types/recorder-audio-worklet-node-options.js
var init_recorder_audio_worklet_node_options = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/types/recorder-audio-worklet-node-options.js"() {
  }
});

// node_modules/recorder-audio-worklet/build/es2019/types/state.js
var init_state = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/types/state.js"() {
  }
});

// node_modules/recorder-audio-worklet/build/es2019/types/index.js
var init_types8 = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/types/index.js"() {
    init_any_recorder_audio_worklet_node_options();
    init_native_recorder_audio_worklet_node_options();
    init_recorder_audio_worklet_node_options();
    init_state();
  }
});

// node_modules/recorder-audio-worklet/build/es2019/module.js
var addRecorderAudioWorkletModule, createRecorderAudioWorkletNode;
var init_module9 = __esm({
  "node_modules/recorder-audio-worklet/build/es2019/module.js"() {
    init_module5();
    init_module6();
    init_module8();
    init_add_recorder_audio_worklet_module();
    init_listener();
    init_post_message_factory();
    init_recorder_audio_worklet_node_factory();
    init_validate_state();
    init_worklet();
    init_interfaces6();
    init_types8();
    addRecorderAudioWorkletModule = createAddRecorderAudioWorkletModule(Blob, URL, worklet);
    createRecorderAudioWorkletNode = createRecorderAudioWorkletNodeFactory(createListener, createPostMessageFactory(generateUniqueNumber2), on, validateState);
  }
});

// node_modules/automation-events/build/es2019/functions/create-extended-exponential-ramp-to-value-automation-event.js
var createExtendedExponentialRampToValueAutomationEvent;
var init_create_extended_exponential_ramp_to_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/functions/create-extended-exponential-ramp-to-value-automation-event.js"() {
    createExtendedExponentialRampToValueAutomationEvent = (value, endTime, insertTime) => {
      return { endTime, insertTime, type: "exponentialRampToValue", value };
    };
  }
});

// node_modules/automation-events/build/es2019/functions/create-extended-linear-ramp-to-value-automation-event.js
var createExtendedLinearRampToValueAutomationEvent;
var init_create_extended_linear_ramp_to_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/functions/create-extended-linear-ramp-to-value-automation-event.js"() {
    createExtendedLinearRampToValueAutomationEvent = (value, endTime, insertTime) => {
      return { endTime, insertTime, type: "linearRampToValue", value };
    };
  }
});

// node_modules/automation-events/build/es2019/functions/create-set-value-automation-event.js
var createSetValueAutomationEvent;
var init_create_set_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/functions/create-set-value-automation-event.js"() {
    createSetValueAutomationEvent = (value, startTime) => {
      return { startTime, type: "setValue", value };
    };
  }
});

// node_modules/automation-events/build/es2019/functions/create-set-value-curve-automation-event.js
var createSetValueCurveAutomationEvent;
var init_create_set_value_curve_automation_event = __esm({
  "node_modules/automation-events/build/es2019/functions/create-set-value-curve-automation-event.js"() {
    createSetValueCurveAutomationEvent = (values, startTime, duration3) => {
      return { duration: duration3, startTime, type: "setValueCurve", values };
    };
  }
});

// node_modules/automation-events/build/es2019/functions/get-target-value-at-time.js
var getTargetValueAtTime;
var init_get_target_value_at_time = __esm({
  "node_modules/automation-events/build/es2019/functions/get-target-value-at-time.js"() {
    getTargetValueAtTime = (time3, valueAtStartTime, { startTime, target, timeConstant }) => {
      return target + (valueAtStartTime - target) * Math.exp((startTime - time3) / timeConstant);
    };
  }
});

// node_modules/automation-events/build/es2019/guards/exponential-ramp-to-value-automation-event.js
var isExponentialRampToValueAutomationEvent;
var init_exponential_ramp_to_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/guards/exponential-ramp-to-value-automation-event.js"() {
    isExponentialRampToValueAutomationEvent = (automationEvent) => {
      return automationEvent.type === "exponentialRampToValue";
    };
  }
});

// node_modules/automation-events/build/es2019/guards/linear-ramp-to-value-automation-event.js
var isLinearRampToValueAutomationEvent;
var init_linear_ramp_to_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/guards/linear-ramp-to-value-automation-event.js"() {
    isLinearRampToValueAutomationEvent = (automationEvent) => {
      return automationEvent.type === "linearRampToValue";
    };
  }
});

// node_modules/automation-events/build/es2019/guards/any-ramp-to-value-automation-event.js
var isAnyRampToValueAutomationEvent;
var init_any_ramp_to_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/guards/any-ramp-to-value-automation-event.js"() {
    init_exponential_ramp_to_value_automation_event();
    init_linear_ramp_to_value_automation_event();
    isAnyRampToValueAutomationEvent = (automationEvent) => {
      return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);
    };
  }
});

// node_modules/automation-events/build/es2019/guards/set-value-automation-event.js
var isSetValueAutomationEvent;
var init_set_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/guards/set-value-automation-event.js"() {
    isSetValueAutomationEvent = (automationEvent) => {
      return automationEvent.type === "setValue";
    };
  }
});

// node_modules/automation-events/build/es2019/guards/set-value-curve-automation-event.js
var isSetValueCurveAutomationEvent;
var init_set_value_curve_automation_event = __esm({
  "node_modules/automation-events/build/es2019/guards/set-value-curve-automation-event.js"() {
    isSetValueCurveAutomationEvent = (automationEvent) => {
      return automationEvent.type === "setValueCurve";
    };
  }
});

// node_modules/automation-events/build/es2019/functions/get-value-of-automation-event-at-index-at-time.js
var getValueOfAutomationEventAtIndexAtTime;
var init_get_value_of_automation_event_at_index_at_time = __esm({
  "node_modules/automation-events/build/es2019/functions/get-value-of-automation-event-at-index-at-time.js"() {
    init_get_target_value_at_time();
    init_any_ramp_to_value_automation_event();
    init_set_value_automation_event();
    init_set_value_curve_automation_event();
    getValueOfAutomationEventAtIndexAtTime = (automationEvents, index, time3, defaultValue) => {
      const automationEvent = automationEvents[index];
      return automationEvent === void 0 ? defaultValue : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent) ? automationEvent.value : isSetValueCurveAutomationEvent(automationEvent) ? automationEvent.values[automationEvent.values.length - 1] : getTargetValueAtTime(time3, getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue), automationEvent);
    };
  }
});

// node_modules/automation-events/build/es2019/functions/get-end-time-and-value-of-previous-automation-event.js
var getEndTimeAndValueOfPreviousAutomationEvent;
var init_get_end_time_and_value_of_previous_automation_event = __esm({
  "node_modules/automation-events/build/es2019/functions/get-end-time-and-value-of-previous-automation-event.js"() {
    init_get_value_of_automation_event_at_index_at_time();
    init_any_ramp_to_value_automation_event();
    init_set_value_automation_event();
    init_set_value_curve_automation_event();
    getEndTimeAndValueOfPreviousAutomationEvent = (automationEvents, index, currentAutomationEvent, nextAutomationEvent, defaultValue) => {
      return currentAutomationEvent === void 0 ? [nextAutomationEvent.insertTime, defaultValue] : isAnyRampToValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.endTime, currentAutomationEvent.value] : isSetValueAutomationEvent(currentAutomationEvent) ? [currentAutomationEvent.startTime, currentAutomationEvent.value] : isSetValueCurveAutomationEvent(currentAutomationEvent) ? [
        currentAutomationEvent.startTime + currentAutomationEvent.duration,
        currentAutomationEvent.values[currentAutomationEvent.values.length - 1]
      ] : [
        currentAutomationEvent.startTime,
        getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)
      ];
    };
  }
});

// node_modules/automation-events/build/es2019/guards/cancel-and-hold-automation-event.js
var isCancelAndHoldAutomationEvent;
var init_cancel_and_hold_automation_event = __esm({
  "node_modules/automation-events/build/es2019/guards/cancel-and-hold-automation-event.js"() {
    isCancelAndHoldAutomationEvent = (automationEvent) => {
      return automationEvent.type === "cancelAndHold";
    };
  }
});

// node_modules/automation-events/build/es2019/guards/cancel-scheduled-values-automation-event.js
var isCancelScheduledValuesAutomationEvent;
var init_cancel_scheduled_values_automation_event = __esm({
  "node_modules/automation-events/build/es2019/guards/cancel-scheduled-values-automation-event.js"() {
    isCancelScheduledValuesAutomationEvent = (automationEvent) => {
      return automationEvent.type === "cancelScheduledValues";
    };
  }
});

// node_modules/automation-events/build/es2019/functions/get-event-time.js
var getEventTime;
var init_get_event_time = __esm({
  "node_modules/automation-events/build/es2019/functions/get-event-time.js"() {
    init_cancel_and_hold_automation_event();
    init_cancel_scheduled_values_automation_event();
    init_exponential_ramp_to_value_automation_event();
    init_linear_ramp_to_value_automation_event();
    getEventTime = (automationEvent) => {
      if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
        return automationEvent.cancelTime;
      }
      if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {
        return automationEvent.endTime;
      }
      return automationEvent.startTime;
    };
  }
});

// node_modules/automation-events/build/es2019/functions/get-exponential-ramp-value-at-time.js
var getExponentialRampValueAtTime;
var init_get_exponential_ramp_value_at_time = __esm({
  "node_modules/automation-events/build/es2019/functions/get-exponential-ramp-value-at-time.js"() {
    getExponentialRampValueAtTime = (time3, startTime, valueAtStartTime, { endTime, value }) => {
      if (valueAtStartTime === value) {
        return value;
      }
      if (0 < valueAtStartTime && 0 < value || valueAtStartTime < 0 && value < 0) {
        return valueAtStartTime * (value / valueAtStartTime) ** ((time3 - startTime) / (endTime - startTime));
      }
      return 0;
    };
  }
});

// node_modules/automation-events/build/es2019/functions/get-linear-ramp-value-at-time.js
var getLinearRampValueAtTime;
var init_get_linear_ramp_value_at_time = __esm({
  "node_modules/automation-events/build/es2019/functions/get-linear-ramp-value-at-time.js"() {
    getLinearRampValueAtTime = (time3, startTime, valueAtStartTime, { endTime, value }) => {
      return valueAtStartTime + (time3 - startTime) / (endTime - startTime) * (value - valueAtStartTime);
    };
  }
});

// node_modules/automation-events/build/es2019/functions/interpolate-value.js
var interpolateValue;
var init_interpolate_value = __esm({
  "node_modules/automation-events/build/es2019/functions/interpolate-value.js"() {
    interpolateValue = (values, theoreticIndex) => {
      const lowerIndex = Math.floor(theoreticIndex);
      const upperIndex = Math.ceil(theoreticIndex);
      if (lowerIndex === upperIndex) {
        return values[lowerIndex];
      }
      return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];
    };
  }
});

// node_modules/automation-events/build/es2019/functions/get-value-curve-value-at-time.js
var getValueCurveValueAtTime;
var init_get_value_curve_value_at_time = __esm({
  "node_modules/automation-events/build/es2019/functions/get-value-curve-value-at-time.js"() {
    init_interpolate_value();
    getValueCurveValueAtTime = (time3, { duration: duration3, startTime, values }) => {
      const theoreticIndex = (time3 - startTime) / duration3 * (values.length - 1);
      return interpolateValue(values, theoreticIndex);
    };
  }
});

// node_modules/automation-events/build/es2019/guards/set-target-automation-event.js
var isSetTargetAutomationEvent;
var init_set_target_automation_event = __esm({
  "node_modules/automation-events/build/es2019/guards/set-target-automation-event.js"() {
    isSetTargetAutomationEvent = (automationEvent) => {
      return automationEvent.type === "setTarget";
    };
  }
});

// node_modules/automation-events/build/es2019/classes/automation-event-list.js
var AutomationEventList;
var init_automation_event_list = __esm({
  "node_modules/automation-events/build/es2019/classes/automation-event-list.js"() {
    init_create_extended_exponential_ramp_to_value_automation_event();
    init_create_extended_linear_ramp_to_value_automation_event();
    init_create_set_value_automation_event();
    init_create_set_value_curve_automation_event();
    init_get_end_time_and_value_of_previous_automation_event();
    init_get_event_time();
    init_get_exponential_ramp_value_at_time();
    init_get_linear_ramp_value_at_time();
    init_get_target_value_at_time();
    init_get_value_curve_value_at_time();
    init_get_value_of_automation_event_at_index_at_time();
    init_any_ramp_to_value_automation_event();
    init_cancel_and_hold_automation_event();
    init_cancel_scheduled_values_automation_event();
    init_exponential_ramp_to_value_automation_event();
    init_linear_ramp_to_value_automation_event();
    init_set_target_automation_event();
    init_set_value_automation_event();
    init_set_value_curve_automation_event();
    AutomationEventList = class {
      constructor(defaultValue) {
        this._automationEvents = [];
        this._currenTime = 0;
        this._defaultValue = defaultValue;
      }
      [Symbol.iterator]() {
        return this._automationEvents[Symbol.iterator]();
      }
      add(automationEvent) {
        const eventTime = getEventTime(automationEvent);
        if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {
          const index = this._automationEvents.findIndex((currentAutomationEvent) => {
            if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {
              return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;
            }
            return getEventTime(currentAutomationEvent) >= eventTime;
          });
          const removedAutomationEvent = this._automationEvents[index];
          if (index !== -1) {
            this._automationEvents = this._automationEvents.slice(0, index);
          }
          if (isCancelAndHoldAutomationEvent(automationEvent)) {
            const lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];
            if (removedAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {
              if (lastAutomationEvent !== void 0 && isSetTargetAutomationEvent(lastAutomationEvent)) {
                throw new Error("The internal list is malformed.");
              }
              const startTime = lastAutomationEvent === void 0 ? removedAutomationEvent.insertTime : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.startTime + lastAutomationEvent.duration : getEventTime(lastAutomationEvent);
              const startValue = lastAutomationEvent === void 0 ? this._defaultValue : isSetValueCurveAutomationEvent(lastAutomationEvent) ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1] : lastAutomationEvent.value;
              const value = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent) : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);
              const truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent) ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime) : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);
              this._automationEvents.push(truncatedAutomationEvent);
            }
            if (lastAutomationEvent !== void 0 && isSetTargetAutomationEvent(lastAutomationEvent)) {
              this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));
            }
            if (lastAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(lastAutomationEvent) && lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime) {
              const duration3 = eventTime - lastAutomationEvent.startTime;
              const ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;
              const length = Math.max(2, 1 + Math.ceil(duration3 * ratio));
              const fraction = duration3 / (length - 1) * ratio;
              const values = lastAutomationEvent.values.slice(0, length);
              if (fraction < 1) {
                for (let i = 1; i < length; i += 1) {
                  const factor = fraction * i % 1;
                  values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;
                }
              }
              this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(values, lastAutomationEvent.startTime, duration3);
            }
          }
        } else {
          const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > eventTime);
          const previousAutomationEvent = index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[index - 1];
          if (previousAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(previousAutomationEvent) && getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime) {
            return false;
          }
          const persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent) ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime) : isLinearRampToValueAutomationEvent(automationEvent) ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime) : automationEvent;
          if (index === -1) {
            this._automationEvents.push(persistentAutomationEvent);
          } else {
            if (isSetValueCurveAutomationEvent(automationEvent) && eventTime + automationEvent.duration > getEventTime(this._automationEvents[index])) {
              return false;
            }
            this._automationEvents.splice(index, 0, persistentAutomationEvent);
          }
        }
        return true;
      }
      flush(time3) {
        const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > time3);
        if (index > 1) {
          const remainingAutomationEvents = this._automationEvents.slice(index - 1);
          const firstRemainingAutomationEvent = remainingAutomationEvents[0];
          if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {
            remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents, index - 2, firstRemainingAutomationEvent.startTime, this._defaultValue), firstRemainingAutomationEvent.startTime));
          }
          this._automationEvents = remainingAutomationEvents;
        }
      }
      getValue(time3) {
        if (this._automationEvents.length === 0) {
          return this._defaultValue;
        }
        const indexOfNextEvent = this._automationEvents.findIndex((automationEvent) => getEventTime(automationEvent) > time3);
        const nextAutomationEvent = this._automationEvents[indexOfNextEvent];
        const indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;
        const currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];
        if (currentAutomationEvent !== void 0 && isSetTargetAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || nextAutomationEvent.insertTime > time3)) {
          return getTargetValueAtTime(time3, getValueOfAutomationEventAtIndexAtTime(this._automationEvents, indexOfCurrentEvent - 1, currentAutomationEvent.startTime, this._defaultValue), currentAutomationEvent);
        }
        if (currentAutomationEvent !== void 0 && isSetValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
          return currentAutomationEvent.value;
        }
        if (currentAutomationEvent !== void 0 && isSetValueCurveAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent) || currentAutomationEvent.startTime + currentAutomationEvent.duration > time3)) {
          if (time3 < currentAutomationEvent.startTime + currentAutomationEvent.duration) {
            return getValueCurveValueAtTime(time3, currentAutomationEvent);
          }
          return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];
        }
        if (currentAutomationEvent !== void 0 && isAnyRampToValueAutomationEvent(currentAutomationEvent) && (nextAutomationEvent === void 0 || !isAnyRampToValueAutomationEvent(nextAutomationEvent))) {
          return currentAutomationEvent.value;
        }
        if (nextAutomationEvent !== void 0 && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {
          const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);
          return getExponentialRampValueAtTime(time3, startTime, value, nextAutomationEvent);
        }
        if (nextAutomationEvent !== void 0 && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {
          const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents, indexOfCurrentEvent, currentAutomationEvent, nextAutomationEvent, this._defaultValue);
          return getLinearRampValueAtTime(time3, startTime, value, nextAutomationEvent);
        }
        return this._defaultValue;
      }
    };
  }
});

// node_modules/automation-events/build/es2019/functions/create-cancel-and-hold-automation-event.js
var createCancelAndHoldAutomationEvent;
var init_create_cancel_and_hold_automation_event = __esm({
  "node_modules/automation-events/build/es2019/functions/create-cancel-and-hold-automation-event.js"() {
    createCancelAndHoldAutomationEvent = (cancelTime) => {
      return { cancelTime, type: "cancelAndHold" };
    };
  }
});

// node_modules/automation-events/build/es2019/functions/create-cancel-scheduled-values-automation-event.js
var createCancelScheduledValuesAutomationEvent;
var init_create_cancel_scheduled_values_automation_event = __esm({
  "node_modules/automation-events/build/es2019/functions/create-cancel-scheduled-values-automation-event.js"() {
    createCancelScheduledValuesAutomationEvent = (cancelTime) => {
      return { cancelTime, type: "cancelScheduledValues" };
    };
  }
});

// node_modules/automation-events/build/es2019/functions/create-exponential-ramp-to-value-automation-event.js
var createExponentialRampToValueAutomationEvent;
var init_create_exponential_ramp_to_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/functions/create-exponential-ramp-to-value-automation-event.js"() {
    createExponentialRampToValueAutomationEvent = (value, endTime) => {
      return { endTime, type: "exponentialRampToValue", value };
    };
  }
});

// node_modules/automation-events/build/es2019/functions/create-linear-ramp-to-value-automation-event.js
var createLinearRampToValueAutomationEvent;
var init_create_linear_ramp_to_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/functions/create-linear-ramp-to-value-automation-event.js"() {
    createLinearRampToValueAutomationEvent = (value, endTime) => {
      return { endTime, type: "linearRampToValue", value };
    };
  }
});

// node_modules/automation-events/build/es2019/functions/create-set-target-automation-event.js
var createSetTargetAutomationEvent;
var init_create_set_target_automation_event = __esm({
  "node_modules/automation-events/build/es2019/functions/create-set-target-automation-event.js"() {
    createSetTargetAutomationEvent = (target, startTime, timeConstant) => {
      return { startTime, target, timeConstant, type: "setTarget" };
    };
  }
});

// node_modules/automation-events/build/es2019/interfaces/cancel-and-hold-automation-event.js
var init_cancel_and_hold_automation_event2 = __esm({
  "node_modules/automation-events/build/es2019/interfaces/cancel-and-hold-automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/interfaces/cancel-scheduled-values-automation-event.js
var init_cancel_scheduled_values_automation_event2 = __esm({
  "node_modules/automation-events/build/es2019/interfaces/cancel-scheduled-values-automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/interfaces/exponential-ramp-to-value-automation-event.js
var init_exponential_ramp_to_value_automation_event2 = __esm({
  "node_modules/automation-events/build/es2019/interfaces/exponential-ramp-to-value-automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/interfaces/extended-exponential-ramp-to-value-automation-event.js
var init_extended_exponential_ramp_to_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/interfaces/extended-exponential-ramp-to-value-automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/interfaces/extended-linear-ramp-to-value-automation-event.js
var init_extended_linear_ramp_to_value_automation_event = __esm({
  "node_modules/automation-events/build/es2019/interfaces/extended-linear-ramp-to-value-automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/interfaces/linear-ramp-to-value-automation-event.js
var init_linear_ramp_to_value_automation_event2 = __esm({
  "node_modules/automation-events/build/es2019/interfaces/linear-ramp-to-value-automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/interfaces/set-value-automation-event.js
var init_set_value_automation_event2 = __esm({
  "node_modules/automation-events/build/es2019/interfaces/set-value-automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/interfaces/set-target-automation-event.js
var init_set_target_automation_event2 = __esm({
  "node_modules/automation-events/build/es2019/interfaces/set-target-automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/interfaces/set-value-curve-automation-event.js
var init_set_value_curve_automation_event2 = __esm({
  "node_modules/automation-events/build/es2019/interfaces/set-value-curve-automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/interfaces/index.js
var init_interfaces7 = __esm({
  "node_modules/automation-events/build/es2019/interfaces/index.js"() {
    init_cancel_and_hold_automation_event2();
    init_cancel_scheduled_values_automation_event2();
    init_exponential_ramp_to_value_automation_event2();
    init_extended_exponential_ramp_to_value_automation_event();
    init_extended_linear_ramp_to_value_automation_event();
    init_linear_ramp_to_value_automation_event2();
    init_set_value_automation_event2();
    init_set_target_automation_event2();
    init_set_value_curve_automation_event2();
  }
});

// node_modules/automation-events/build/es2019/types/automation-event.js
var init_automation_event = __esm({
  "node_modules/automation-events/build/es2019/types/automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/types/persistent-automation-event.js
var init_persistent_automation_event = __esm({
  "node_modules/automation-events/build/es2019/types/persistent-automation-event.js"() {
  }
});

// node_modules/automation-events/build/es2019/types/index.js
var init_types9 = __esm({
  "node_modules/automation-events/build/es2019/types/index.js"() {
    init_automation_event();
    init_persistent_automation_event();
  }
});

// node_modules/automation-events/build/es2019/module.js
var init_module10 = __esm({
  "node_modules/automation-events/build/es2019/module.js"() {
    init_automation_event_list();
    init_create_cancel_and_hold_automation_event();
    init_create_cancel_scheduled_values_automation_event();
    init_create_exponential_ramp_to_value_automation_event();
    init_create_linear_ramp_to_value_automation_event();
    init_create_set_target_automation_event();
    init_create_set_value_automation_event();
    init_create_set_value_curve_automation_event();
    init_interfaces7();
    init_types9();
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/abort-error.js
var createAbortError;
var init_abort_error = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/abort-error.js"() {
    createAbortError = () => new DOMException("", "AbortError");
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/add-active-input-connection-to-audio-node.js
var createAddActiveInputConnectionToAudioNode;
var init_add_active_input_connection_to_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/add-active-input-connection-to-audio-node.js"() {
    createAddActiveInputConnectionToAudioNode = (insertElementInSet2) => {
      return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {
        insertElementInSet2(activeInputs[input], [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js
var createAddAudioNodeConnections;
var init_add_audio_node_connections = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/add-audio-node-connections.js"() {
    createAddAudioNodeConnections = (audioNodeConnectionsStore) => {
      return (audioNode, audioNodeRenderer, nativeAudioNode) => {
        const activeInputs = [];
        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {
          activeInputs.push(/* @__PURE__ */ new Set());
        }
        audioNodeConnectionsStore.set(audioNode, {
          activeInputs,
          outputs: /* @__PURE__ */ new Set(),
          passiveInputs: /* @__PURE__ */ new WeakMap(),
          renderer: audioNodeRenderer
        });
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js
var createAddAudioParamConnections;
var init_add_audio_param_connections = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/add-audio-param-connections.js"() {
    createAddAudioParamConnections = (audioParamConnectionsStore) => {
      return (audioParam, audioParamRenderer) => {
        audioParamConnectionsStore.set(audioParam, { activeInputs: /* @__PURE__ */ new Set(), passiveInputs: /* @__PURE__ */ new WeakMap(), renderer: audioParamRenderer });
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/globals.js
var ACTIVE_AUDIO_NODE_STORE, AUDIO_NODE_CONNECTIONS_STORE, AUDIO_NODE_STORE, AUDIO_PARAM_CONNECTIONS_STORE, AUDIO_PARAM_STORE, CONTEXT_STORE, EVENT_LISTENERS, CYCLE_COUNTERS, NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS, NODE_TO_PROCESSOR_MAPS;
var init_globals = __esm({
  "node_modules/standardized-audio-context/build/es2019/globals.js"() {
    ACTIVE_AUDIO_NODE_STORE = /* @__PURE__ */ new WeakSet();
    AUDIO_NODE_CONNECTIONS_STORE = /* @__PURE__ */ new WeakMap();
    AUDIO_NODE_STORE = /* @__PURE__ */ new WeakMap();
    AUDIO_PARAM_CONNECTIONS_STORE = /* @__PURE__ */ new WeakMap();
    AUDIO_PARAM_STORE = /* @__PURE__ */ new WeakMap();
    CONTEXT_STORE = /* @__PURE__ */ new WeakMap();
    EVENT_LISTENERS = /* @__PURE__ */ new WeakMap();
    CYCLE_COUNTERS = /* @__PURE__ */ new WeakMap();
    NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS = /* @__PURE__ */ new WeakMap();
    NODE_TO_PROCESSOR_MAPS = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js
var handler, isConstructible;
var init_is_constructible = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/is-constructible.js"() {
    handler = {
      construct() {
        return handler;
      }
    };
    isConstructible = (constructible) => {
      try {
        const proxy = new Proxy(constructible, handler);
        new proxy();
      } catch {
        return false;
      }
      return true;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js
var IMPORT_STATEMENT_REGEX, splitImportStatements;
var init_split_import_statements = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/split-import-statements.js"() {
    IMPORT_STATEMENT_REGEX = /^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/;
    splitImportStatements = (source, url4) => {
      const importStatements = [];
      let sourceWithoutImportStatements = source.replace(/^[\s]+/, "");
      let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
      while (result !== null) {
        const unresolvedUrl = result[1].slice(1, -1);
        const importStatementWithResolvedUrl = result[0].replace(/([\s]+)?;?$/, "").replace(unresolvedUrl, new URL(unresolvedUrl, url4).toString());
        importStatements.push(importStatementWithResolvedUrl);
        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\s]+/, "");
        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);
      }
      return [importStatements.join(";"), sourceWithoutImportStatements];
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js
var verifyParameterDescriptors, verifyProcessorCtor, createAddAudioWorkletModule;
var init_add_audio_worklet_module = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/add-audio-worklet-module.js"() {
    init_globals();
    init_is_constructible();
    init_split_import_statements();
    verifyParameterDescriptors = (parameterDescriptors) => {
      if (parameterDescriptors !== void 0 && !Array.isArray(parameterDescriptors)) {
        throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.");
      }
    };
    verifyProcessorCtor = (processorCtor) => {
      if (!isConstructible(processorCtor)) {
        throw new TypeError("The given value for processorCtor should be a constructor.");
      }
      if (processorCtor.prototype === null || typeof processorCtor.prototype !== "object") {
        throw new TypeError("The given value for processorCtor should have a prototype.");
      }
    };
    createAddAudioWorkletModule = (cacheTestResult2, createNotSupportedError3, evaluateSource, exposeCurrentFrameAndCurrentTime2, fetchSource, getNativeContext2, getOrCreateBackupOfflineAudioContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, ongoingRequests, resolvedRequests, testAudioWorkletProcessorPostMessageSupport, window5) => {
      let index = 0;
      return (context, moduleURL, options = { credentials: "omit" }) => {
        const resolvedRequestsOfContext = resolvedRequests.get(context);
        if (resolvedRequestsOfContext !== void 0 && resolvedRequestsOfContext.has(moduleURL)) {
          return Promise.resolve();
        }
        const ongoingRequestsOfContext = ongoingRequests.get(context);
        if (ongoingRequestsOfContext !== void 0) {
          const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);
          if (promiseOfOngoingRequest !== void 0) {
            return promiseOfOngoingRequest;
          }
        }
        const nativeContext = getNativeContext2(context);
        const promise2 = nativeContext.audioWorklet === void 0 ? fetchSource(moduleURL).then(([source, absoluteUrl]) => {
          const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);
          const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}
})})(window,'_AWGS')`;
          return evaluateSource(wrappedSource);
        }).then(() => {
          const evaluateAudioWorkletGlobalScope = window5._AWGS.pop();
          if (evaluateAudioWorkletGlobalScope === void 0) {
            throw new SyntaxError();
          }
          exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor {
          }, void 0, (name, processorCtor) => {
            if (name.trim() === "") {
              throw createNotSupportedError3();
            }
            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);
            if (nodeNameToProcessorConstructorMap !== void 0) {
              if (nodeNameToProcessorConstructorMap.has(name)) {
                throw createNotSupportedError3();
              }
              verifyProcessorCtor(processorCtor);
              verifyParameterDescriptors(processorCtor.parameterDescriptors);
              nodeNameToProcessorConstructorMap.set(name, processorCtor);
            } else {
              verifyProcessorCtor(processorCtor);
              verifyParameterDescriptors(processorCtor.parameterDescriptors);
              NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, /* @__PURE__ */ new Map([[name, processorCtor]]));
            }
          }, nativeContext.sampleRate, void 0, void 0));
        }) : Promise.all([
          fetchSource(moduleURL),
          Promise.resolve(cacheTestResult2(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport))
        ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {
          const currentIndex = index + 1;
          index = currentIndex;
          const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);
          const patchedAudioWorkletProcessor = isSupportingPostMessage ? "AudioWorkletProcessor" : "class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}";
          const memberDefinition = isSupportingPostMessage ? "" : "__c = (a) => a.forEach(e=>this.__b.add(e.buffer));";
          const bufferRegistration = isSupportingPostMessage ? "" : "i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));";
          const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}
})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;
          const blob3 = new Blob([wrappedSource], { type: "application/javascript; charset=utf-8" });
          const url4 = URL.createObjectURL(blob3);
          return nativeContext.audioWorklet.addModule(url4, options).then(() => {
            if (isNativeOfflineAudioContext2(nativeContext)) {
              return nativeContext;
            }
            const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext2(nativeContext);
            return backupOfflineAudioContext.audioWorklet.addModule(url4, options).then(() => backupOfflineAudioContext);
          }).then((nativeContextOrBackupOfflineAudioContext) => {
            if (nativeAudioWorkletNodeConstructor2 === null) {
              throw new SyntaxError();
            }
            try {
              new nativeAudioWorkletNodeConstructor2(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`);
            } catch {
              throw new SyntaxError();
            }
          }).finally(() => URL.revokeObjectURL(url4));
        });
        if (ongoingRequestsOfContext === void 0) {
          ongoingRequests.set(context, /* @__PURE__ */ new Map([[moduleURL, promise2]]));
        } else {
          ongoingRequestsOfContext.set(moduleURL, promise2);
        }
        promise2.then(() => {
          const updatedResolvedRequestsOfContext = resolvedRequests.get(context);
          if (updatedResolvedRequestsOfContext === void 0) {
            resolvedRequests.set(context, /* @__PURE__ */ new Set([moduleURL]));
          } else {
            updatedResolvedRequestsOfContext.add(moduleURL);
          }
        }).finally(() => {
          const updatedOngoingRequestsOfContext = ongoingRequests.get(context);
          if (updatedOngoingRequestsOfContext !== void 0) {
            updatedOngoingRequestsOfContext.delete(moduleURL);
          }
        });
        return promise2;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js
var getValueForKey;
var init_get_value_for_key = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/get-value-for-key.js"() {
    getValueForKey = (map2, key) => {
      const value = map2.get(key);
      if (value === void 0) {
        throw new Error("A value with the given key could not be found.");
      }
      return value;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js
var pickElementFromSet;
var init_pick_element_from_set = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/pick-element-from-set.js"() {
    pickElementFromSet = (set2, predicate) => {
      const matchingElements = Array.from(set2).filter(predicate);
      if (matchingElements.length > 1) {
        throw Error("More than one element was found.");
      }
      if (matchingElements.length === 0) {
        throw Error("No element was found.");
      }
      const [matchingElement] = matchingElements;
      set2.delete(matchingElement);
      return matchingElement;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-node.js
var deletePassiveInputConnectionToAudioNode;
var init_delete_passive_input_connection_to_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-node.js"() {
    init_get_value_for_key();
    init_pick_element_from_set();
    deletePassiveInputConnectionToAudioNode = (passiveInputs, source, output, input) => {
      const passiveInputConnections = getValueForKey(passiveInputs, source);
      const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input);
      if (passiveInputConnections.size === 0) {
        passiveInputs.delete(source);
      }
      return matchingConnection;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js
var getEventListenersOfAudioNode;
var init_get_event_listeners_of_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/get-event-listeners-of-audio-node.js"() {
    init_globals();
    init_get_value_for_key();
    getEventListenersOfAudioNode = (audioNode) => {
      return getValueForKey(EVENT_LISTENERS, audioNode);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js
var setInternalStateToActive;
var init_set_internal_state_to_active = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-active.js"() {
    init_globals();
    init_get_event_listeners_of_audio_node();
    setInternalStateToActive = (audioNode) => {
      if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
        throw new Error("The AudioNode is already stored.");
      }
      ACTIVE_AUDIO_NODE_STORE.add(audioNode);
      getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js
var isAudioWorkletNode;
var init_audio_worklet_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/audio-worklet-node.js"() {
    isAudioWorkletNode = (audioNode) => {
      return "port" in audioNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js
var setInternalStateToPassive;
var init_set_internal_state_to_passive = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive.js"() {
    init_globals();
    init_get_event_listeners_of_audio_node();
    setInternalStateToPassive = (audioNode) => {
      if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {
        throw new Error("The AudioNode is not stored.");
      }
      ACTIVE_AUDIO_NODE_STORE.delete(audioNode);
      getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js
var setInternalStateToPassiveWhenNecessary;
var init_set_internal_state_to_passive_when_necessary = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/set-internal-state-to-passive-when-necessary.js"() {
    init_audio_worklet_node();
    init_set_internal_state_to_passive();
    setInternalStateToPassiveWhenNecessary = (audioNode, activeInputs) => {
      if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {
        setInternalStateToPassive(audioNode);
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/add-connection-to-audio-node.js
var createAddConnectionToAudioNode;
var init_add_connection_to_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/add-connection-to-audio-node.js"() {
    init_delete_passive_input_connection_to_audio_node();
    init_set_internal_state_to_active();
    init_set_internal_state_to_passive_when_necessary();
    createAddConnectionToAudioNode = (addActiveInputConnectionToAudioNode2, addPassiveInputConnectionToAudioNode2, connectNativeAudioNodeToNativeAudioNode2, deleteActiveInputConnectionToAudioNode2, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getAudioNodeTailTime2, getEventListenersOfAudioNode2, getNativeAudioNode2, insertElementInSet2, isActiveAudioNode2, isPartOfACycle2, isPassiveAudioNode2) => {
      const tailTimeTimeoutIds = /* @__PURE__ */ new WeakMap();
      return (source, destination, output, input, isOffline) => {
        const { activeInputs, passiveInputs } = getAudioNodeConnections2(destination);
        const { outputs } = getAudioNodeConnections2(source);
        const eventListeners = getEventListenersOfAudioNode2(source);
        const eventListener = (isActive) => {
          const nativeDestinationAudioNode = getNativeAudioNode2(destination);
          const nativeSourceAudioNode = getNativeAudioNode2(source);
          if (isActive) {
            const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);
            addActiveInputConnectionToAudioNode2(activeInputs, source, partialConnection, false);
            if (!isOffline && !isPartOfACycle2(source)) {
              connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);
            }
            if (isPassiveAudioNode2(destination)) {
              setInternalStateToActive(destination);
            }
          } else {
            const partialConnection = deleteActiveInputConnectionToAudioNode2(activeInputs, source, output, input);
            addPassiveInputConnectionToAudioNode2(passiveInputs, input, partialConnection, false);
            if (!isOffline && !isPartOfACycle2(source)) {
              disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);
            }
            const tailTime = getAudioNodeTailTime2(destination);
            if (tailTime === 0) {
              if (isActiveAudioNode2(destination)) {
                setInternalStateToPassiveWhenNecessary(destination, activeInputs);
              }
            } else {
              const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);
              if (tailTimeTimeoutId !== void 0) {
                clearTimeout(tailTimeTimeoutId);
              }
              tailTimeTimeoutIds.set(destination, setTimeout(() => {
                if (isActiveAudioNode2(destination)) {
                  setInternalStateToPassiveWhenNecessary(destination, activeInputs);
                }
              }, tailTime * 1e3));
            }
          }
        };
        if (insertElementInSet2(outputs, [destination, output, input], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input, true)) {
          eventListeners.add(eventListener);
          if (isActiveAudioNode2(source)) {
            addActiveInputConnectionToAudioNode2(activeInputs, source, [output, input, eventListener], true);
          } else {
            addPassiveInputConnectionToAudioNode2(passiveInputs, input, [source, output, eventListener], true);
          }
          return true;
        }
        return false;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/add-passive-input-connection-to-audio-node.js
var createAddPassiveInputConnectionToAudioNode;
var init_add_passive_input_connection_to_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/add-passive-input-connection-to-audio-node.js"() {
    createAddPassiveInputConnectionToAudioNode = (insertElementInSet2) => {
      return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {
        const passiveInputConnections = passiveInputs.get(source);
        if (passiveInputConnections === void 0) {
          passiveInputs.set(source, /* @__PURE__ */ new Set([[output, input, eventListener]]));
        } else {
          insertElementInSet2(passiveInputConnections, [output, input, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input, ignoreDuplicates);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js
var createAddSilentConnection;
var init_add_silent_connection = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/add-silent-connection.js"() {
    createAddSilentConnection = (createNativeGainNode2) => {
      return (nativeContext, nativeAudioScheduledSourceNode) => {
        const nativeGainNode = createNativeGainNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          gain: 0
        });
        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);
        const disconnect3 = () => {
          nativeAudioScheduledSourceNode.removeEventListener("ended", disconnect3);
          nativeAudioScheduledSourceNode.disconnect(nativeGainNode);
          nativeGainNode.disconnect();
        };
        nativeAudioScheduledSourceNode.addEventListener("ended", disconnect3);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js
var createAddUnrenderedAudioWorkletNode;
var init_add_unrendered_audio_worklet_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/add-unrendered-audio-worklet-node.js"() {
    createAddUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {
      return (nativeContext, audioWorkletNode) => {
        getUnrenderedAudioWorkletNodes2(nativeContext).add(audioWorkletNode);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js
var DEFAULT_OPTIONS, createAnalyserNodeConstructor;
var init_analyser_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/analyser-node-constructor.js"() {
    DEFAULT_OPTIONS = {
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      fftSize: 2048,
      maxDecibels: -30,
      minDecibels: -100,
      smoothingTimeConstant: 0.8
    };
    createAnalyserNodeConstructor = (audionNodeConstructor, createAnalyserNodeRenderer2, createIndexSizeError2, createNativeAnalyserNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
      return class AnalyserNode extends audionNodeConstructor {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS, ...options };
          const nativeAnalyserNode = createNativeAnalyserNode2(nativeContext, mergedOptions);
          const analyserNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createAnalyserNodeRenderer2() : null;
          super(context, false, nativeAnalyserNode, analyserNodeRenderer);
          this._nativeAnalyserNode = nativeAnalyserNode;
        }
        get fftSize() {
          return this._nativeAnalyserNode.fftSize;
        }
        set fftSize(value) {
          this._nativeAnalyserNode.fftSize = value;
        }
        get frequencyBinCount() {
          return this._nativeAnalyserNode.frequencyBinCount;
        }
        get maxDecibels() {
          return this._nativeAnalyserNode.maxDecibels;
        }
        set maxDecibels(value) {
          const maxDecibels = this._nativeAnalyserNode.maxDecibels;
          this._nativeAnalyserNode.maxDecibels = value;
          if (!(value > this._nativeAnalyserNode.minDecibels)) {
            this._nativeAnalyserNode.maxDecibels = maxDecibels;
            throw createIndexSizeError2();
          }
        }
        get minDecibels() {
          return this._nativeAnalyserNode.minDecibels;
        }
        set minDecibels(value) {
          const minDecibels = this._nativeAnalyserNode.minDecibels;
          this._nativeAnalyserNode.minDecibels = value;
          if (!(this._nativeAnalyserNode.maxDecibels > value)) {
            this._nativeAnalyserNode.minDecibels = minDecibels;
            throw createIndexSizeError2();
          }
        }
        get smoothingTimeConstant() {
          return this._nativeAnalyserNode.smoothingTimeConstant;
        }
        set smoothingTimeConstant(value) {
          this._nativeAnalyserNode.smoothingTimeConstant = value;
        }
        getByteFrequencyData(array2) {
          this._nativeAnalyserNode.getByteFrequencyData(array2);
        }
        getByteTimeDomainData(array2) {
          this._nativeAnalyserNode.getByteTimeDomainData(array2);
        }
        getFloatFrequencyData(array2) {
          this._nativeAnalyserNode.getFloatFrequencyData(array2);
        }
        getFloatTimeDomainData(array2) {
          this._nativeAnalyserNode.getFloatTimeDomainData(array2);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js
var isOwnedByContext;
var init_is_owned_by_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/is-owned-by-context.js"() {
    isOwnedByContext = (nativeAudioNode, nativeContext) => {
      return nativeAudioNode.context === nativeContext;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js
var createAnalyserNodeRendererFactory;
var init_analyser_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/analyser-node-renderer-factory.js"() {
    init_is_owned_by_context();
    createAnalyserNodeRendererFactory = (createNativeAnalyserNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeAnalyserNodes = /* @__PURE__ */ new WeakMap();
        const createAnalyserNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeAnalyserNode = getNativeAudioNode2(proxy);
          const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);
          if (!nativeAnalyserNodeIsOwnedByContext) {
            const options = {
              channelCount: nativeAnalyserNode.channelCount,
              channelCountMode: nativeAnalyserNode.channelCountMode,
              channelInterpretation: nativeAnalyserNode.channelInterpretation,
              fftSize: nativeAnalyserNode.fftSize,
              maxDecibels: nativeAnalyserNode.maxDecibels,
              minDecibels: nativeAnalyserNode.minDecibels,
              smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant
            };
            nativeAnalyserNode = createNativeAnalyserNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAnalyserNode);
          return nativeAnalyserNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);
            if (renderedNativeAnalyserNode !== void 0) {
              return Promise.resolve(renderedNativeAnalyserNode);
            }
            return createAnalyserNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js
var testAudioBufferCopyChannelMethodsOutOfBoundsSupport;
var init_test_audio_buffer_copy_channel_methods_out_of_bounds_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.js"() {
    testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer) => {
      try {
        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);
      } catch {
        return false;
      }
      return true;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js
var createIndexSizeError;
var init_index_size_error = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/index-size-error.js"() {
    createIndexSizeError = () => new DOMException("", "IndexSizeError");
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js
var wrapAudioBufferGetChannelDataMethod;
var init_wrap_audio_buffer_get_channel_data_method = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-get-channel-data-method.js"() {
    init_index_size_error();
    wrapAudioBufferGetChannelDataMethod = (audioBuffer) => {
      audioBuffer.getChannelData = /* @__PURE__ */ ((getChannelData) => {
        return (channel) => {
          try {
            return getChannelData.call(audioBuffer, channel);
          } catch (err) {
            if (err.code === 12) {
              throw createIndexSizeError();
            }
            throw err;
          }
        };
      })(audioBuffer.getChannelData);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js
var DEFAULT_OPTIONS2, createAudioBufferConstructor;
var init_audio_buffer_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-constructor.js"() {
    init_test_audio_buffer_copy_channel_methods_out_of_bounds_support();
    init_wrap_audio_buffer_get_channel_data_method();
    DEFAULT_OPTIONS2 = {
      numberOfChannels: 1
    };
    createAudioBufferConstructor = (audioBufferStore2, cacheTestResult2, createNotSupportedError3, nativeAudioBufferConstructor2, nativeOfflineAudioContextConstructor2, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
      let nativeOfflineAudioContext = null;
      return class AudioBuffer {
        constructor(options) {
          if (nativeOfflineAudioContextConstructor2 === null) {
            throw new Error("Missing the native OfflineAudioContext constructor.");
          }
          const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS2, ...options };
          if (nativeOfflineAudioContext === null) {
            nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
          }
          const audioBuffer = nativeAudioBufferConstructor2 !== null && cacheTestResult2(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor2({ length, numberOfChannels, sampleRate }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);
          if (audioBuffer.numberOfChannels === 0) {
            throw createNotSupportedError3();
          }
          if (typeof audioBuffer.copyFromChannel !== "function") {
            wrapAudioBufferCopyChannelMethods2(audioBuffer);
            wrapAudioBufferGetChannelDataMethod(audioBuffer);
          } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))) {
            wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
          }
          audioBufferStore2.add(audioBuffer);
          return audioBuffer;
        }
        static [Symbol.hasInstance](instance) {
          return instance !== null && typeof instance === "object" && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore2.has(instance);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/constants.js
var MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT;
var init_constants = __esm({
  "node_modules/standardized-audio-context/build/es2019/constants.js"() {
    MOST_NEGATIVE_SINGLE_FLOAT = -34028234663852886e22;
    MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js
var isActiveAudioNode;
var init_is_active_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/is-active-audio-node.js"() {
    init_globals();
    isActiveAudioNode = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js
var DEFAULT_OPTIONS3, createAudioBufferSourceNodeConstructor;
var init_audio_buffer_source_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-constructor.js"() {
    init_constants();
    init_is_active_audio_node();
    init_set_internal_state_to_active();
    init_set_internal_state_to_passive();
    DEFAULT_OPTIONS3 = {
      buffer: null,
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      // Bug #149: Safari does not yet support the detune AudioParam.
      loop: false,
      loopEnd: 0,
      loopStart: 0,
      playbackRate: 1
    };
    createAudioBufferSourceNodeConstructor = (audioNodeConstructor2, createAudioBufferSourceNodeRenderer2, createAudioParam2, createInvalidStateError3, createNativeAudioBufferSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener3) => {
      return class AudioBufferSourceNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS3, ...options };
          const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer2() : null;
          super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);
          this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;
          this._isBufferNullified = false;
          this._isBufferSet = mergedOptions.buffer !== null;
          this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;
          this._onended = null;
          this._playbackRate = createAudioParam2(this, isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        }
        get buffer() {
          if (this._isBufferNullified) {
            return null;
          }
          return this._nativeAudioBufferSourceNode.buffer;
        }
        set buffer(value) {
          this._nativeAudioBufferSourceNode.buffer = value;
          if (value !== null) {
            if (this._isBufferSet) {
              throw createInvalidStateError3();
            }
            this._isBufferSet = true;
          }
        }
        get loop() {
          return this._nativeAudioBufferSourceNode.loop;
        }
        set loop(value) {
          this._nativeAudioBufferSourceNode.loop = value;
        }
        get loopEnd() {
          return this._nativeAudioBufferSourceNode.loopEnd;
        }
        set loopEnd(value) {
          this._nativeAudioBufferSourceNode.loopEnd = value;
        }
        get loopStart() {
          return this._nativeAudioBufferSourceNode.loopStart;
        }
        set loopStart(value) {
          this._nativeAudioBufferSourceNode.loopStart = value;
        }
        get onended() {
          return this._onended;
        }
        set onended(value) {
          const wrappedListener = typeof value === "function" ? wrapEventListener3(this, value) : null;
          this._nativeAudioBufferSourceNode.onended = wrappedListener;
          const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;
          this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
        }
        get playbackRate() {
          return this._playbackRate;
        }
        start(when = 0, offset = 0, duration3) {
          this._nativeAudioBufferSourceNode.start(when, offset, duration3);
          if (this._audioBufferSourceNodeRenderer !== null) {
            this._audioBufferSourceNodeRenderer.start = duration3 === void 0 ? [when, offset] : [when, offset, duration3];
          }
          if (this.context.state !== "closed") {
            setInternalStateToActive(this);
            const resetInternalStateToPassive = () => {
              this._nativeAudioBufferSourceNode.removeEventListener("ended", resetInternalStateToPassive);
              if (isActiveAudioNode(this)) {
                setInternalStateToPassive(this);
              }
            };
            this._nativeAudioBufferSourceNode.addEventListener("ended", resetInternalStateToPassive);
          }
        }
        stop(when = 0) {
          this._nativeAudioBufferSourceNode.stop(when);
          if (this._audioBufferSourceNodeRenderer !== null) {
            this._audioBufferSourceNodeRenderer.stop = when;
          }
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js
var createAudioBufferSourceNodeRendererFactory;
var init_audio_buffer_source_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-buffer-source-node-renderer-factory.js"() {
    init_is_owned_by_context();
    createAudioBufferSourceNodeRendererFactory = (connectAudioParam2, createNativeAudioBufferSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeAudioBufferSourceNodes = /* @__PURE__ */ new WeakMap();
        let start = null;
        let stop = null;
        const createAudioBufferSourceNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeAudioBufferSourceNode = getNativeAudioNode2(proxy);
          const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);
          if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
            const options = {
              buffer: nativeAudioBufferSourceNode.buffer,
              channelCount: nativeAudioBufferSourceNode.channelCount,
              channelCountMode: nativeAudioBufferSourceNode.channelCountMode,
              channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,
              // Bug #149: Safari does not yet support the detune AudioParam.
              loop: nativeAudioBufferSourceNode.loop,
              loopEnd: nativeAudioBufferSourceNode.loopEnd,
              loopStart: nativeAudioBufferSourceNode.loopStart,
              playbackRate: nativeAudioBufferSourceNode.playbackRate.value
            };
            nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, options);
            if (start !== null) {
              nativeAudioBufferSourceNode.start(...start);
            }
            if (stop !== null) {
              nativeAudioBufferSourceNode.stop(stop);
            }
          }
          renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);
          if (!nativeAudioBufferSourceNodeIsOwnedByContext) {
            await renderAutomation2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
          } else {
            await connectAudioParam2(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);
          }
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);
          return nativeAudioBufferSourceNode;
        };
        return {
          set start(value) {
            start = value;
          },
          set stop(value) {
            stop = value;
          },
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);
            if (renderedNativeAudioBufferSourceNode !== void 0) {
              return Promise.resolve(renderedNativeAudioBufferSourceNode);
            }
            return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/audio-buffer-source-node.js
var isAudioBufferSourceNode;
var init_audio_buffer_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/audio-buffer-source-node.js"() {
    isAudioBufferSourceNode = (audioNode) => {
      return "playbackRate" in audioNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/biquad-filter-node.js
var isBiquadFilterNode;
var init_biquad_filter_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/biquad-filter-node.js"() {
    isBiquadFilterNode = (audioNode) => {
      return "frequency" in audioNode && "gain" in audioNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/constant-source-node.js
var isConstantSourceNode;
var init_constant_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/constant-source-node.js"() {
    isConstantSourceNode = (audioNode) => {
      return "offset" in audioNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/gain-node.js
var isGainNode;
var init_gain_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/gain-node.js"() {
    isGainNode = (audioNode) => {
      return !("frequency" in audioNode) && "gain" in audioNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/oscillator-node.js
var isOscillatorNode;
var init_oscillator_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/oscillator-node.js"() {
    isOscillatorNode = (audioNode) => {
      return "detune" in audioNode && "frequency" in audioNode && !("gain" in audioNode);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/stereo-panner-node.js
var isStereoPannerNode;
var init_stereo_panner_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/stereo-panner-node.js"() {
    isStereoPannerNode = (audioNode) => {
      return "pan" in audioNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js
var getAudioNodeConnections;
var init_get_audio_node_connections = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/get-audio-node-connections.js"() {
    init_globals();
    init_get_value_for_key();
    getAudioNodeConnections = (audioNode) => {
      return getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js
var getAudioParamConnections;
var init_get_audio_param_connections = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/get-audio-param-connections.js"() {
    init_globals();
    init_get_value_for_key();
    getAudioParamConnections = (audioParam) => {
      return getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/deactivate-active-audio-node-input-connections.js
var deactivateActiveAudioNodeInputConnections;
var init_deactivate_active_audio_node_input_connections = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/deactivate-active-audio-node-input-connections.js"() {
    init_audio_buffer_source_node();
    init_audio_worklet_node();
    init_biquad_filter_node();
    init_constant_source_node();
    init_gain_node();
    init_oscillator_node();
    init_stereo_panner_node();
    init_get_audio_node_connections();
    init_get_audio_param_connections();
    init_is_active_audio_node();
    init_set_internal_state_to_passive();
    deactivateActiveAudioNodeInputConnections = (audioNode, trace) => {
      const { activeInputs } = getAudioNodeConnections(audioNode);
      activeInputs.forEach((connections) => connections.forEach(([source]) => {
        if (!trace.includes(audioNode)) {
          deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);
        }
      }));
      const audioParams = isAudioBufferSourceNode(audioNode) ? [
        // Bug #149: Safari does not yet support the detune AudioParam.
        audioNode.playbackRate
      ] : isAudioWorkletNode(audioNode) ? Array.from(audioNode.parameters.values()) : isBiquadFilterNode(audioNode) ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain] : isConstantSourceNode(audioNode) ? [audioNode.offset] : isGainNode(audioNode) ? [audioNode.gain] : isOscillatorNode(audioNode) ? [audioNode.detune, audioNode.frequency] : isStereoPannerNode(audioNode) ? [audioNode.pan] : [];
      for (const audioParam of audioParams) {
        const audioParamConnections = getAudioParamConnections(audioParam);
        if (audioParamConnections !== void 0) {
          audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));
        }
      }
      if (isActiveAudioNode(audioNode)) {
        setInternalStateToPassive(audioNode);
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js
var deactivateAudioGraph;
var init_deactivate_audio_graph = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/deactivate-audio-graph.js"() {
    init_deactivate_active_audio_node_input_connections();
    deactivateAudioGraph = (context) => {
      deactivateActiveAudioNodeInputConnections(context.destination, []);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js
var isValidLatencyHint;
var init_is_valid_latency_hint = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/is-valid-latency-hint.js"() {
    isValidLatencyHint = (latencyHint) => {
      return latencyHint === void 0 || typeof latencyHint === "number" || typeof latencyHint === "string" && (latencyHint === "balanced" || latencyHint === "interactive" || latencyHint === "playback");
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js
var createAudioContextConstructor;
var init_audio_context_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-context-constructor.js"() {
    init_deactivate_audio_graph();
    init_is_valid_latency_hint();
    createAudioContextConstructor = (baseAudioContextConstructor2, createInvalidStateError3, createNotSupportedError3, createUnknownError2, mediaElementAudioSourceNodeConstructor2, mediaStreamAudioDestinationNodeConstructor2, mediaStreamAudioSourceNodeConstructor2, mediaStreamTrackAudioSourceNodeConstructor2, nativeAudioContextConstructor2) => {
      return class AudioContext extends baseAudioContextConstructor2 {
        constructor(options = {}) {
          if (nativeAudioContextConstructor2 === null) {
            throw new Error("Missing the native AudioContext constructor.");
          }
          let nativeAudioContext;
          try {
            nativeAudioContext = new nativeAudioContextConstructor2(options);
          } catch (err) {
            if (err.code === 12 && err.message === "sampleRate is not in range") {
              throw createNotSupportedError3();
            }
            throw err;
          }
          if (nativeAudioContext === null) {
            throw createUnknownError2();
          }
          if (!isValidLatencyHint(options.latencyHint)) {
            throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
          }
          if (options.sampleRate !== void 0 && nativeAudioContext.sampleRate !== options.sampleRate) {
            throw createNotSupportedError3();
          }
          super(nativeAudioContext, 2);
          const { latencyHint } = options;
          const { sampleRate } = nativeAudioContext;
          this._baseLatency = typeof nativeAudioContext.baseLatency === "number" ? nativeAudioContext.baseLatency : latencyHint === "balanced" ? 512 / sampleRate : latencyHint === "interactive" || latencyHint === void 0 ? 256 / sampleRate : latencyHint === "playback" ? 1024 / sampleRate : (
            /*
             * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a
             * ScriptProcessorNode.
             */
            Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate
          );
          this._nativeAudioContext = nativeAudioContext;
          if (nativeAudioContextConstructor2.name === "webkitAudioContext") {
            this._nativeGainNode = nativeAudioContext.createGain();
            this._nativeOscillatorNode = nativeAudioContext.createOscillator();
            this._nativeGainNode.gain.value = 1e-37;
            this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);
            this._nativeOscillatorNode.start();
          } else {
            this._nativeGainNode = null;
            this._nativeOscillatorNode = null;
          }
          this._state = null;
          if (nativeAudioContext.state === "running") {
            this._state = "suspended";
            const revokeState = () => {
              if (this._state === "suspended") {
                this._state = null;
              }
              nativeAudioContext.removeEventListener("statechange", revokeState);
            };
            nativeAudioContext.addEventListener("statechange", revokeState);
          }
        }
        get baseLatency() {
          return this._baseLatency;
        }
        get state() {
          return this._state !== null ? this._state : this._nativeAudioContext.state;
        }
        close() {
          if (this.state === "closed") {
            return this._nativeAudioContext.close().then(() => {
              throw createInvalidStateError3();
            });
          }
          if (this._state === "suspended") {
            this._state = null;
          }
          return this._nativeAudioContext.close().then(() => {
            if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {
              this._nativeOscillatorNode.stop();
              this._nativeGainNode.disconnect();
              this._nativeOscillatorNode.disconnect();
            }
            deactivateAudioGraph(this);
          });
        }
        createMediaElementSource(mediaElement) {
          return new mediaElementAudioSourceNodeConstructor2(this, { mediaElement });
        }
        createMediaStreamDestination() {
          return new mediaStreamAudioDestinationNodeConstructor2(this);
        }
        createMediaStreamSource(mediaStream) {
          return new mediaStreamAudioSourceNodeConstructor2(this, { mediaStream });
        }
        createMediaStreamTrackSource(mediaStreamTrack) {
          return new mediaStreamTrackAudioSourceNodeConstructor2(this, { mediaStreamTrack });
        }
        resume() {
          if (this._state === "suspended") {
            return new Promise((resolve, reject) => {
              const resolvePromise = () => {
                this._nativeAudioContext.removeEventListener("statechange", resolvePromise);
                if (this._nativeAudioContext.state === "running") {
                  resolve();
                } else {
                  this.resume().then(resolve, reject);
                }
              };
              this._nativeAudioContext.addEventListener("statechange", resolvePromise);
            });
          }
          return this._nativeAudioContext.resume().catch((err) => {
            if (err === void 0 || err.code === 15) {
              throw createInvalidStateError3();
            }
            throw err;
          });
        }
        suspend() {
          return this._nativeAudioContext.suspend().catch((err) => {
            if (err === void 0) {
              throw createInvalidStateError3();
            }
            throw err;
          });
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js
var createAudioDestinationNodeConstructor;
var init_audio_destination_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-constructor.js"() {
    createAudioDestinationNodeConstructor = (audioNodeConstructor2, createAudioDestinationNodeRenderer2, createIndexSizeError2, createInvalidStateError3, createNativeAudioDestinationNode, getNativeContext2, isNativeOfflineAudioContext2, renderInputsOfAudioNode2) => {
      return class AudioDestinationNode extends audioNodeConstructor2 {
        constructor(context, channelCount) {
          const nativeContext = getNativeContext2(context);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);
          const audioDestinationNodeRenderer = isOffline ? createAudioDestinationNodeRenderer2(renderInputsOfAudioNode2) : null;
          super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);
          this._isNodeOfNativeOfflineAudioContext = isOffline;
          this._nativeAudioDestinationNode = nativeAudioDestinationNode;
        }
        get channelCount() {
          return this._nativeAudioDestinationNode.channelCount;
        }
        set channelCount(value) {
          if (this._isNodeOfNativeOfflineAudioContext) {
            throw createInvalidStateError3();
          }
          if (value > this._nativeAudioDestinationNode.maxChannelCount) {
            throw createIndexSizeError2();
          }
          this._nativeAudioDestinationNode.channelCount = value;
        }
        get channelCountMode() {
          return this._nativeAudioDestinationNode.channelCountMode;
        }
        set channelCountMode(value) {
          if (this._isNodeOfNativeOfflineAudioContext) {
            throw createInvalidStateError3();
          }
          this._nativeAudioDestinationNode.channelCountMode = value;
        }
        get maxChannelCount() {
          return this._nativeAudioDestinationNode.maxChannelCount;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js
var createAudioDestinationNodeRenderer;
var init_audio_destination_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-destination-node-renderer-factory.js"() {
    createAudioDestinationNodeRenderer = (renderInputsOfAudioNode2) => {
      const renderedNativeAudioDestinationNodes = /* @__PURE__ */ new WeakMap();
      const createAudioDestinationNode = async (proxy, nativeOfflineAudioContext) => {
        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;
        renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);
        await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);
        return nativeAudioDestinationNode;
      };
      return {
        render(proxy, nativeOfflineAudioContext) {
          const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);
          if (renderedNativeAudioDestinationNode !== void 0) {
            return Promise.resolve(renderedNativeAudioDestinationNode);
          }
          return createAudioDestinationNode(proxy, nativeOfflineAudioContext);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js
var createAudioListenerFactory;
var init_audio_listener_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-listener-factory.js"() {
    init_constants();
    createAudioListenerFactory = (createAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeScriptProcessorNode2, createNotSupportedError3, getFirstSample2, isNativeOfflineAudioContext2, overwriteAccessors2) => {
      return (context, nativeContext) => {
        const nativeListener = nativeContext.listener;
        const createFakeAudioParams = () => {
          const buffer = new Float32Array(1);
          const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: 9
          });
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          let isScriptProcessorNodeCreated = false;
          let lastOrientation = [0, 0, -1, 0, 1, 0];
          let lastPosition = [0, 0, 0];
          const createScriptProcessorNode = () => {
            if (isScriptProcessorNodeCreated) {
              return;
            }
            isScriptProcessorNodeCreated = true;
            const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 9, 0);
            scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {
              const orientation = [
                getFirstSample2(inputBuffer, buffer, 0),
                getFirstSample2(inputBuffer, buffer, 1),
                getFirstSample2(inputBuffer, buffer, 2),
                getFirstSample2(inputBuffer, buffer, 3),
                getFirstSample2(inputBuffer, buffer, 4),
                getFirstSample2(inputBuffer, buffer, 5)
              ];
              if (orientation.some((value, index) => value !== lastOrientation[index])) {
                nativeListener.setOrientation(...orientation);
                lastOrientation = orientation;
              }
              const positon = [
                getFirstSample2(inputBuffer, buffer, 6),
                getFirstSample2(inputBuffer, buffer, 7),
                getFirstSample2(inputBuffer, buffer, 8)
              ];
              if (positon.some((value, index) => value !== lastPosition[index])) {
                nativeListener.setPosition(...positon);
                lastPosition = positon;
              }
            };
            channelMergerNode.connect(scriptProcessorNode);
          };
          const createSetOrientation = (index) => (value) => {
            if (value !== lastOrientation[index]) {
              lastOrientation[index] = value;
              nativeListener.setOrientation(...lastOrientation);
            }
          };
          const createSetPosition = (index) => (value) => {
            if (value !== lastPosition[index]) {
              lastPosition[index] = value;
              nativeListener.setPosition(...lastPosition);
            }
          };
          const createFakeAudioParam = (input, initialValue, setValue) => {
            const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              offset: initialValue
            });
            constantSourceNode.connect(channelMergerNode, 0, input);
            constantSourceNode.start();
            Object.defineProperty(constantSourceNode.offset, "defaultValue", {
              get() {
                return initialValue;
              }
            });
            const audioParam = createAudioParam2({ context }, isOffline, constantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
            overwriteAccessors2(audioParam, "value", (get) => () => get.call(audioParam), (set2) => (value) => {
              try {
                set2.call(audioParam, value);
              } catch (err) {
                if (err.code !== 9) {
                  throw err;
                }
              }
              createScriptProcessorNode();
              if (isOffline) {
                setValue(value);
              }
            });
            audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {
              if (isOffline) {
                return () => {
                  throw createNotSupportedError3();
                };
              }
              return (...args) => {
                const value = cancelAndHoldAtTime.apply(audioParam, args);
                createScriptProcessorNode();
                return value;
              };
            })(audioParam.cancelAndHoldAtTime);
            audioParam.cancelScheduledValues = ((cancelScheduledValues) => {
              if (isOffline) {
                return () => {
                  throw createNotSupportedError3();
                };
              }
              return (...args) => {
                const value = cancelScheduledValues.apply(audioParam, args);
                createScriptProcessorNode();
                return value;
              };
            })(audioParam.cancelScheduledValues);
            audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {
              if (isOffline) {
                return () => {
                  throw createNotSupportedError3();
                };
              }
              return (...args) => {
                const value = exponentialRampToValueAtTime.apply(audioParam, args);
                createScriptProcessorNode();
                return value;
              };
            })(audioParam.exponentialRampToValueAtTime);
            audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {
              if (isOffline) {
                return () => {
                  throw createNotSupportedError3();
                };
              }
              return (...args) => {
                const value = linearRampToValueAtTime.apply(audioParam, args);
                createScriptProcessorNode();
                return value;
              };
            })(audioParam.linearRampToValueAtTime);
            audioParam.setTargetAtTime = ((setTargetAtTime) => {
              if (isOffline) {
                return () => {
                  throw createNotSupportedError3();
                };
              }
              return (...args) => {
                const value = setTargetAtTime.apply(audioParam, args);
                createScriptProcessorNode();
                return value;
              };
            })(audioParam.setTargetAtTime);
            audioParam.setValueAtTime = ((setValueAtTime) => {
              if (isOffline) {
                return () => {
                  throw createNotSupportedError3();
                };
              }
              return (...args) => {
                const value = setValueAtTime.apply(audioParam, args);
                createScriptProcessorNode();
                return value;
              };
            })(audioParam.setValueAtTime);
            audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {
              if (isOffline) {
                return () => {
                  throw createNotSupportedError3();
                };
              }
              return (...args) => {
                const value = setValueCurveAtTime.apply(audioParam, args);
                createScriptProcessorNode();
                return value;
              };
            })(audioParam.setValueCurveAtTime);
            return audioParam;
          };
          return {
            forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),
            forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),
            forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),
            positionX: createFakeAudioParam(6, 0, createSetPosition(0)),
            positionY: createFakeAudioParam(7, 0, createSetPosition(1)),
            positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),
            upX: createFakeAudioParam(3, 0, createSetOrientation(3)),
            upY: createFakeAudioParam(4, 1, createSetOrientation(4)),
            upZ: createFakeAudioParam(5, 0, createSetOrientation(5))
          };
        };
        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } = nativeListener.forwardX === void 0 ? createFakeAudioParams() : nativeListener;
        return {
          get forwardX() {
            return forwardX;
          },
          get forwardY() {
            return forwardY;
          },
          get forwardZ() {
            return forwardZ;
          },
          get positionX() {
            return positionX;
          },
          get positionY() {
            return positionY;
          },
          get positionZ() {
            return positionZ;
          },
          get upX() {
            return upX;
          },
          get upY() {
            return upY;
          },
          get upZ() {
            return upZ;
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/audio-node.js
var isAudioNode;
var init_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/audio-node.js"() {
    isAudioNode = (audioNodeOrAudioParam) => {
      return "context" in audioNodeOrAudioParam;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js
var isAudioNodeOutputConnection;
var init_audio_node_output_connection = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/audio-node-output-connection.js"() {
    init_audio_node();
    isAudioNodeOutputConnection = (outputConnection) => {
      return isAudioNode(outputConnection[0]);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js
var insertElementInSet;
var init_insert_element_in_set = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/insert-element-in-set.js"() {
    insertElementInSet = (set2, element, predicate, ignoreDuplicates) => {
      for (const lmnt of set2) {
        if (predicate(lmnt)) {
          if (ignoreDuplicates) {
            return false;
          }
          throw Error("The set contains at least one similar element.");
        }
      }
      set2.add(element);
      return true;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/add-active-input-connection-to-audio-param.js
var addActiveInputConnectionToAudioParam;
var init_add_active_input_connection_to_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/add-active-input-connection-to-audio-param.js"() {
    init_insert_element_in_set();
    addActiveInputConnectionToAudioParam = (activeInputs, source, [output, eventListener], ignoreDuplicates) => {
      insertElementInSet(activeInputs, [source, output, eventListener], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output, ignoreDuplicates);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/add-passive-input-connection-to-audio-param.js
var addPassiveInputConnectionToAudioParam;
var init_add_passive_input_connection_to_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/add-passive-input-connection-to-audio-param.js"() {
    init_insert_element_in_set();
    addPassiveInputConnectionToAudioParam = (passiveInputs, [source, output, eventListener], ignoreDuplicates) => {
      const passiveInputConnections = passiveInputs.get(source);
      if (passiveInputConnections === void 0) {
        passiveInputs.set(source, /* @__PURE__ */ new Set([[output, eventListener]]));
      } else {
        insertElementInSet(passiveInputConnections, [output, eventListener], (passiveInputConnection) => passiveInputConnection[0] === output, ignoreDuplicates);
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js
var isNativeAudioNodeFaker;
var init_native_audio_node_faker = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/native-audio-node-faker.js"() {
    isNativeAudioNodeFaker = (nativeAudioNodeOrNativeAudioNodeFaker) => {
      return "inputs" in nativeAudioNodeOrNativeAudioNodeFaker;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js
var connectNativeAudioNodeToNativeAudioNode;
var init_connect_native_audio_node_to_native_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/connect-native-audio-node-to-native-audio-node.js"() {
    init_native_audio_node_faker();
    connectNativeAudioNodeToNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {
      if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];
        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);
        return [fakeNativeDestinationAudioNode, output, 0];
      }
      nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);
      return [nativeDestinationAudioNode, output, input];
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection.js
var deleteActiveInputConnection;
var init_delete_active_input_connection = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection.js"() {
    deleteActiveInputConnection = (activeInputConnections, source, output) => {
      for (const activeInputConnection of activeInputConnections) {
        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {
          activeInputConnections.delete(activeInputConnection);
          return activeInputConnection;
        }
      }
      return null;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection-to-audio-param.js
var deleteActiveInputConnectionToAudioParam;
var init_delete_active_input_connection_to_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/delete-active-input-connection-to-audio-param.js"() {
    init_pick_element_from_set();
    deleteActiveInputConnectionToAudioParam = (activeInputs, source, output) => {
      return pickElementFromSet(activeInputs, (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js
var deleteEventListenerOfAudioNode;
var init_delete_event_listeners_of_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/delete-event-listeners-of-audio-node.js"() {
    init_get_event_listeners_of_audio_node();
    deleteEventListenerOfAudioNode = (audioNode, eventListener) => {
      const eventListeners = getEventListenersOfAudioNode(audioNode);
      if (!eventListeners.delete(eventListener)) {
        throw new Error("Missing the expected event listener.");
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-param.js
var deletePassiveInputConnectionToAudioParam;
var init_delete_passive_input_connection_to_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/delete-passive-input-connection-to-audio-param.js"() {
    init_get_value_for_key();
    init_pick_element_from_set();
    deletePassiveInputConnectionToAudioParam = (passiveInputs, source, output) => {
      const passiveInputConnections = getValueForKey(passiveInputs, source);
      const matchingConnection = pickElementFromSet(passiveInputConnections, (passiveInputConnection) => passiveInputConnection[0] === output);
      if (passiveInputConnections.size === 0) {
        passiveInputs.delete(source);
      }
      return matchingConnection;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js
var disconnectNativeAudioNodeFromNativeAudioNode;
var init_disconnect_native_audio_node_from_native_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/disconnect-native-audio-node-from-native-audio-node.js"() {
    init_native_audio_node_faker();
    disconnectNativeAudioNodeFromNativeAudioNode = (nativeSourceAudioNode, nativeDestinationAudioNode, output, input) => {
      if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {
        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);
      } else {
        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js
var getNativeAudioNode;
var init_get_native_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-node.js"() {
    init_globals();
    init_get_value_for_key();
    getNativeAudioNode = (audioNode) => {
      return getValueForKey(AUDIO_NODE_STORE, audioNode);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js
var getNativeAudioParam;
var init_get_native_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/get-native-audio-param.js"() {
    init_globals();
    init_get_value_for_key();
    getNativeAudioParam = (audioParam) => {
      return getValueForKey(AUDIO_PARAM_STORE, audioParam);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js
var isPartOfACycle;
var init_is_part_of_a_cycle = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/is-part-of-a-cycle.js"() {
    init_globals();
    isPartOfACycle = (audioNode) => {
      return CYCLE_COUNTERS.has(audioNode);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js
var isPassiveAudioNode;
var init_is_passive_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/is-passive-audio-node.js"() {
    init_globals();
    isPassiveAudioNode = (audioNode) => {
      return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js
var testAudioNodeDisconnectMethodSupport;
var init_test_audio_node_disconnect_method_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-audio-node-disconnect-method-support.js"() {
    testAudioNodeDisconnectMethodSupport = (nativeAudioContext, nativeAudioWorkletNodeConstructor2) => {
      return new Promise((resolve) => {
        if (nativeAudioWorkletNodeConstructor2 !== null) {
          resolve(true);
        } else {
          const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1);
          const dummy = nativeAudioContext.createGain();
          const ones = nativeAudioContext.createBuffer(1, 2, 44100);
          const channelData = ones.getChannelData(0);
          channelData[0] = 1;
          channelData[1] = 1;
          const source = nativeAudioContext.createBufferSource();
          source.buffer = ones;
          source.loop = true;
          source.connect(analyzer).connect(nativeAudioContext.destination);
          source.connect(dummy);
          source.disconnect(dummy);
          analyzer.onaudioprocess = (event) => {
            const chnnlDt = event.inputBuffer.getChannelData(0);
            if (Array.prototype.some.call(chnnlDt, (sample) => sample === 1)) {
              resolve(true);
            } else {
              resolve(false);
            }
            source.stop();
            analyzer.onaudioprocess = null;
            source.disconnect(analyzer);
            analyzer.disconnect(nativeAudioContext.destination);
          };
          source.start();
        }
      });
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js
var visitEachAudioNodeOnce;
var init_visit_each_audio_node_once = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/visit-each-audio-node-once.js"() {
    visitEachAudioNodeOnce = (cycles, visitor) => {
      const counts = /* @__PURE__ */ new Map();
      for (const cycle of cycles) {
        for (const audioNode of cycle) {
          const count = counts.get(audioNode);
          counts.set(audioNode, count === void 0 ? 1 : count + 1);
        }
      }
      counts.forEach((count, audioNode) => visitor(audioNode, count));
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js
var isNativeAudioNode;
var init_native_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/native-audio-node.js"() {
    isNativeAudioNode = (nativeAudioNodeOrAudioParam) => {
      return "context" in nativeAudioNodeOrAudioParam;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js
var wrapAudioNodeDisconnectMethod;
var init_wrap_audio_node_disconnect_method = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-node-disconnect-method.js"() {
    init_native_audio_node();
    wrapAudioNodeDisconnectMethod = (nativeAudioNode) => {
      const connections = /* @__PURE__ */ new Map();
      nativeAudioNode.connect = /* @__PURE__ */ ((connect3) => {
        return (destination, output = 0, input = 0) => {
          const returnValue = isNativeAudioNode(destination) ? connect3(destination, output, input) : connect3(destination, output);
          const connectionsToDestination = connections.get(destination);
          if (connectionsToDestination === void 0) {
            connections.set(destination, [{ input, output }]);
          } else {
            if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {
              connectionsToDestination.push({ input, output });
            }
          }
          return returnValue;
        };
      })(nativeAudioNode.connect.bind(nativeAudioNode));
      nativeAudioNode.disconnect = /* @__PURE__ */ ((disconnect3) => {
        return (destinationOrOutput, output, input) => {
          disconnect3.apply(nativeAudioNode);
          if (destinationOrOutput === void 0) {
            connections.clear();
          } else if (typeof destinationOrOutput === "number") {
            for (const [destination, connectionsToDestination] of connections) {
              const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);
              if (filteredConnections.length === 0) {
                connections.delete(destination);
              } else {
                connections.set(destination, filteredConnections);
              }
            }
          } else if (connections.has(destinationOrOutput)) {
            if (output === void 0) {
              connections.delete(destinationOrOutput);
            } else {
              const connectionsToDestination = connections.get(destinationOrOutput);
              if (connectionsToDestination !== void 0) {
                const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== output && (connection.input !== input || input === void 0));
                if (filteredConnections.length === 0) {
                  connections.delete(destinationOrOutput);
                } else {
                  connections.set(destinationOrOutput, filteredConnections);
                }
              }
            }
          }
          for (const [destination, connectionsToDestination] of connections) {
            connectionsToDestination.forEach((connection) => {
              if (isNativeAudioNode(destination)) {
                nativeAudioNode.connect(destination, connection.output, connection.input);
              } else {
                nativeAudioNode.connect(destination, connection.output);
              }
            });
          }
        };
      })(nativeAudioNode.disconnect);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js
var addConnectionToAudioParamOfAudioContext, deleteInputConnectionOfAudioNode, deleteInputConnectionOfAudioParam, deleteInputsOfAudioNode, deleteInputsOfAudioParam, deleteAnyConnection, deleteConnectionAtOutput, deleteConnectionToDestination, createAudioNodeConstructor;
var init_audio_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-node-constructor.js"() {
    init_globals();
    init_audio_node();
    init_audio_node_output_connection();
    init_add_active_input_connection_to_audio_param();
    init_add_passive_input_connection_to_audio_param();
    init_connect_native_audio_node_to_native_audio_node();
    init_delete_active_input_connection();
    init_delete_active_input_connection_to_audio_param();
    init_delete_event_listeners_of_audio_node();
    init_delete_passive_input_connection_to_audio_node();
    init_delete_passive_input_connection_to_audio_param();
    init_disconnect_native_audio_node_from_native_audio_node();
    init_get_audio_node_connections();
    init_get_audio_param_connections();
    init_get_event_listeners_of_audio_node();
    init_get_native_audio_node();
    init_get_native_audio_param();
    init_insert_element_in_set();
    init_is_active_audio_node();
    init_is_part_of_a_cycle();
    init_is_passive_audio_node();
    init_set_internal_state_to_active();
    init_set_internal_state_to_passive_when_necessary();
    init_test_audio_node_disconnect_method_support();
    init_visit_each_audio_node_once();
    init_wrap_audio_node_disconnect_method();
    addConnectionToAudioParamOfAudioContext = (source, destination, output, isOffline) => {
      const { activeInputs, passiveInputs } = getAudioParamConnections(destination);
      const { outputs } = getAudioNodeConnections(source);
      const eventListeners = getEventListenersOfAudioNode(source);
      const eventListener = (isActive) => {
        const nativeAudioNode = getNativeAudioNode(source);
        const nativeAudioParam = getNativeAudioParam(destination);
        if (isActive) {
          const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);
          addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);
          if (!isOffline && !isPartOfACycle(source)) {
            nativeAudioNode.connect(nativeAudioParam, output);
          }
        } else {
          const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);
          addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);
          if (!isOffline && !isPartOfACycle(source)) {
            nativeAudioNode.disconnect(nativeAudioParam, output);
          }
        }
      };
      if (insertElementInSet(outputs, [destination, output], (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output, true)) {
        eventListeners.add(eventListener);
        if (isActiveAudioNode(source)) {
          addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);
        } else {
          addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);
        }
        return true;
      }
      return false;
    };
    deleteInputConnectionOfAudioNode = (source, destination, output, input) => {
      const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);
      const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);
      if (activeInputConnection === null) {
        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);
        return [passiveInputConnection[2], false];
      }
      return [activeInputConnection[2], true];
    };
    deleteInputConnectionOfAudioParam = (source, destination, output) => {
      const { activeInputs, passiveInputs } = getAudioParamConnections(destination);
      const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);
      if (activeInputConnection === null) {
        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);
        return [passiveInputConnection[1], false];
      }
      return [activeInputConnection[2], true];
    };
    deleteInputsOfAudioNode = (source, isOffline, destination, output, input) => {
      const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);
      if (listener !== null) {
        deleteEventListenerOfAudioNode(source, listener);
        if (isActive && !isOffline && !isPartOfACycle(source)) {
          disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);
        }
      }
      if (isActiveAudioNode(destination)) {
        const { activeInputs } = getAudioNodeConnections(destination);
        setInternalStateToPassiveWhenNecessary(destination, activeInputs);
      }
    };
    deleteInputsOfAudioParam = (source, isOffline, destination, output) => {
      const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);
      if (listener !== null) {
        deleteEventListenerOfAudioNode(source, listener);
        if (isActive && !isOffline && !isPartOfACycle(source)) {
          getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);
        }
      }
    };
    deleteAnyConnection = (source, isOffline) => {
      const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
      const destinations = [];
      for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
        if (isAudioNodeOutputConnection(outputConnection)) {
          deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
        } else {
          deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
        }
        destinations.push(outputConnection[0]);
      }
      audioNodeConnectionsOfSource.outputs.clear();
      return destinations;
    };
    deleteConnectionAtOutput = (source, isOffline, output) => {
      const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
      const destinations = [];
      for (const outputConnection of audioNodeConnectionsOfSource.outputs) {
        if (outputConnection[1] === output) {
          if (isAudioNodeOutputConnection(outputConnection)) {
            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
          } else {
            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
          }
          destinations.push(outputConnection[0]);
          audioNodeConnectionsOfSource.outputs.delete(outputConnection);
        }
      }
      return destinations;
    };
    deleteConnectionToDestination = (source, isOffline, destination, output, input) => {
      const audioNodeConnectionsOfSource = getAudioNodeConnections(source);
      return Array.from(audioNodeConnectionsOfSource.outputs).filter((outputConnection) => outputConnection[0] === destination && (output === void 0 || outputConnection[1] === output) && (input === void 0 || outputConnection[2] === input)).map((outputConnection) => {
        if (isAudioNodeOutputConnection(outputConnection)) {
          deleteInputsOfAudioNode(source, isOffline, ...outputConnection);
        } else {
          deleteInputsOfAudioParam(source, isOffline, ...outputConnection);
        }
        audioNodeConnectionsOfSource.outputs.delete(outputConnection);
        return outputConnection[0];
      });
    };
    createAudioNodeConstructor = (addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult2, createIncrementCycleCounter, createIndexSizeError2, createInvalidAccessError2, createNotSupportedError3, decrementCycleCounter, detectCycles, eventTargetConstructor2, getNativeContext2, isNativeAudioContext2, isNativeAudioNode3, isNativeAudioParam2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2) => {
      return class AudioNode extends eventTargetConstructor2 {
        constructor(context, isActive, nativeAudioNode, audioNodeRenderer) {
          super(nativeAudioNode);
          this._context = context;
          this._nativeAudioNode = nativeAudioNode;
          const nativeContext = getNativeContext2(context);
          if (isNativeAudioContext2(nativeContext) && true !== cacheTestResult2(testAudioNodeDisconnectMethodSupport, () => {
            return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor2);
          })) {
            wrapAudioNodeDisconnectMethod(nativeAudioNode);
          }
          AUDIO_NODE_STORE.set(this, nativeAudioNode);
          EVENT_LISTENERS.set(this, /* @__PURE__ */ new Set());
          if (context.state !== "closed" && isActive) {
            setInternalStateToActive(this);
          }
          addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);
        }
        get channelCount() {
          return this._nativeAudioNode.channelCount;
        }
        set channelCount(value) {
          this._nativeAudioNode.channelCount = value;
        }
        get channelCountMode() {
          return this._nativeAudioNode.channelCountMode;
        }
        set channelCountMode(value) {
          this._nativeAudioNode.channelCountMode = value;
        }
        get channelInterpretation() {
          return this._nativeAudioNode.channelInterpretation;
        }
        set channelInterpretation(value) {
          this._nativeAudioNode.channelInterpretation = value;
        }
        get context() {
          return this._context;
        }
        get numberOfInputs() {
          return this._nativeAudioNode.numberOfInputs;
        }
        get numberOfOutputs() {
          return this._nativeAudioNode.numberOfOutputs;
        }
        // tslint:disable-next-line:invalid-void
        connect(destination, output = 0, input = 0) {
          if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {
            throw createIndexSizeError2();
          }
          const nativeContext = getNativeContext2(this._context);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          if (isNativeAudioNode3(destination) || isNativeAudioParam2(destination)) {
            throw createInvalidAccessError2();
          }
          if (isAudioNode(destination)) {
            const nativeDestinationAudioNode = getNativeAudioNode(destination);
            try {
              const connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);
              const isPassive = isPassiveAudioNode(this);
              if (isOffline || isPassive) {
                this._nativeAudioNode.disconnect(...connection);
              }
              if (this.context.state !== "closed" && !isPassive && isPassiveAudioNode(destination)) {
                setInternalStateToActive(destination);
              }
            } catch (err) {
              if (err.code === 12) {
                throw createInvalidAccessError2();
              }
              throw err;
            }
            const isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);
            if (isNewConnectionToAudioNode) {
              const cycles = detectCycles([this], destination);
              visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
            }
            return destination;
          }
          const nativeAudioParam = getNativeAudioParam(destination);
          if (nativeAudioParam.name === "playbackRate" && nativeAudioParam.maxValue === 1024) {
            throw createNotSupportedError3();
          }
          try {
            this._nativeAudioNode.connect(nativeAudioParam, output);
            if (isOffline || isPassiveAudioNode(this)) {
              this._nativeAudioNode.disconnect(nativeAudioParam, output);
            }
          } catch (err) {
            if (err.code === 12) {
              throw createInvalidAccessError2();
            }
            throw err;
          }
          const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);
          if (isNewConnectionToAudioParam) {
            const cycles = detectCycles([this], destination);
            visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));
          }
        }
        disconnect(destinationOrOutput, output, input) {
          let destinations;
          const nativeContext = getNativeContext2(this._context);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          if (destinationOrOutput === void 0) {
            destinations = deleteAnyConnection(this, isOffline);
          } else if (typeof destinationOrOutput === "number") {
            if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {
              throw createIndexSizeError2();
            }
            destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);
          } else {
            if (output !== void 0 && (output < 0 || output >= this.numberOfOutputs)) {
              throw createIndexSizeError2();
            }
            if (isAudioNode(destinationOrOutput) && input !== void 0 && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {
              throw createIndexSizeError2();
            }
            destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);
            if (destinations.length === 0) {
              throw createInvalidAccessError2();
            }
          }
          for (const destination of destinations) {
            const cycles = detectCycles([this], destination);
            visitEachAudioNodeOnce(cycles, decrementCycleCounter);
          }
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js
var createAudioParamFactory;
var init_audio_param_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-param-factory.js"() {
    init_module10();
    createAudioParamFactory = (addAudioParamConnections, audioParamAudioNodeStore2, audioParamStore, createAudioParamRenderer2, createCancelAndHoldAutomationEvent2, createCancelScheduledValuesAutomationEvent2, createExponentialRampToValueAutomationEvent2, createLinearRampToValueAutomationEvent2, createSetTargetAutomationEvent2, createSetValueAutomationEvent2, createSetValueCurveAutomationEvent2, nativeAudioContextConstructor2, setValueAtTimeUntilPossible2) => {
      return (audioNode, isAudioParamOfOfflineAudioContext, nativeAudioParam, maxValue = null, minValue = null) => {
        const defaultValue = nativeAudioParam.value;
        const automationEventList = new AutomationEventList(defaultValue);
        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer2(automationEventList) : null;
        const audioParam = {
          get defaultValue() {
            return defaultValue;
          },
          get maxValue() {
            return maxValue === null ? nativeAudioParam.maxValue : maxValue;
          },
          get minValue() {
            return minValue === null ? nativeAudioParam.minValue : minValue;
          },
          get value() {
            return nativeAudioParam.value;
          },
          set value(value) {
            nativeAudioParam.value = value;
            audioParam.setValueAtTime(value, audioNode.context.currentTime);
          },
          cancelAndHoldAtTime(cancelTime) {
            if (typeof nativeAudioParam.cancelAndHoldAtTime === "function") {
              if (audioParamRenderer === null) {
                automationEventList.flush(audioNode.context.currentTime);
              }
              automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));
              nativeAudioParam.cancelAndHoldAtTime(cancelTime);
            } else {
              const previousLastEvent = Array.from(automationEventList).pop();
              if (audioParamRenderer === null) {
                automationEventList.flush(audioNode.context.currentTime);
              }
              automationEventList.add(createCancelAndHoldAutomationEvent2(cancelTime));
              const currentLastEvent = Array.from(automationEventList).pop();
              nativeAudioParam.cancelScheduledValues(cancelTime);
              if (previousLastEvent !== currentLastEvent && currentLastEvent !== void 0) {
                if (currentLastEvent.type === "exponentialRampToValue") {
                  nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
                } else if (currentLastEvent.type === "linearRampToValue") {
                  nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);
                } else if (currentLastEvent.type === "setValue") {
                  nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);
                } else if (currentLastEvent.type === "setValueCurve") {
                  nativeAudioParam.setValueCurveAtTime(currentLastEvent.values, currentLastEvent.startTime, currentLastEvent.duration);
                }
              }
            }
            return audioParam;
          },
          cancelScheduledValues(cancelTime) {
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createCancelScheduledValuesAutomationEvent2(cancelTime));
            nativeAudioParam.cancelScheduledValues(cancelTime);
            return audioParam;
          },
          exponentialRampToValueAtTime(value, endTime) {
            if (value === 0) {
              throw new RangeError();
            }
            if (!Number.isFinite(endTime) || endTime < 0) {
              throw new RangeError();
            }
            const currentTime = audioNode.context.currentTime;
            if (audioParamRenderer === null) {
              automationEventList.flush(currentTime);
            }
            if (Array.from(automationEventList).length === 0) {
              automationEventList.add(createSetValueAutomationEvent2(defaultValue, currentTime));
              nativeAudioParam.setValueAtTime(defaultValue, currentTime);
            }
            automationEventList.add(createExponentialRampToValueAutomationEvent2(value, endTime));
            nativeAudioParam.exponentialRampToValueAtTime(value, endTime);
            return audioParam;
          },
          linearRampToValueAtTime(value, endTime) {
            const currentTime = audioNode.context.currentTime;
            if (audioParamRenderer === null) {
              automationEventList.flush(currentTime);
            }
            if (Array.from(automationEventList).length === 0) {
              automationEventList.add(createSetValueAutomationEvent2(defaultValue, currentTime));
              nativeAudioParam.setValueAtTime(defaultValue, currentTime);
            }
            automationEventList.add(createLinearRampToValueAutomationEvent2(value, endTime));
            nativeAudioParam.linearRampToValueAtTime(value, endTime);
            return audioParam;
          },
          setTargetAtTime(target, startTime, timeConstant) {
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createSetTargetAutomationEvent2(target, startTime, timeConstant));
            nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);
            return audioParam;
          },
          setValueAtTime(value, startTime) {
            if (audioParamRenderer === null) {
              automationEventList.flush(audioNode.context.currentTime);
            }
            automationEventList.add(createSetValueAutomationEvent2(value, startTime));
            nativeAudioParam.setValueAtTime(value, startTime);
            return audioParam;
          },
          setValueCurveAtTime(values, startTime, duration3) {
            const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);
            if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext") {
              const endTime = startTime + duration3;
              const sampleRate = audioNode.context.sampleRate;
              const firstSample = Math.ceil(startTime * sampleRate);
              const lastSample = Math.floor(endTime * sampleRate);
              const numberOfInterpolatedValues = lastSample - firstSample;
              const interpolatedValues = new Float32Array(numberOfInterpolatedValues);
              for (let i = 0; i < numberOfInterpolatedValues; i += 1) {
                const theoreticIndex = (convertedValues.length - 1) / duration3 * ((firstSample + i) / sampleRate - startTime);
                const lowerIndex = Math.floor(theoreticIndex);
                const upperIndex = Math.ceil(theoreticIndex);
                interpolatedValues[i] = lowerIndex === upperIndex ? convertedValues[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];
              }
              if (audioParamRenderer === null) {
                automationEventList.flush(audioNode.context.currentTime);
              }
              automationEventList.add(createSetValueCurveAutomationEvent2(interpolatedValues, startTime, duration3));
              nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration3);
              const timeOfLastSample = lastSample / sampleRate;
              if (timeOfLastSample < endTime) {
                setValueAtTimeUntilPossible2(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);
              }
              setValueAtTimeUntilPossible2(audioParam, convertedValues[convertedValues.length - 1], endTime);
            } else {
              if (audioParamRenderer === null) {
                automationEventList.flush(audioNode.context.currentTime);
              }
              automationEventList.add(createSetValueCurveAutomationEvent2(convertedValues, startTime, duration3));
              nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration3);
            }
            return audioParam;
          }
        };
        audioParamStore.set(audioParam, nativeAudioParam);
        audioParamAudioNodeStore2.set(audioParam, audioNode);
        addAudioParamConnections(audioParam, audioParamRenderer);
        return audioParam;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js
var createAudioParamRenderer;
var init_audio_param_renderer = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-param-renderer.js"() {
    createAudioParamRenderer = (automationEventList) => {
      return {
        replay(audioParam) {
          for (const automationEvent of automationEventList) {
            if (automationEvent.type === "exponentialRampToValue") {
              const { endTime, value } = automationEvent;
              audioParam.exponentialRampToValueAtTime(value, endTime);
            } else if (automationEvent.type === "linearRampToValue") {
              const { endTime, value } = automationEvent;
              audioParam.linearRampToValueAtTime(value, endTime);
            } else if (automationEvent.type === "setTarget") {
              const { startTime, target, timeConstant } = automationEvent;
              audioParam.setTargetAtTime(target, startTime, timeConstant);
            } else if (automationEvent.type === "setValue") {
              const { startTime, value } = automationEvent;
              audioParam.setValueAtTime(value, startTime);
            } else if (automationEvent.type === "setValueCurve") {
              const { duration: duration3, startTime, values } = automationEvent;
              audioParam.setValueCurveAtTime(values, startTime, duration3);
            } else {
              throw new Error("Can't apply an unknown automation.");
            }
          }
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/read-only-map.js
var ReadOnlyMap;
var init_read_only_map = __esm({
  "node_modules/standardized-audio-context/build/es2019/read-only-map.js"() {
    ReadOnlyMap = class {
      constructor(parameters) {
        this._map = new Map(parameters);
      }
      get size() {
        return this._map.size;
      }
      entries() {
        return this._map.entries();
      }
      forEach(callback, thisArg = null) {
        return this._map.forEach((value, key) => callback.call(thisArg, value, key, this));
      }
      get(name) {
        return this._map.get(name);
      }
      has(name) {
        return this._map.has(name);
      }
      keys() {
        return this._map.keys();
      }
      values() {
        return this._map.values();
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js
var DEFAULT_OPTIONS4, createAudioWorkletNodeConstructor;
var init_audio_worklet_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-constructor.js"() {
    init_globals();
    init_read_only_map();
    DEFAULT_OPTIONS4 = {
      channelCount: 2,
      // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: 1,
      numberOfOutputs: 1,
      parameterData: {},
      processorOptions: {}
    };
    createAudioWorkletNodeConstructor = (addUnrenderedAudioWorkletNode2, audioNodeConstructor2, createAudioParam2, createAudioWorkletNodeRenderer2, createNativeAudioWorkletNode2, getAudioNodeConnections2, getBackupOfflineAudioContext2, getNativeContext2, isNativeOfflineAudioContext2, nativeAudioWorkletNodeConstructor2, sanitizeAudioWorkletNodeOptions2, setActiveAudioWorkletNodeInputs2, testAudioWorkletNodeOptionsClonability2, wrapEventListener3) => {
      return class AudioWorkletNode extends audioNodeConstructor2 {
        constructor(context, name, options) {
          var _a13;
          const nativeContext = getNativeContext2(context);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const mergedOptions = sanitizeAudioWorkletNodeOptions2({ ...DEFAULT_OPTIONS4, ...options });
          testAudioWorkletNodeOptionsClonability2(mergedOptions);
          const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);
          const processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);
          const nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== "closed" ? nativeContext : (_a13 = getBackupOfflineAudioContext2(nativeContext)) !== null && _a13 !== void 0 ? _a13 : nativeContext;
          const nativeAudioWorkletNode = createNativeAudioWorkletNode2(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor2, name, processorConstructor, mergedOptions);
          const audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer2(name, mergedOptions, processorConstructor) : null;
          super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);
          const parameters = [];
          nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {
            const audioParam = createAudioParam2(this, isOffline, nativeAudioParam);
            parameters.push([nm, audioParam]);
          });
          this._nativeAudioWorkletNode = nativeAudioWorkletNode;
          this._onprocessorerror = null;
          this._parameters = new ReadOnlyMap(parameters);
          if (isOffline) {
            addUnrenderedAudioWorkletNode2(nativeContext, this);
          }
          const { activeInputs } = getAudioNodeConnections2(this);
          setActiveAudioWorkletNodeInputs2(nativeAudioWorkletNode, activeInputs);
        }
        get onprocessorerror() {
          return this._onprocessorerror;
        }
        set onprocessorerror(value) {
          const wrappedListener = typeof value === "function" ? wrapEventListener3(this, value) : null;
          this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;
          const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;
          this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;
        }
        get parameters() {
          if (this._parameters === null) {
            return this._nativeAudioWorkletNode.parameters;
          }
          return this._parameters;
        }
        get port() {
          return this._nativeAudioWorkletNode.port;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js
function copyFromChannel(audioBuffer, parent, key, channelNumber, bufferOffset) {
  if (typeof audioBuffer.copyFromChannel === "function") {
    if (parent[key].byteLength === 0) {
      parent[key] = new Float32Array(128);
    }
    audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);
  } else {
    const channelData = audioBuffer.getChannelData(channelNumber);
    if (parent[key].byteLength === 0) {
      parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);
    } else {
      const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);
      parent[key].set(slicedInput);
    }
  }
}
var init_copy_from_channel = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/copy-from-channel.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js
var copyToChannel;
var init_copy_to_channel = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/copy-to-channel.js"() {
    copyToChannel = (audioBuffer, parent, key, channelNumber, bufferOffset) => {
      if (typeof audioBuffer.copyToChannel === "function") {
        if (parent[key].byteLength !== 0) {
          audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);
        }
      } else {
        if (parent[key].byteLength !== 0) {
          audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);
        }
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js
var createNestedArrays;
var init_create_nested_arrays = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/create-nested-arrays.js"() {
    createNestedArrays = (x, y) => {
      const arrays = [];
      for (let i = 0; i < x; i += 1) {
        const array2 = [];
        const length = typeof y === "number" ? y : y[i];
        for (let j = 0; j < length; j += 1) {
          array2.push(new Float32Array(128));
        }
        arrays.push(array2);
      }
      return arrays;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js
var getAudioWorkletProcessor;
var init_get_audio_worklet_processor = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/get-audio-worklet-processor.js"() {
    init_globals();
    init_get_native_audio_node();
    init_get_value_for_key();
    getAudioWorkletProcessor = (nativeOfflineAudioContext, proxy) => {
      const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);
      const nativeAudioWorkletNode = getNativeAudioNode(proxy);
      return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js
var processBuffer, createAudioWorkletNodeRendererFactory;
var init_audio_worklet_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/audio-worklet-node-renderer-factory.js"() {
    init_copy_from_channel();
    init_copy_to_channel();
    init_create_nested_arrays();
    init_get_audio_node_connections();
    init_get_audio_worklet_processor();
    init_is_owned_by_context();
    processBuffer = async (proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2) => {
      const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;
      const numberOfInputChannels = options.channelCount * options.numberOfInputs;
      const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
      const processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);
      if (processorConstructor === void 0) {
        throw new Error("Missing the processor constructor.");
      }
      const audioNodeConnections = getAudioNodeConnections(proxy);
      const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);
      const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);
      const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);
      const parameters = Array.from(proxy.parameters.keys()).reduce((prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});
      for (let i = 0; i < length; i += 128) {
        if (options.numberOfInputs > 0 && renderedBuffer !== null) {
          for (let j = 0; j < options.numberOfInputs; j += 1) {
            for (let k = 0; k < options.channelCount; k += 1) {
              copyFromChannel(renderedBuffer, inputs[j], k, k, i);
            }
          }
        }
        if (processorConstructor.parameterDescriptors !== void 0 && renderedBuffer !== null) {
          processorConstructor.parameterDescriptors.forEach(({ name }, index) => {
            copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);
          });
        }
        for (let j = 0; j < options.numberOfInputs; j += 1) {
          for (let k = 0; k < outputChannelCount[j]; k += 1) {
            if (outputs[j][k].byteLength === 0) {
              outputs[j][k] = new Float32Array(128);
            }
          }
        }
        try {
          const potentiallyEmptyInputs = inputs.map((input, index) => {
            if (audioNodeConnections.activeInputs[index].size === 0) {
              return [];
            }
            return input;
          });
          const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));
          if (processedBuffer !== null) {
            for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {
              for (let k = 0; k < outputChannelCount[j]; k += 1) {
                copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);
              }
              outputChannelSplitterNodeOutput += outputChannelCount[j];
            }
          }
          if (!activeSourceFlag) {
            break;
          }
        } catch (error) {
          proxy.dispatchEvent(new ErrorEvent("processorerror", {
            colno: error.colno,
            filename: error.filename,
            lineno: error.lineno,
            message: error.message
          }));
          break;
        }
      }
      return processedBuffer;
    };
    createAudioWorkletNodeRendererFactory = (connectAudioParam2, connectMultipleOutputs2, createNativeAudioBufferSourceNode2, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, deleteUnrenderedAudioWorkletNode2, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getNativeAudioNode2, nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
      return (name, options, processorConstructor) => {
        const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
        let processedBufferPromise = null;
        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeAudioWorkletNode = getNativeAudioNode2(proxy);
          let nativeOutputNodes = null;
          const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);
          const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);
          if (nativeAudioWorkletNodeConstructor2 === null) {
            const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
            const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, {
              channelCount: Math.max(1, numberOfOutputChannels),
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              numberOfOutputs: Math.max(1, numberOfOutputChannels)
            });
            const outputChannelMergerNodes = [];
            for (let i = 0; i < proxy.numberOfOutputs; i += 1) {
              outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "speakers",
                numberOfInputs: outputChannelCount[i]
              }));
            }
            const outputGainNode = createNativeGainNode2(nativeOfflineAudioContext, {
              channelCount: options.channelCount,
              channelCountMode: options.channelCountMode,
              channelInterpretation: options.channelInterpretation,
              gain: 1
            });
            outputGainNode.connect = connectMultipleOutputs2.bind(null, outputChannelMergerNodes);
            outputGainNode.disconnect = disconnectMultipleOutputs2.bind(null, outputChannelMergerNodes);
            nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];
          } else if (!nativeAudioWorkletNodeIsOwnedByContext) {
            nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeOfflineAudioContext, name);
          }
          renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);
          if (nativeOutputNodes !== null) {
            if (processedBufferPromise === null) {
              if (processorConstructor === void 0) {
                throw new Error("Missing the processor constructor.");
              }
              if (nativeOfflineAudioContextConstructor2 === null) {
                throw new Error("Missing the native OfflineAudioContext constructor.");
              }
              const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;
              const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;
              const numberOfChannels = numberOfInputChannels + numberOfParameters;
              const renderBuffer = async () => {
                const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(
                  numberOfChannels,
                  // Ceil the length to the next full render quantum.
                  // Bug #17: Safari does not yet expose the length.
                  Math.ceil(proxy.context.length / 128) * 128,
                  nativeOfflineAudioContext.sampleRate
                );
                const gainNodes = [];
                const inputChannelSplitterNodes = [];
                for (let i = 0; i < options.numberOfInputs; i += 1) {
                  gainNodes.push(createNativeGainNode2(partialOfflineAudioContext, {
                    channelCount: options.channelCount,
                    channelCountMode: options.channelCountMode,
                    channelInterpretation: options.channelInterpretation,
                    gain: 1
                  }));
                  inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(partialOfflineAudioContext, {
                    channelCount: options.channelCount,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    numberOfOutputs: options.channelCount
                  }));
                }
                const constantSourceNodes = await Promise.all(Array.from(proxy.parameters.values()).map(async (audioParam) => {
                  const constantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    offset: audioParam.value
                  });
                  await renderAutomation2(partialOfflineAudioContext, audioParam, constantSourceNode.offset);
                  return constantSourceNode;
                }));
                const inputChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {
                  channelCount: 1,
                  channelCountMode: "explicit",
                  channelInterpretation: "speakers",
                  numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
                });
                for (let i = 0; i < options.numberOfInputs; i += 1) {
                  gainNodes[i].connect(inputChannelSplitterNodes[i]);
                  for (let j = 0; j < options.channelCount; j += 1) {
                    inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);
                  }
                }
                for (const [index, constantSourceNode] of constantSourceNodes.entries()) {
                  constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);
                  constantSourceNode.start(0);
                }
                inputChannelMergerNode.connect(partialOfflineAudioContext.destination);
                await Promise.all(gainNodes.map((gainNode) => renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, gainNode)));
                return renderNativeOfflineAudioContext2(partialOfflineAudioContext);
              };
              processedBufferPromise = processBuffer(proxy, numberOfChannels === 0 ? null : await renderBuffer(), nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime2);
            }
            const processedBuffer = await processedBufferPromise;
            const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {
              buffer: null,
              channelCount: 2,
              channelCountMode: "max",
              channelInterpretation: "speakers",
              loop: false,
              loopEnd: 0,
              loopStart: 0,
              playbackRate: 1
            });
            const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;
            if (processedBuffer !== null) {
              audioBufferSourceNode.buffer = processedBuffer;
              audioBufferSourceNode.start(0);
            }
            audioBufferSourceNode.connect(outputChannelSplitterNode);
            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {
              const outputChannelMergerNode = outputChannelMergerNodes[i];
              for (let j = 0; j < outputChannelCount[i]; j += 1) {
                outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);
              }
              outputChannelSplitterNodeOutput += outputChannelCount[i];
            }
            return outputGainNode;
          }
          if (!nativeAudioWorkletNodeIsOwnedByContext) {
            for (const [nm, audioParam] of proxy.parameters.entries()) {
              await renderAutomation2(
                nativeOfflineAudioContext,
                audioParam,
                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
                nativeAudioWorkletNode.parameters.get(nm)
              );
            }
          } else {
            for (const [nm, audioParam] of proxy.parameters.entries()) {
              await connectAudioParam2(
                nativeOfflineAudioContext,
                audioParam,
                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.
                nativeAudioWorkletNode.parameters.get(nm)
              );
            }
          }
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);
          return nativeAudioWorkletNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            deleteUnrenderedAudioWorkletNode2(nativeOfflineAudioContext, proxy);
            const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
            if (renderedNativeAudioWorkletNodeOrGainNode !== void 0) {
              return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);
            }
            return createAudioNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js
var createBaseAudioContextConstructor;
var init_base_audio_context_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/base-audio-context-constructor.js"() {
    createBaseAudioContextConstructor = (addAudioWorkletModule2, analyserNodeConstructor2, audioBufferConstructor2, audioBufferSourceNodeConstructor2, biquadFilterNodeConstructor2, channelMergerNodeConstructor2, channelSplitterNodeConstructor2, constantSourceNodeConstructor2, convolverNodeConstructor2, decodeAudioData2, delayNodeConstructor2, dynamicsCompressorNodeConstructor2, gainNodeConstructor2, iIRFilterNodeConstructor2, minimalBaseAudioContextConstructor2, oscillatorNodeConstructor2, pannerNodeConstructor2, periodicWaveConstructor2, stereoPannerNodeConstructor2, waveShaperNodeConstructor2) => {
      return class BaseAudioContext extends minimalBaseAudioContextConstructor2 {
        constructor(_nativeContext, numberOfChannels) {
          super(_nativeContext, numberOfChannels);
          this._nativeContext = _nativeContext;
          this._audioWorklet = addAudioWorkletModule2 === void 0 ? void 0 : {
            addModule: (moduleURL, options) => {
              return addAudioWorkletModule2(this, moduleURL, options);
            }
          };
        }
        get audioWorklet() {
          return this._audioWorklet;
        }
        createAnalyser() {
          return new analyserNodeConstructor2(this);
        }
        createBiquadFilter() {
          return new biquadFilterNodeConstructor2(this);
        }
        createBuffer(numberOfChannels, length, sampleRate) {
          return new audioBufferConstructor2({ length, numberOfChannels, sampleRate });
        }
        createBufferSource() {
          return new audioBufferSourceNodeConstructor2(this);
        }
        createChannelMerger(numberOfInputs = 6) {
          return new channelMergerNodeConstructor2(this, { numberOfInputs });
        }
        createChannelSplitter(numberOfOutputs = 6) {
          return new channelSplitterNodeConstructor2(this, { numberOfOutputs });
        }
        createConstantSource() {
          return new constantSourceNodeConstructor2(this);
        }
        createConvolver() {
          return new convolverNodeConstructor2(this);
        }
        createDelay(maxDelayTime = 1) {
          return new delayNodeConstructor2(this, { maxDelayTime });
        }
        createDynamicsCompressor() {
          return new dynamicsCompressorNodeConstructor2(this);
        }
        createGain() {
          return new gainNodeConstructor2(this);
        }
        createIIRFilter(feedforward, feedback) {
          return new iIRFilterNodeConstructor2(this, { feedback, feedforward });
        }
        createOscillator() {
          return new oscillatorNodeConstructor2(this);
        }
        createPanner() {
          return new pannerNodeConstructor2(this);
        }
        createPeriodicWave(real, imag, constraints = { disableNormalization: false }) {
          return new periodicWaveConstructor2(this, { ...constraints, imag, real });
        }
        createStereoPanner() {
          return new stereoPannerNodeConstructor2(this);
        }
        createWaveShaper() {
          return new waveShaperNodeConstructor2(this);
        }
        decodeAudioData(audioData, successCallback, errorCallback) {
          return decodeAudioData2(this._nativeContext, audioData).then((audioBuffer) => {
            if (typeof successCallback === "function") {
              successCallback(audioBuffer);
            }
            return audioBuffer;
          }, (err) => {
            if (typeof errorCallback === "function") {
              errorCallback(err);
            }
            throw err;
          });
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js
var DEFAULT_OPTIONS5, createBiquadFilterNodeConstructor;
var init_biquad_filter_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-constructor.js"() {
    init_constants();
    DEFAULT_OPTIONS5 = {
      Q: 1,
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      detune: 0,
      frequency: 350,
      gain: 0,
      type: "lowpass"
    };
    createBiquadFilterNodeConstructor = (audioNodeConstructor2, createAudioParam2, createBiquadFilterNodeRenderer2, createInvalidAccessError2, createNativeBiquadFilterNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
      return class BiquadFilterNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS5, ...options };
          const nativeBiquadFilterNode = createNativeBiquadFilterNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const biquadFilterNodeRenderer = isOffline ? createBiquadFilterNodeRenderer2() : null;
          super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);
          this._Q = createAudioParam2(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
          this._detune = createAudioParam2(this, isOffline, nativeBiquadFilterNode.detune, 1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT), -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT));
          this._frequency = createAudioParam2(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);
          this._gain = createAudioParam2(this, isOffline, nativeBiquadFilterNode.gain, 40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT), MOST_NEGATIVE_SINGLE_FLOAT);
          this._nativeBiquadFilterNode = nativeBiquadFilterNode;
          setAudioNodeTailTime2(this, 1);
        }
        get detune() {
          return this._detune;
        }
        get frequency() {
          return this._frequency;
        }
        get gain() {
          return this._gain;
        }
        get Q() {
          return this._Q;
        }
        get type() {
          return this._nativeBiquadFilterNode.type;
        }
        set type(value) {
          this._nativeBiquadFilterNode.type = value;
        }
        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
          try {
            this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
          } catch (err) {
            if (err.code === 11) {
              throw createInvalidAccessError2();
            }
            throw err;
          }
          if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
            throw createInvalidAccessError2();
          }
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js
var createBiquadFilterNodeRendererFactory;
var init_biquad_filter_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/biquad-filter-node-renderer-factory.js"() {
    init_is_owned_by_context();
    createBiquadFilterNodeRendererFactory = (connectAudioParam2, createNativeBiquadFilterNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeBiquadFilterNodes = /* @__PURE__ */ new WeakMap();
        const createBiquadFilterNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeBiquadFilterNode = getNativeAudioNode2(proxy);
          const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);
          if (!nativeBiquadFilterNodeIsOwnedByContext) {
            const options = {
              Q: nativeBiquadFilterNode.Q.value,
              channelCount: nativeBiquadFilterNode.channelCount,
              channelCountMode: nativeBiquadFilterNode.channelCountMode,
              channelInterpretation: nativeBiquadFilterNode.channelInterpretation,
              detune: nativeBiquadFilterNode.detune.value,
              frequency: nativeBiquadFilterNode.frequency.value,
              gain: nativeBiquadFilterNode.gain.value,
              type: nativeBiquadFilterNode.type
            };
            nativeBiquadFilterNode = createNativeBiquadFilterNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);
          if (!nativeBiquadFilterNodeIsOwnedByContext) {
            await renderAutomation2(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
            await renderAutomation2(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
            await renderAutomation2(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
            await renderAutomation2(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
          } else {
            await connectAudioParam2(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);
          }
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);
          return nativeBiquadFilterNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);
            if (renderedNativeBiquadFilterNode !== void 0) {
              return Promise.resolve(renderedNativeBiquadFilterNode);
            }
            return createBiquadFilterNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js
var createCacheTestResult;
var init_cache_test_result = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/cache-test-result.js"() {
    createCacheTestResult = (ongoingTests, testResults) => {
      return (tester, test) => {
        const cachedTestResult = testResults.get(tester);
        if (cachedTestResult !== void 0) {
          return cachedTestResult;
        }
        const ongoingTest = ongoingTests.get(tester);
        if (ongoingTest !== void 0) {
          return ongoingTest;
        }
        try {
          const synchronousTestResult = test();
          if (synchronousTestResult instanceof Promise) {
            ongoingTests.set(tester, synchronousTestResult);
            return synchronousTestResult.catch(() => false).then((finalTestResult) => {
              ongoingTests.delete(tester);
              testResults.set(tester, finalTestResult);
              return finalTestResult;
            });
          }
          testResults.set(tester, synchronousTestResult);
          return synchronousTestResult;
        } catch {
          testResults.set(tester, false);
          return false;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js
var DEFAULT_OPTIONS6, createChannelMergerNodeConstructor;
var init_channel_merger_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-constructor.js"() {
    DEFAULT_OPTIONS6 = {
      channelCount: 1,
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      numberOfInputs: 6
    };
    createChannelMergerNodeConstructor = (audioNodeConstructor2, createChannelMergerNodeRenderer2, createNativeChannelMergerNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
      return class ChannelMergerNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS6, ...options };
          const nativeChannelMergerNode = createNativeChannelMergerNode2(nativeContext, mergedOptions);
          const channelMergerNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createChannelMergerNodeRenderer2() : null;
          super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js
var createChannelMergerNodeRendererFactory;
var init_channel_merger_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/channel-merger-node-renderer-factory.js"() {
    init_is_owned_by_context();
    createChannelMergerNodeRendererFactory = (createNativeChannelMergerNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeAudioNode = getNativeAudioNode2(proxy);
          const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);
          if (!nativeAudioNodeIsOwnedByContext) {
            const options = {
              channelCount: nativeAudioNode.channelCount,
              channelCountMode: nativeAudioNode.channelCountMode,
              channelInterpretation: nativeAudioNode.channelInterpretation,
              numberOfInputs: nativeAudioNode.numberOfInputs
            };
            nativeAudioNode = createNativeChannelMergerNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioNode);
          return nativeAudioNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
            if (renderedNativeAudioNode !== void 0) {
              return Promise.resolve(renderedNativeAudioNode);
            }
            return createAudioNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js
var DEFAULT_OPTIONS7, createChannelSplitterNodeConstructor;
var init_channel_splitter_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-constructor.js"() {
    DEFAULT_OPTIONS7 = {
      channelCount: 6,
      channelCountMode: "explicit",
      channelInterpretation: "discrete",
      numberOfOutputs: 6
    };
    createChannelSplitterNodeConstructor = (audioNodeConstructor2, createChannelSplitterNodeRenderer2, createNativeChannelSplitterNode2, getNativeContext2, isNativeOfflineAudioContext2, sanitizeChannelSplitterOptions2) => {
      return class ChannelSplitterNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = sanitizeChannelSplitterOptions2({ ...DEFAULT_OPTIONS7, ...options });
          const nativeChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, mergedOptions);
          const channelSplitterNodeRenderer = isNativeOfflineAudioContext2(nativeContext) ? createChannelSplitterNodeRenderer2() : null;
          super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js
var createChannelSplitterNodeRendererFactory;
var init_channel_splitter_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/channel-splitter-node-renderer-factory.js"() {
    init_is_owned_by_context();
    createChannelSplitterNodeRendererFactory = (createNativeChannelSplitterNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeAudioNode = getNativeAudioNode2(proxy);
          const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);
          if (!nativeAudioNodeIsOwnedByContext) {
            const options = {
              channelCount: nativeAudioNode.channelCount,
              channelCountMode: nativeAudioNode.channelCountMode,
              channelInterpretation: nativeAudioNode.channelInterpretation,
              numberOfOutputs: nativeAudioNode.numberOfOutputs
            };
            nativeAudioNode = createNativeChannelSplitterNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeAudioNode);
          return nativeAudioNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
            if (renderedNativeAudioNode !== void 0) {
              return Promise.resolve(renderedNativeAudioNode);
            }
            return createAudioNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js
var createConnectAudioParam;
var init_connect_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/connect-audio-param.js"() {
    createConnectAudioParam = (renderInputsOfAudioParam2) => {
      return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
        return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js
var createConnectMultipleOutputs;
var init_connect_multiple_outputs = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/connect-multiple-outputs.js"() {
    init_native_audio_node();
    createConnectMultipleOutputs = (createIndexSizeError2) => {
      return (outputAudioNodes, destination, output = 0, input = 0) => {
        const outputAudioNode = outputAudioNodes[output];
        if (outputAudioNode === void 0) {
          throw createIndexSizeError2();
        }
        if (isNativeAudioNode(destination)) {
          return outputAudioNode.connect(destination, 0, input);
        }
        return outputAudioNode.connect(destination, 0);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js
var createConnectedNativeAudioBufferSourceNodeFactory;
var init_connected_native_audio_buffer_source_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/connected-native-audio-buffer-source-node-factory.js"() {
    createConnectedNativeAudioBufferSourceNodeFactory = (createNativeAudioBufferSourceNode2) => {
      return (nativeContext, nativeAudioNode) => {
        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {
          buffer: null,
          channelCount: 2,
          channelCountMode: "max",
          channelInterpretation: "speakers",
          loop: false,
          loopEnd: 0,
          loopStart: 0,
          playbackRate: 1
        });
        const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);
        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
        nativeAudioBufferSourceNode.loop = true;
        nativeAudioBufferSourceNode.connect(nativeAudioNode);
        nativeAudioBufferSourceNode.start();
        return () => {
          nativeAudioBufferSourceNode.stop();
          nativeAudioBufferSourceNode.disconnect(nativeAudioNode);
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js
var DEFAULT_OPTIONS8, createConstantSourceNodeConstructor;
var init_constant_source_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-constructor.js"() {
    init_constants();
    init_is_active_audio_node();
    init_set_internal_state_to_active();
    init_set_internal_state_to_passive();
    DEFAULT_OPTIONS8 = {
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      offset: 1
    };
    createConstantSourceNodeConstructor = (audioNodeConstructor2, createAudioParam2, createConstantSourceNodeRendererFactory2, createNativeConstantSourceNode2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener3) => {
      return class ConstantSourceNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS8, ...options };
          const nativeConstantSourceNode = createNativeConstantSourceNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const constantSourceNodeRenderer = isOffline ? createConstantSourceNodeRendererFactory2() : null;
          super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);
          this._constantSourceNodeRenderer = constantSourceNodeRenderer;
          this._nativeConstantSourceNode = nativeConstantSourceNode;
          this._offset = createAudioParam2(this, isOffline, nativeConstantSourceNode.offset, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
          this._onended = null;
        }
        get offset() {
          return this._offset;
        }
        get onended() {
          return this._onended;
        }
        set onended(value) {
          const wrappedListener = typeof value === "function" ? wrapEventListener3(this, value) : null;
          this._nativeConstantSourceNode.onended = wrappedListener;
          const nativeOnEnded = this._nativeConstantSourceNode.onended;
          this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
        }
        start(when = 0) {
          this._nativeConstantSourceNode.start(when);
          if (this._constantSourceNodeRenderer !== null) {
            this._constantSourceNodeRenderer.start = when;
          }
          if (this.context.state !== "closed") {
            setInternalStateToActive(this);
            const resetInternalStateToPassive = () => {
              this._nativeConstantSourceNode.removeEventListener("ended", resetInternalStateToPassive);
              if (isActiveAudioNode(this)) {
                setInternalStateToPassive(this);
              }
            };
            this._nativeConstantSourceNode.addEventListener("ended", resetInternalStateToPassive);
          }
        }
        stop(when = 0) {
          this._nativeConstantSourceNode.stop(when);
          if (this._constantSourceNodeRenderer !== null) {
            this._constantSourceNodeRenderer.stop = when;
          }
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js
var createConstantSourceNodeRendererFactory;
var init_constant_source_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/constant-source-node-renderer-factory.js"() {
    init_is_owned_by_context();
    createConstantSourceNodeRendererFactory = (connectAudioParam2, createNativeConstantSourceNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeConstantSourceNodes = /* @__PURE__ */ new WeakMap();
        let start = null;
        let stop = null;
        const createConstantSourceNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeConstantSourceNode = getNativeAudioNode2(proxy);
          const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);
          if (!nativeConstantSourceNodeIsOwnedByContext) {
            const options = {
              channelCount: nativeConstantSourceNode.channelCount,
              channelCountMode: nativeConstantSourceNode.channelCountMode,
              channelInterpretation: nativeConstantSourceNode.channelInterpretation,
              offset: nativeConstantSourceNode.offset.value
            };
            nativeConstantSourceNode = createNativeConstantSourceNode2(nativeOfflineAudioContext, options);
            if (start !== null) {
              nativeConstantSourceNode.start(start);
            }
            if (stop !== null) {
              nativeConstantSourceNode.stop(stop);
            }
          }
          renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);
          if (!nativeConstantSourceNodeIsOwnedByContext) {
            await renderAutomation2(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
          } else {
            await connectAudioParam2(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);
          }
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);
          return nativeConstantSourceNode;
        };
        return {
          set start(value) {
            start = value;
          },
          set stop(value) {
            stop = value;
          },
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);
            if (renderedNativeConstantSourceNode !== void 0) {
              return Promise.resolve(renderedNativeConstantSourceNode);
            }
            return createConstantSourceNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js
var createConvertNumberToUnsignedLong;
var init_convert_number_to_unsigned_long = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/convert-number-to-unsigned-long.js"() {
    createConvertNumberToUnsignedLong = (unit32Array) => {
      return (value) => {
        unit32Array[0] = value;
        return unit32Array[0];
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js
var DEFAULT_OPTIONS9, createConvolverNodeConstructor;
var init_convolver_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/convolver-node-constructor.js"() {
    DEFAULT_OPTIONS9 = {
      buffer: null,
      channelCount: 2,
      channelCountMode: "clamped-max",
      channelInterpretation: "speakers",
      disableNormalization: false
    };
    createConvolverNodeConstructor = (audioNodeConstructor2, createConvolverNodeRenderer2, createNativeConvolverNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
      return class ConvolverNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS9, ...options };
          const nativeConvolverNode = createNativeConvolverNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const convolverNodeRenderer = isOffline ? createConvolverNodeRenderer2() : null;
          super(context, false, nativeConvolverNode, convolverNodeRenderer);
          this._isBufferNullified = false;
          this._nativeConvolverNode = nativeConvolverNode;
          if (mergedOptions.buffer !== null) {
            setAudioNodeTailTime2(this, mergedOptions.buffer.duration);
          }
        }
        get buffer() {
          if (this._isBufferNullified) {
            return null;
          }
          return this._nativeConvolverNode.buffer;
        }
        set buffer(value) {
          this._nativeConvolverNode.buffer = value;
          if (value === null && this._nativeConvolverNode.buffer !== null) {
            const nativeContext = this._nativeConvolverNode.context;
            this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);
            this._isBufferNullified = true;
            setAudioNodeTailTime2(this, 0);
          } else {
            this._isBufferNullified = false;
            setAudioNodeTailTime2(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);
          }
        }
        get normalize() {
          return this._nativeConvolverNode.normalize;
        }
        set normalize(value) {
          this._nativeConvolverNode.normalize = value;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js
var createConvolverNodeRendererFactory;
var init_convolver_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/convolver-node-renderer-factory.js"() {
    init_native_audio_node_faker();
    init_is_owned_by_context();
    createConvolverNodeRendererFactory = (createNativeConvolverNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeConvolverNodes = /* @__PURE__ */ new WeakMap();
        const createConvolverNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeConvolverNode = getNativeAudioNode2(proxy);
          const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);
          if (!nativeConvolverNodeIsOwnedByContext) {
            const options = {
              buffer: nativeConvolverNode.buffer,
              channelCount: nativeConvolverNode.channelCount,
              channelCountMode: nativeConvolverNode.channelCountMode,
              channelInterpretation: nativeConvolverNode.channelInterpretation,
              disableNormalization: !nativeConvolverNode.normalize
            };
            nativeConvolverNode = createNativeConvolverNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);
          if (isNativeAudioNodeFaker(nativeConvolverNode)) {
            await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);
          } else {
            await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeConvolverNode);
          }
          return nativeConvolverNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);
            if (renderedNativeConvolverNode !== void 0) {
              return Promise.resolve(renderedNativeConvolverNode);
            }
            return createConvolverNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js
var createCreateNativeOfflineAudioContext;
var init_create_native_offline_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/create-native-offline-audio-context.js"() {
    createCreateNativeOfflineAudioContext = (createNotSupportedError3, nativeOfflineAudioContextConstructor2) => {
      return (numberOfChannels, length, sampleRate) => {
        if (nativeOfflineAudioContextConstructor2 === null) {
          throw new Error("Missing the native OfflineAudioContext constructor.");
        }
        try {
          return new nativeOfflineAudioContextConstructor2(numberOfChannels, length, sampleRate);
        } catch (err) {
          if (err.name === "SyntaxError") {
            throw createNotSupportedError3();
          }
          throw err;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js
var createDataCloneError;
var init_data_clone_error = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/data-clone-error.js"() {
    createDataCloneError = () => new DOMException("", "DataCloneError");
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js
var detachArrayBuffer;
var init_detach_array_buffer = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/detach-array-buffer.js"() {
    detachArrayBuffer = (arrayBuffer) => {
      const { port1, port2 } = new MessageChannel();
      return new Promise((resolve) => {
        const closeAndResolve = () => {
          port2.onmessage = null;
          port1.close();
          port2.close();
          resolve();
        };
        port2.onmessage = () => closeAndResolve();
        try {
          port1.postMessage(arrayBuffer, [arrayBuffer]);
        } catch {
        } finally {
          closeAndResolve();
        }
      });
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js
var createDecodeAudioData;
var init_decode_audio_data = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/decode-audio-data.js"() {
    init_detach_array_buffer();
    init_wrap_audio_buffer_get_channel_data_method();
    createDecodeAudioData = (audioBufferStore2, cacheTestResult2, createDataCloneError2, createEncodingError2, detachedArrayBuffers, getNativeContext2, isNativeContext2, testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, testPromiseSupport2, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
      return (anyContext, audioData) => {
        const nativeContext = isNativeContext2(anyContext) ? anyContext : getNativeContext2(anyContext);
        if (detachedArrayBuffers.has(audioData)) {
          const err = createDataCloneError2();
          return Promise.reject(err);
        }
        try {
          detachedArrayBuffers.add(audioData);
        } catch {
        }
        if (cacheTestResult2(testPromiseSupport2, () => testPromiseSupport2(nativeContext))) {
          return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {
            detachArrayBuffer(audioData).catch(() => {
            });
            if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport2(audioBuffer))) {
              wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
            }
            audioBufferStore2.add(audioBuffer);
            return audioBuffer;
          });
        }
        return new Promise((resolve, reject) => {
          const complete = async () => {
            try {
              await detachArrayBuffer(audioData);
            } catch {
            }
          };
          const fail = (err) => {
            reject(err);
            complete();
          };
          try {
            nativeContext.decodeAudioData(audioData, (audioBuffer) => {
              if (typeof audioBuffer.copyFromChannel !== "function") {
                wrapAudioBufferCopyChannelMethods2(audioBuffer);
                wrapAudioBufferGetChannelDataMethod(audioBuffer);
              }
              audioBufferStore2.add(audioBuffer);
              complete().then(() => resolve(audioBuffer));
            }, (err) => {
              if (err === null) {
                fail(createEncodingError2());
              } else {
                fail(err);
              }
            });
          } catch (err) {
            fail(err);
          }
        });
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js
var createDecrementCycleCounter;
var init_decrement_cycle_counter = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/decrement-cycle-counter.js"() {
    init_audio_node_output_connection();
    createDecrementCycleCounter = (connectNativeAudioNodeToNativeAudioNode2, cycleCounters, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, getNativeContext2, isActiveAudioNode2, isNativeOfflineAudioContext2) => {
      return (audioNode, count) => {
        const cycleCounter = cycleCounters.get(audioNode);
        if (cycleCounter === void 0) {
          throw new Error("Missing the expected cycle count.");
        }
        const nativeContext = getNativeContext2(audioNode.context);
        const isOffline = isNativeOfflineAudioContext2(nativeContext);
        if (cycleCounter === count) {
          cycleCounters.delete(audioNode);
          if (!isOffline && isActiveAudioNode2(audioNode)) {
            const nativeSourceAudioNode = getNativeAudioNode2(audioNode);
            const { outputs } = getAudioNodeConnections2(audioNode);
            for (const output of outputs) {
              if (isAudioNodeOutputConnection(output)) {
                const nativeDestinationAudioNode = getNativeAudioNode2(output[0]);
                connectNativeAudioNodeToNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
              } else {
                const nativeDestinationAudioParam = getNativeAudioParam2(output[0]);
                nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);
              }
            }
          }
        } else {
          cycleCounters.set(audioNode, cycleCounter - count);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js
var DEFAULT_OPTIONS10, createDelayNodeConstructor;
var init_delay_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/delay-node-constructor.js"() {
    DEFAULT_OPTIONS10 = {
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      delayTime: 0,
      maxDelayTime: 1
    };
    createDelayNodeConstructor = (audioNodeConstructor2, createAudioParam2, createDelayNodeRenderer2, createNativeDelayNode2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
      return class DelayNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS10, ...options };
          const nativeDelayNode = createNativeDelayNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const delayNodeRenderer = isOffline ? createDelayNodeRenderer2(mergedOptions.maxDelayTime) : null;
          super(context, false, nativeDelayNode, delayNodeRenderer);
          this._delayTime = createAudioParam2(this, isOffline, nativeDelayNode.delayTime);
          setAudioNodeTailTime2(this, mergedOptions.maxDelayTime);
        }
        get delayTime() {
          return this._delayTime;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js
var createDelayNodeRendererFactory;
var init_delay_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/delay-node-renderer-factory.js"() {
    init_is_owned_by_context();
    createDelayNodeRendererFactory = (connectAudioParam2, createNativeDelayNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
      return (maxDelayTime) => {
        const renderedNativeDelayNodes = /* @__PURE__ */ new WeakMap();
        const createDelayNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeDelayNode = getNativeAudioNode2(proxy);
          const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);
          if (!nativeDelayNodeIsOwnedByContext) {
            const options = {
              channelCount: nativeDelayNode.channelCount,
              channelCountMode: nativeDelayNode.channelCountMode,
              channelInterpretation: nativeDelayNode.channelInterpretation,
              delayTime: nativeDelayNode.delayTime.value,
              maxDelayTime
            };
            nativeDelayNode = createNativeDelayNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);
          if (!nativeDelayNodeIsOwnedByContext) {
            await renderAutomation2(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
          } else {
            await connectAudioParam2(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);
          }
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeDelayNode);
          return nativeDelayNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);
            if (renderedNativeDelayNode !== void 0) {
              return Promise.resolve(renderedNativeDelayNode);
            }
            return createDelayNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/delete-active-input-connection-to-audio-node.js
var createDeleteActiveInputConnectionToAudioNode;
var init_delete_active_input_connection_to_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/delete-active-input-connection-to-audio-node.js"() {
    createDeleteActiveInputConnectionToAudioNode = (pickElementFromSet2) => {
      return (activeInputs, source, output, input) => {
        return pickElementFromSet2(activeInputs[input], (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js
var createDeleteUnrenderedAudioWorkletNode;
var init_delete_unrendered_audio_worklet_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/delete-unrendered-audio-worklet-node.js"() {
    createDeleteUnrenderedAudioWorkletNode = (getUnrenderedAudioWorkletNodes2) => {
      return (nativeContext, audioWorkletNode) => {
        getUnrenderedAudioWorkletNodes2(nativeContext).delete(audioWorkletNode);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/guards/delay-node.js
var isDelayNode;
var init_delay_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/guards/delay-node.js"() {
    isDelayNode = (audioNode) => {
      return "delayTime" in audioNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js
var createDetectCycles;
var init_detect_cycles = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/detect-cycles.js"() {
    init_audio_node();
    init_delay_node();
    createDetectCycles = (audioParamAudioNodeStore2, getAudioNodeConnections2, getValueForKey2) => {
      return function detectCycles(chain, nextLink) {
        const audioNode = isAudioNode(nextLink) ? nextLink : getValueForKey2(audioParamAudioNodeStore2, nextLink);
        if (isDelayNode(audioNode)) {
          return [];
        }
        if (chain[0] === audioNode) {
          return [chain];
        }
        if (chain.includes(audioNode)) {
          return [];
        }
        const { outputs } = getAudioNodeConnections2(audioNode);
        return Array.from(outputs).map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0])).reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js
var getOutputAudioNodeAtIndex, createDisconnectMultipleOutputs;
var init_disconnect_multiple_outputs = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/disconnect-multiple-outputs.js"() {
    init_native_audio_node();
    getOutputAudioNodeAtIndex = (createIndexSizeError2, outputAudioNodes, output) => {
      const outputAudioNode = outputAudioNodes[output];
      if (outputAudioNode === void 0) {
        throw createIndexSizeError2();
      }
      return outputAudioNode;
    };
    createDisconnectMultipleOutputs = (createIndexSizeError2) => {
      return (outputAudioNodes, destinationOrOutput = void 0, output = void 0, input = 0) => {
        if (destinationOrOutput === void 0) {
          return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());
        }
        if (typeof destinationOrOutput === "number") {
          return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, destinationOrOutput).disconnect();
        }
        if (isNativeAudioNode(destinationOrOutput)) {
          if (output === void 0) {
            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));
          }
          if (input === void 0) {
            return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0);
          }
          return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);
        }
        if (output === void 0) {
          return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));
        }
        return getOutputAudioNodeAtIndex(createIndexSizeError2, outputAudioNodes, output).disconnect(destinationOrOutput, 0);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js
var DEFAULT_OPTIONS11, createDynamicsCompressorNodeConstructor;
var init_dynamics_compressor_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-constructor.js"() {
    DEFAULT_OPTIONS11 = {
      attack: 3e-3,
      channelCount: 2,
      channelCountMode: "clamped-max",
      channelInterpretation: "speakers",
      knee: 30,
      ratio: 12,
      release: 0.25,
      threshold: -24
    };
    createDynamicsCompressorNodeConstructor = (audioNodeConstructor2, createAudioParam2, createDynamicsCompressorNodeRenderer2, createNativeDynamicsCompressorNode2, createNotSupportedError3, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
      return class DynamicsCompressorNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS11, ...options };
          const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const dynamicsCompressorNodeRenderer = isOffline ? createDynamicsCompressorNodeRenderer2() : null;
          super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);
          this._attack = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.attack);
          this._knee = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.knee);
          this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;
          this._ratio = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.ratio);
          this._release = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.release);
          this._threshold = createAudioParam2(this, isOffline, nativeDynamicsCompressorNode.threshold);
          setAudioNodeTailTime2(this, 6e-3);
        }
        get attack() {
          return this._attack;
        }
        // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.
        get channelCount() {
          return this._nativeDynamicsCompressorNode.channelCount;
        }
        set channelCount(value) {
          const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;
          this._nativeDynamicsCompressorNode.channelCount = value;
          if (value > 2) {
            this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;
            throw createNotSupportedError3();
          }
        }
        /*
         * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be
         * overwritten here.
         */
        get channelCountMode() {
          return this._nativeDynamicsCompressorNode.channelCountMode;
        }
        set channelCountMode(value) {
          const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;
          this._nativeDynamicsCompressorNode.channelCountMode = value;
          if (value === "max") {
            this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;
            throw createNotSupportedError3();
          }
        }
        get knee() {
          return this._knee;
        }
        get ratio() {
          return this._ratio;
        }
        get reduction() {
          if (typeof this._nativeDynamicsCompressorNode.reduction.value === "number") {
            return this._nativeDynamicsCompressorNode.reduction.value;
          }
          return this._nativeDynamicsCompressorNode.reduction;
        }
        get release() {
          return this._release;
        }
        get threshold() {
          return this._threshold;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js
var createDynamicsCompressorNodeRendererFactory;
var init_dynamics_compressor_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/dynamics-compressor-node-renderer-factory.js"() {
    init_is_owned_by_context();
    createDynamicsCompressorNodeRendererFactory = (connectAudioParam2, createNativeDynamicsCompressorNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeDynamicsCompressorNodes = /* @__PURE__ */ new WeakMap();
        const createDynamicsCompressorNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeDynamicsCompressorNode = getNativeAudioNode2(proxy);
          const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);
          if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
            const options = {
              attack: nativeDynamicsCompressorNode.attack.value,
              channelCount: nativeDynamicsCompressorNode.channelCount,
              channelCountMode: nativeDynamicsCompressorNode.channelCountMode,
              channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,
              knee: nativeDynamicsCompressorNode.knee.value,
              ratio: nativeDynamicsCompressorNode.ratio.value,
              release: nativeDynamicsCompressorNode.release.value,
              threshold: nativeDynamicsCompressorNode.threshold.value
            };
            nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);
          if (!nativeDynamicsCompressorNodeIsOwnedByContext) {
            await renderAutomation2(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
            await renderAutomation2(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
            await renderAutomation2(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
            await renderAutomation2(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
            await renderAutomation2(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
          } else {
            await connectAudioParam2(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);
          }
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);
          return nativeDynamicsCompressorNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);
            if (renderedNativeDynamicsCompressorNode !== void 0) {
              return Promise.resolve(renderedNativeDynamicsCompressorNode);
            }
            return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js
var createEncodingError;
var init_encoding_error = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/encoding-error.js"() {
    createEncodingError = () => new DOMException("", "EncodingError");
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js
var createEvaluateSource;
var init_evaluate_source = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/evaluate-source.js"() {
    createEvaluateSource = (window5) => {
      return (source) => new Promise((resolve, reject) => {
        if (window5 === null) {
          reject(new SyntaxError());
          return;
        }
        const head = window5.document.head;
        if (head === null) {
          reject(new SyntaxError());
        } else {
          const script = window5.document.createElement("script");
          const blob3 = new Blob([source], { type: "application/javascript" });
          const url4 = URL.createObjectURL(blob3);
          const originalOnErrorHandler = window5.onerror;
          const removeErrorEventListenerAndRevokeUrl = () => {
            window5.onerror = originalOnErrorHandler;
            URL.revokeObjectURL(url4);
          };
          window5.onerror = (message, src, lineno, colno, error) => {
            if (src === url4 || src === window5.location.href && lineno === 1 && colno === 1) {
              removeErrorEventListenerAndRevokeUrl();
              reject(error);
              return false;
            }
            if (originalOnErrorHandler !== null) {
              return originalOnErrorHandler(message, src, lineno, colno, error);
            }
          };
          script.onerror = () => {
            removeErrorEventListenerAndRevokeUrl();
            reject(new SyntaxError());
          };
          script.onload = () => {
            removeErrorEventListenerAndRevokeUrl();
            resolve();
          };
          script.src = url4;
          script.type = "module";
          head.appendChild(script);
        }
      });
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js
var createEventTargetConstructor2;
var init_event_target_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/event-target-constructor.js"() {
    createEventTargetConstructor2 = (wrapEventListener3) => {
      return class EventTarget {
        constructor(_nativeEventTarget) {
          this._nativeEventTarget = _nativeEventTarget;
          this._listeners = /* @__PURE__ */ new WeakMap();
        }
        addEventListener(type, listener, options) {
          if (listener !== null) {
            let wrappedEventListener = this._listeners.get(listener);
            if (wrappedEventListener === void 0) {
              wrappedEventListener = wrapEventListener3(this, listener);
              if (typeof listener === "function") {
                this._listeners.set(listener, wrappedEventListener);
              }
            }
            this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);
          }
        }
        dispatchEvent(event) {
          return this._nativeEventTarget.dispatchEvent(event);
        }
        removeEventListener(type, listener, options) {
          const wrappedEventListener = listener === null ? void 0 : this._listeners.get(listener);
          this._nativeEventTarget.removeEventListener(type, wrappedEventListener === void 0 ? null : wrappedEventListener, options);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js
var createExposeCurrentFrameAndCurrentTime;
var init_expose_current_frame_and_current_time = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/expose-current-frame-and-current-time.js"() {
    createExposeCurrentFrameAndCurrentTime = (window5) => {
      return (currentTime, sampleRate, fn) => {
        Object.defineProperties(window5, {
          currentFrame: {
            configurable: true,
            get() {
              return Math.round(currentTime * sampleRate);
            }
          },
          currentTime: {
            configurable: true,
            get() {
              return currentTime;
            }
          }
        });
        try {
          return fn();
        } finally {
          if (window5 !== null) {
            delete window5.currentFrame;
            delete window5.currentTime;
          }
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js
var createFetchSource;
var init_fetch_source = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/fetch-source.js"() {
    createFetchSource = (createAbortError2) => {
      return async (url4) => {
        try {
          const response = await fetch(url4);
          if (response.ok) {
            return [await response.text(), response.url];
          }
        } catch {
        }
        throw createAbortError2();
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js
var DEFAULT_OPTIONS12, createGainNodeConstructor;
var init_gain_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/gain-node-constructor.js"() {
    init_constants();
    DEFAULT_OPTIONS12 = {
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      gain: 1
    };
    createGainNodeConstructor = (audioNodeConstructor2, createAudioParam2, createGainNodeRenderer2, createNativeGainNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
      return class GainNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS12, ...options };
          const nativeGainNode = createNativeGainNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const gainNodeRenderer = isOffline ? createGainNodeRenderer2() : null;
          super(context, false, nativeGainNode, gainNodeRenderer);
          this._gain = createAudioParam2(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
        }
        get gain() {
          return this._gain;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js
var createGainNodeRendererFactory;
var init_gain_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/gain-node-renderer-factory.js"() {
    init_is_owned_by_context();
    createGainNodeRendererFactory = (connectAudioParam2, createNativeGainNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeGainNodes = /* @__PURE__ */ new WeakMap();
        const createGainNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeGainNode = getNativeAudioNode2(proxy);
          const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);
          if (!nativeGainNodeIsOwnedByContext) {
            const options = {
              channelCount: nativeGainNode.channelCount,
              channelCountMode: nativeGainNode.channelCountMode,
              channelInterpretation: nativeGainNode.channelInterpretation,
              gain: nativeGainNode.gain.value
            };
            nativeGainNode = createNativeGainNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);
          if (!nativeGainNodeIsOwnedByContext) {
            await renderAutomation2(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
          } else {
            await connectAudioParam2(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);
          }
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeGainNode);
          return nativeGainNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);
            if (renderedNativeGainNode !== void 0) {
              return Promise.resolve(renderedNativeGainNode);
            }
            return createGainNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/get-active-audio-worklet-node-inputs.js
var createGetActiveAudioWorkletNodeInputs;
var init_get_active_audio_worklet_node_inputs = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/get-active-audio-worklet-node-inputs.js"() {
    createGetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2, getValueForKey2) => {
      return (nativeAudioWorkletNode) => getValueForKey2(activeAudioWorkletNodeInputsStore2, nativeAudioWorkletNode);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js
var createGetAudioNodeRenderer;
var init_get_audio_node_renderer = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-renderer.js"() {
    createGetAudioNodeRenderer = (getAudioNodeConnections2) => {
      return (audioNode) => {
        const audioNodeConnections = getAudioNodeConnections2(audioNode);
        if (audioNodeConnections.renderer === null) {
          throw new Error("Missing the renderer of the given AudioNode in the audio graph.");
        }
        return audioNodeConnections.renderer;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-tail-time.js
var createGetAudioNodeTailTime;
var init_get_audio_node_tail_time = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/get-audio-node-tail-time.js"() {
    createGetAudioNodeTailTime = (audioNodeTailTimeStore2) => {
      return (audioNode) => {
        var _a13;
        return (_a13 = audioNodeTailTimeStore2.get(audioNode)) !== null && _a13 !== void 0 ? _a13 : 0;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js
var createGetAudioParamRenderer;
var init_get_audio_param_renderer = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/get-audio-param-renderer.js"() {
    createGetAudioParamRenderer = (getAudioParamConnections2) => {
      return (audioParam) => {
        const audioParamConnections = getAudioParamConnections2(audioParam);
        if (audioParamConnections.renderer === null) {
          throw new Error("Missing the renderer of the given AudioParam in the audio graph.");
        }
        return audioParamConnections.renderer;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/get-backup-offline-audio-context.js
var createGetBackupOfflineAudioContext;
var init_get_backup_offline_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/get-backup-offline-audio-context.js"() {
    createGetBackupOfflineAudioContext = (backupOfflineAudioContextStore2) => {
      return (nativeContext) => {
        return backupOfflineAudioContextStore2.get(nativeContext);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js
var createInvalidStateError2;
var init_invalid_state_error2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/invalid-state-error.js"() {
    createInvalidStateError2 = () => new DOMException("", "InvalidStateError");
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js
var createGetNativeContext;
var init_get_native_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/get-native-context.js"() {
    init_invalid_state_error2();
    createGetNativeContext = (contextStore) => {
      return (context) => {
        const nativeContext = contextStore.get(context);
        if (nativeContext === void 0) {
          throw createInvalidStateError2();
        }
        return nativeContext;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/get-or-create-backup-offline-audio-context.js
var createGetOrCreateBackupOfflineAudioContext;
var init_get_or_create_backup_offline_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/get-or-create-backup-offline-audio-context.js"() {
    createGetOrCreateBackupOfflineAudioContext = (backupOfflineAudioContextStore2, nativeOfflineAudioContextConstructor2) => {
      return (nativeContext) => {
        let backupOfflineAudioContext = backupOfflineAudioContextStore2.get(nativeContext);
        if (backupOfflineAudioContext !== void 0) {
          return backupOfflineAudioContext;
        }
        if (nativeOfflineAudioContextConstructor2 === null) {
          throw new Error("Missing the native OfflineAudioContext constructor.");
        }
        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
        backupOfflineAudioContextStore2.set(nativeContext, backupOfflineAudioContext);
        return backupOfflineAudioContext;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js
var createGetUnrenderedAudioWorkletNodes;
var init_get_unrendered_audio_worklet_nodes = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/get-unrendered-audio-worklet-nodes.js"() {
    createGetUnrenderedAudioWorkletNodes = (unrenderedAudioWorkletNodeStore2) => {
      return (nativeContext) => {
        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore2.get(nativeContext);
        if (unrenderedAudioWorkletNodes === void 0) {
          throw new Error("The context has no set of AudioWorkletNodes.");
        }
        return unrenderedAudioWorkletNodes;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js
var createInvalidAccessError;
var init_invalid_access_error = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/invalid-access-error.js"() {
    createInvalidAccessError = () => new DOMException("", "InvalidAccessError");
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js
var wrapIIRFilterNodeGetFrequencyResponseMethod;
var init_wrap_iir_filter_node_get_frequency_response_method = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-iir-filter-node-get-frequency-response-method.js"() {
    init_invalid_access_error();
    wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode) => {
      nativeIIRFilterNode.getFrequencyResponse = /* @__PURE__ */ ((getFrequencyResponse) => {
        return (frequencyHz, magResponse, phaseResponse) => {
          if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
            throw createInvalidAccessError();
          }
          return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);
        };
      })(nativeIIRFilterNode.getFrequencyResponse);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js
var DEFAULT_OPTIONS13, createIIRFilterNodeConstructor;
var init_iir_filter_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-constructor.js"() {
    init_wrap_iir_filter_node_get_frequency_response_method();
    DEFAULT_OPTIONS13 = {
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers"
    };
    createIIRFilterNodeConstructor = (audioNodeConstructor2, createNativeIIRFilterNode2, createIIRFilterNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
      return class IIRFilterNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const mergedOptions = { ...DEFAULT_OPTIONS13, ...options };
          const nativeIIRFilterNode = createNativeIIRFilterNode2(nativeContext, isOffline ? null : context.baseLatency, mergedOptions);
          const iirFilterNodeRenderer = isOffline ? createIIRFilterNodeRenderer2(mergedOptions.feedback, mergedOptions.feedforward) : null;
          super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);
          wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);
          this._nativeIIRFilterNode = nativeIIRFilterNode;
          setAudioNodeTailTime2(this, 1);
        }
        getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
          return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js
var filterBuffer;
var init_filter_buffer = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/filter-buffer.js"() {
    filterBuffer = (feedback, feedbackLength, feedforward, feedforwardLength, minLength, xBuffer, yBuffer, bufferIndex, bufferLength, input, output) => {
      const inputLength = input.length;
      let i = bufferIndex;
      for (let j = 0; j < inputLength; j += 1) {
        let y = feedforward[0] * input[j];
        for (let k = 1; k < minLength; k += 1) {
          const x = i - k & bufferLength - 1;
          y += feedforward[k] * xBuffer[x];
          y -= feedback[k] * yBuffer[x];
        }
        for (let k = minLength; k < feedforwardLength; k += 1) {
          y += feedforward[k] * xBuffer[i - k & bufferLength - 1];
        }
        for (let k = minLength; k < feedbackLength; k += 1) {
          y -= feedback[k] * yBuffer[i - k & bufferLength - 1];
        }
        xBuffer[i] = input[j];
        yBuffer[i] = y;
        i = i + 1 & bufferLength - 1;
        output[j] = y;
      }
      return i;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js
var filterFullBuffer, createIIRFilterNodeRendererFactory;
var init_iir_filter_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/iir-filter-node-renderer-factory.js"() {
    init_filter_buffer();
    init_is_owned_by_context();
    filterFullBuffer = (renderedBuffer, nativeOfflineAudioContext, feedback, feedforward) => {
      const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
      const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
      const feedbackLength = convertedFeedback.length;
      const feedforwardLength = convertedFeedforward.length;
      const minLength = Math.min(feedbackLength, feedforwardLength);
      if (convertedFeedback[0] !== 1) {
        for (let i = 0; i < feedbackLength; i += 1) {
          convertedFeedforward[i] /= convertedFeedback[0];
        }
        for (let i = 1; i < feedforwardLength; i += 1) {
          convertedFeedback[i] /= convertedFeedback[0];
        }
      }
      const bufferLength = 32;
      const xBuffer = new Float32Array(bufferLength);
      const yBuffer = new Float32Array(bufferLength);
      const filteredBuffer = nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels, renderedBuffer.length, renderedBuffer.sampleRate);
      const numberOfChannels = renderedBuffer.numberOfChannels;
      for (let i = 0; i < numberOfChannels; i += 1) {
        const input = renderedBuffer.getChannelData(i);
        const output = filteredBuffer.getChannelData(i);
        xBuffer.fill(0);
        yBuffer.fill(0);
        filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffer, yBuffer, 0, bufferLength, input, output);
      }
      return filteredBuffer;
    };
    createIIRFilterNodeRendererFactory = (createNativeAudioBufferSourceNode2, getNativeAudioNode2, nativeOfflineAudioContextConstructor2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
      return (feedback, feedforward) => {
        const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
        let filteredBufferPromise = null;
        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeAudioBufferSourceNode = null;
          let nativeIIRFilterNode = getNativeAudioNode2(proxy);
          const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);
          if (nativeOfflineAudioContext.createIIRFilter === void 0) {
            nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeOfflineAudioContext, {
              buffer: null,
              channelCount: 2,
              channelCountMode: "max",
              channelInterpretation: "speakers",
              loop: false,
              loopEnd: 0,
              loopStart: 0,
              playbackRate: 1
            });
          } else if (!nativeIIRFilterNodeIsOwnedByContext) {
            nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(feedforward, feedback);
          }
          renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode);
          if (nativeAudioBufferSourceNode !== null) {
            if (filteredBufferPromise === null) {
              if (nativeOfflineAudioContextConstructor2 === null) {
                throw new Error("Missing the native OfflineAudioContext constructor.");
              }
              const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(
                // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.
                proxy.context.destination.channelCount,
                // Bug #17: Safari does not yet expose the length.
                proxy.context.length,
                nativeOfflineAudioContext.sampleRate
              );
              filteredBufferPromise = (async () => {
                await renderInputsOfAudioNode2(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);
                const renderedBuffer = await renderNativeOfflineAudioContext2(partialOfflineAudioContext);
                return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);
              })();
            }
            const filteredBuffer = await filteredBufferPromise;
            nativeAudioBufferSourceNode.buffer = filteredBuffer;
            nativeAudioBufferSourceNode.start(0);
            return nativeAudioBufferSourceNode;
          }
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);
          return nativeIIRFilterNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
            if (renderedNativeAudioNode !== void 0) {
              return Promise.resolve(renderedNativeAudioNode);
            }
            return createAudioNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js
var createIncrementCycleCounterFactory;
var init_increment_cycle_counter_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/increment-cycle-counter-factory.js"() {
    init_audio_node_output_connection();
    createIncrementCycleCounterFactory = (cycleCounters, disconnectNativeAudioNodeFromNativeAudioNode2, getAudioNodeConnections2, getNativeAudioNode2, getNativeAudioParam2, isActiveAudioNode2) => {
      return (isOffline) => {
        return (audioNode, count) => {
          const cycleCounter = cycleCounters.get(audioNode);
          if (cycleCounter === void 0) {
            if (!isOffline && isActiveAudioNode2(audioNode)) {
              const nativeSourceAudioNode = getNativeAudioNode2(audioNode);
              const { outputs } = getAudioNodeConnections2(audioNode);
              for (const output of outputs) {
                if (isAudioNodeOutputConnection(output)) {
                  const nativeDestinationAudioNode = getNativeAudioNode2(output[0]);
                  disconnectNativeAudioNodeFromNativeAudioNode2(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);
                } else {
                  const nativeDestinationAudioParam = getNativeAudioParam2(output[0]);
                  nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);
                }
              }
            }
            cycleCounters.set(audioNode, count);
          } else {
            cycleCounters.set(audioNode, cycleCounter + count);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js
var createIsAnyAudioContext;
var init_is_any_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-context.js"() {
    createIsAnyAudioContext = (contextStore, isNativeAudioContext2) => {
      return (anything) => {
        const nativeContext = contextStore.get(anything);
        return isNativeAudioContext2(nativeContext) || isNativeAudioContext2(anything);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js
var createIsAnyAudioNode;
var init_is_any_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-node.js"() {
    createIsAnyAudioNode = (audioNodeStore, isNativeAudioNode3) => {
      return (anything) => audioNodeStore.has(anything) || isNativeAudioNode3(anything);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js
var createIsAnyAudioParam;
var init_is_any_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-any-audio-param.js"() {
    createIsAnyAudioParam = (audioParamStore, isNativeAudioParam2) => {
      return (anything) => audioParamStore.has(anything) || isNativeAudioParam2(anything);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js
var createIsAnyOfflineAudioContext;
var init_is_any_offline_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-any-offline-audio-context.js"() {
    createIsAnyOfflineAudioContext = (contextStore, isNativeOfflineAudioContext2) => {
      return (anything) => {
        const nativeContext = contextStore.get(anything);
        return isNativeOfflineAudioContext2(nativeContext) || isNativeOfflineAudioContext2(anything);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js
var createIsNativeAudioContext;
var init_is_native_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-context.js"() {
    createIsNativeAudioContext = (nativeAudioContextConstructor2) => {
      return (anything) => {
        return nativeAudioContextConstructor2 !== null && anything instanceof nativeAudioContextConstructor2;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js
var createIsNativeAudioNode;
var init_is_native_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-node.js"() {
    createIsNativeAudioNode = (window5) => {
      return (anything) => {
        return window5 !== null && typeof window5.AudioNode === "function" && anything instanceof window5.AudioNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js
var createIsNativeAudioParam;
var init_is_native_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-native-audio-param.js"() {
    createIsNativeAudioParam = (window5) => {
      return (anything) => {
        return window5 !== null && typeof window5.AudioParam === "function" && anything instanceof window5.AudioParam;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js
var createIsNativeContext;
var init_is_native_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-native-context.js"() {
    createIsNativeContext = (isNativeAudioContext2, isNativeOfflineAudioContext2) => {
      return (anything) => {
        return isNativeAudioContext2(anything) || isNativeOfflineAudioContext2(anything);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js
var createIsNativeOfflineAudioContext;
var init_is_native_offline_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-native-offline-audio-context.js"() {
    createIsNativeOfflineAudioContext = (nativeOfflineAudioContextConstructor2) => {
      return (anything) => {
        return nativeOfflineAudioContextConstructor2 !== null && anything instanceof nativeOfflineAudioContextConstructor2;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js
var createIsSecureContext;
var init_is_secure_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-secure-context.js"() {
    createIsSecureContext = (window5) => window5 !== null && window5.isSecureContext;
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/is-supported-promise.js
var init_is_supported_promise2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/is-supported-promise.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js
var createMediaElementAudioSourceNodeConstructor;
var init_media_element_audio_source_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/media-element-audio-source-node-constructor.js"() {
    createMediaElementAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaElementAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
      return class MediaElementAudioSourceNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode2(nativeContext, options);
          if (isNativeOfflineAudioContext2(nativeContext)) {
            throw TypeError();
          }
          super(context, true, nativeMediaElementAudioSourceNode, null);
          this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;
        }
        get mediaElement() {
          return this._nativeMediaElementAudioSourceNode.mediaElement;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js
var DEFAULT_OPTIONS14, createMediaStreamAudioDestinationNodeConstructor;
var init_media_stream_audio_destination_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-destination-node-constructor.js"() {
    DEFAULT_OPTIONS14 = {
      channelCount: 2,
      channelCountMode: "explicit",
      channelInterpretation: "speakers"
    };
    createMediaStreamAudioDestinationNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioDestinationNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
      return class MediaStreamAudioDestinationNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          if (isNativeOfflineAudioContext2(nativeContext)) {
            throw new TypeError();
          }
          const mergedOptions = { ...DEFAULT_OPTIONS14, ...options };
          const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode2(nativeContext, mergedOptions);
          super(context, false, nativeMediaStreamAudioDestinationNode, null);
          this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;
        }
        get stream() {
          return this._nativeMediaStreamAudioDestinationNode.stream;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js
var createMediaStreamAudioSourceNodeConstructor;
var init_media_stream_audio_source_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/media-stream-audio-source-node-constructor.js"() {
    createMediaStreamAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamAudioSourceNode2, getNativeContext2, isNativeOfflineAudioContext2) => {
      return class MediaStreamAudioSourceNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode2(nativeContext, options);
          if (isNativeOfflineAudioContext2(nativeContext)) {
            throw new TypeError();
          }
          super(context, true, nativeMediaStreamAudioSourceNode, null);
          this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;
        }
        get mediaStream() {
          return this._nativeMediaStreamAudioSourceNode.mediaStream;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js
var createMediaStreamTrackAudioSourceNodeConstructor;
var init_media_stream_track_audio_source_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/media-stream-track-audio-source-node-constructor.js"() {
    createMediaStreamTrackAudioSourceNodeConstructor = (audioNodeConstructor2, createNativeMediaStreamTrackAudioSourceNode2, getNativeContext2) => {
      return class MediaStreamTrackAudioSourceNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode2(nativeContext, options);
          super(context, true, nativeMediaStreamTrackAudioSourceNode, null);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js
var createMinimalAudioContextConstructor;
var init_minimal_audio_context_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/minimal-audio-context-constructor.js"() {
    init_deactivate_audio_graph();
    init_is_valid_latency_hint();
    createMinimalAudioContextConstructor = (createInvalidStateError3, createNotSupportedError3, createUnknownError2, minimalBaseAudioContextConstructor2, nativeAudioContextConstructor2) => {
      return class MinimalAudioContext extends minimalBaseAudioContextConstructor2 {
        constructor(options = {}) {
          if (nativeAudioContextConstructor2 === null) {
            throw new Error("Missing the native AudioContext constructor.");
          }
          let nativeAudioContext;
          try {
            nativeAudioContext = new nativeAudioContextConstructor2(options);
          } catch (err) {
            if (err.code === 12 && err.message === "sampleRate is not in range") {
              throw createNotSupportedError3();
            }
            throw err;
          }
          if (nativeAudioContext === null) {
            throw createUnknownError2();
          }
          if (!isValidLatencyHint(options.latencyHint)) {
            throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);
          }
          if (options.sampleRate !== void 0 && nativeAudioContext.sampleRate !== options.sampleRate) {
            throw createNotSupportedError3();
          }
          super(nativeAudioContext, 2);
          const { latencyHint } = options;
          const { sampleRate } = nativeAudioContext;
          this._baseLatency = typeof nativeAudioContext.baseLatency === "number" ? nativeAudioContext.baseLatency : latencyHint === "balanced" ? 512 / sampleRate : latencyHint === "interactive" || latencyHint === void 0 ? 256 / sampleRate : latencyHint === "playback" ? 1024 / sampleRate : (
            /*
             * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a
             * ScriptProcessorNode.
             */
            Math.max(2, Math.min(128, Math.round(latencyHint * sampleRate / 128))) * 128 / sampleRate
          );
          this._nativeAudioContext = nativeAudioContext;
          if (nativeAudioContextConstructor2.name === "webkitAudioContext") {
            this._nativeGainNode = nativeAudioContext.createGain();
            this._nativeOscillatorNode = nativeAudioContext.createOscillator();
            this._nativeGainNode.gain.value = 1e-37;
            this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);
            this._nativeOscillatorNode.start();
          } else {
            this._nativeGainNode = null;
            this._nativeOscillatorNode = null;
          }
          this._state = null;
          if (nativeAudioContext.state === "running") {
            this._state = "suspended";
            const revokeState = () => {
              if (this._state === "suspended") {
                this._state = null;
              }
              nativeAudioContext.removeEventListener("statechange", revokeState);
            };
            nativeAudioContext.addEventListener("statechange", revokeState);
          }
        }
        get baseLatency() {
          return this._baseLatency;
        }
        get state() {
          return this._state !== null ? this._state : this._nativeAudioContext.state;
        }
        close() {
          if (this.state === "closed") {
            return this._nativeAudioContext.close().then(() => {
              throw createInvalidStateError3();
            });
          }
          if (this._state === "suspended") {
            this._state = null;
          }
          return this._nativeAudioContext.close().then(() => {
            if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {
              this._nativeOscillatorNode.stop();
              this._nativeGainNode.disconnect();
              this._nativeOscillatorNode.disconnect();
            }
            deactivateAudioGraph(this);
          });
        }
        resume() {
          if (this._state === "suspended") {
            return new Promise((resolve, reject) => {
              const resolvePromise = () => {
                this._nativeAudioContext.removeEventListener("statechange", resolvePromise);
                if (this._nativeAudioContext.state === "running") {
                  resolve();
                } else {
                  this.resume().then(resolve, reject);
                }
              };
              this._nativeAudioContext.addEventListener("statechange", resolvePromise);
            });
          }
          return this._nativeAudioContext.resume().catch((err) => {
            if (err === void 0 || err.code === 15) {
              throw createInvalidStateError3();
            }
            throw err;
          });
        }
        suspend() {
          return this._nativeAudioContext.suspend().catch((err) => {
            if (err === void 0) {
              throw createInvalidStateError3();
            }
            throw err;
          });
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js
var createMinimalBaseAudioContextConstructor;
var init_minimal_base_audio_context_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/minimal-base-audio-context-constructor.js"() {
    init_globals();
    createMinimalBaseAudioContextConstructor = (audioDestinationNodeConstructor2, createAudioListener2, eventTargetConstructor2, isNativeOfflineAudioContext2, unrenderedAudioWorkletNodeStore2, wrapEventListener3) => {
      return class MinimalBaseAudioContext extends eventTargetConstructor2 {
        constructor(_nativeContext, numberOfChannels) {
          super(_nativeContext);
          this._nativeContext = _nativeContext;
          CONTEXT_STORE.set(this, _nativeContext);
          if (isNativeOfflineAudioContext2(_nativeContext)) {
            unrenderedAudioWorkletNodeStore2.set(_nativeContext, /* @__PURE__ */ new Set());
          }
          this._destination = new audioDestinationNodeConstructor2(this, numberOfChannels);
          this._listener = createAudioListener2(this, _nativeContext);
          this._onstatechange = null;
        }
        get currentTime() {
          return this._nativeContext.currentTime;
        }
        get destination() {
          return this._destination;
        }
        get listener() {
          return this._listener;
        }
        get onstatechange() {
          return this._onstatechange;
        }
        set onstatechange(value) {
          const wrappedListener = typeof value === "function" ? wrapEventListener3(this, value) : null;
          this._nativeContext.onstatechange = wrappedListener;
          const nativeOnStateChange = this._nativeContext.onstatechange;
          this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;
        }
        get sampleRate() {
          return this._nativeContext.sampleRate;
        }
        get state() {
          return this._nativeContext.state;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js
var testPromiseSupport;
var init_test_promise_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-promise-support.js"() {
    testPromiseSupport = (nativeContext) => {
      const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);
      try {
        const promise2 = nativeContext.decodeAudioData(uint32Array.buffer, () => {
        });
        if (promise2 === void 0) {
          return false;
        }
        promise2.catch(() => {
        });
        return true;
      } catch {
      }
      return false;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/minimal-offline-audio-context-constructor.js
var DEFAULT_OPTIONS15, createMinimalOfflineAudioContextConstructor;
var init_minimal_offline_audio_context_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/minimal-offline-audio-context-constructor.js"() {
    init_deactivate_audio_graph();
    init_test_promise_support();
    DEFAULT_OPTIONS15 = {
      numberOfChannels: 1
    };
    createMinimalOfflineAudioContextConstructor = (cacheTestResult2, createInvalidStateError3, createNativeOfflineAudioContext2, minimalBaseAudioContextConstructor2, startRendering2) => {
      return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor2 {
        constructor(options) {
          const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS15, ...options };
          const nativeOfflineAudioContext = createNativeOfflineAudioContext2(numberOfChannels, length, sampleRate);
          if (!cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
            nativeOfflineAudioContext.addEventListener("statechange", /* @__PURE__ */ (() => {
              let i = 0;
              const delayStateChangeEvent = (event) => {
                if (this._state === "running") {
                  if (i > 0) {
                    nativeOfflineAudioContext.removeEventListener("statechange", delayStateChangeEvent);
                    event.stopImmediatePropagation();
                    this._waitForThePromiseToSettle(event);
                  } else {
                    i += 1;
                  }
                }
              };
              return delayStateChangeEvent;
            })());
          }
          super(nativeOfflineAudioContext, numberOfChannels);
          this._length = length;
          this._nativeOfflineAudioContext = nativeOfflineAudioContext;
          this._state = null;
        }
        get length() {
          if (this._nativeOfflineAudioContext.length === void 0) {
            return this._length;
          }
          return this._nativeOfflineAudioContext.length;
        }
        get state() {
          return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
        }
        startRendering() {
          if (this._state === "running") {
            return Promise.reject(createInvalidStateError3());
          }
          this._state = "running";
          return startRendering2(this.destination, this._nativeOfflineAudioContext).finally(() => {
            this._state = null;
            deactivateAudioGraph(this);
          });
        }
        _waitForThePromiseToSettle(event) {
          if (this._state === null) {
            this._nativeOfflineAudioContext.dispatchEvent(event);
          } else {
            setTimeout(() => this._waitForThePromiseToSettle(event));
          }
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js
var createMonitorConnections;
var init_monitor_connections = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/monitor-connections.js"() {
    createMonitorConnections = (insertElementInSet2, isNativeAudioNode3) => {
      return (nativeAudioNode, whenConnected, whenDisconnected) => {
        const connections = /* @__PURE__ */ new Set();
        nativeAudioNode.connect = /* @__PURE__ */ ((connect3) => {
          return (destination, output = 0, input = 0) => {
            const wasDisconnected = connections.size === 0;
            if (isNativeAudioNode3(destination)) {
              connect3.call(nativeAudioNode, destination, output, input);
              insertElementInSet2(connections, [destination, output, input], (connection) => connection[0] === destination && connection[1] === output && connection[2] === input, true);
              if (wasDisconnected) {
                whenConnected();
              }
              return destination;
            }
            connect3.call(nativeAudioNode, destination, output);
            insertElementInSet2(connections, [destination, output], (connection) => connection[0] === destination && connection[1] === output, true);
            if (wasDisconnected) {
              whenConnected();
            }
            return;
          };
        })(nativeAudioNode.connect);
        nativeAudioNode.disconnect = /* @__PURE__ */ ((disconnect3) => {
          return (destinationOrOutput, output, input) => {
            const wasConnected = connections.size > 0;
            if (destinationOrOutput === void 0) {
              disconnect3.apply(nativeAudioNode);
              connections.clear();
            } else if (typeof destinationOrOutput === "number") {
              disconnect3.call(nativeAudioNode, destinationOrOutput);
              for (const connection of connections) {
                if (connection[1] === destinationOrOutput) {
                  connections.delete(connection);
                }
              }
            } else {
              if (isNativeAudioNode3(destinationOrOutput)) {
                disconnect3.call(nativeAudioNode, destinationOrOutput, output, input);
              } else {
                disconnect3.call(nativeAudioNode, destinationOrOutput, output);
              }
              for (const connection of connections) {
                if (connection[0] === destinationOrOutput && (output === void 0 || connection[1] === output) && (input === void 0 || connection[2] === input)) {
                  connections.delete(connection);
                }
              }
            }
            const isDisconnected = connections.size === 0;
            if (wasConnected && isDisconnected) {
              whenDisconnected();
            }
          };
        })(nativeAudioNode.disconnect);
        return nativeAudioNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js
var assignNativeAudioNodeOption;
var init_assign_native_audio_node_option = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-option.js"() {
    assignNativeAudioNodeOption = (nativeAudioNode, options, option) => {
      const value = options[option];
      if (value !== void 0 && value !== nativeAudioNode[option]) {
        nativeAudioNode[option] = value;
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js
var assignNativeAudioNodeOptions;
var init_assign_native_audio_node_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-options.js"() {
    init_assign_native_audio_node_option();
    assignNativeAudioNodeOptions = (nativeAudioNode, options) => {
      assignNativeAudioNodeOption(nativeAudioNode, options, "channelCount");
      assignNativeAudioNodeOption(nativeAudioNode, options, "channelCountMode");
      assignNativeAudioNodeOption(nativeAudioNode, options, "channelInterpretation");
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js
var testAnalyserNodeGetFloatTimeDomainDataMethodSupport;
var init_test_analyser_node_get_float_time_domain_data_method_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-analyser-node-get-float-time-domain-data-method-support.js"() {
    testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode) => {
      return typeof nativeAnalyserNode.getFloatTimeDomainData === "function";
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js
var wrapAnalyserNodeGetFloatTimeDomainDataMethod;
var init_wrap_analyser_node_get_float_time_domain_data_method = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-analyser-node-get-float-time-domain-data-method.js"() {
    wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode) => {
      nativeAnalyserNode.getFloatTimeDomainData = (array2) => {
        const byteTimeDomainData = new Uint8Array(array2.length);
        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);
        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);
        for (let i = 0; i < length; i += 1) {
          array2[i] = (byteTimeDomainData[i] - 128) * 78125e-7;
        }
        return array2;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js
var createNativeAnalyserNodeFactory;
var init_native_analyser_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-analyser-node-factory.js"() {
    init_assign_native_audio_node_option();
    init_assign_native_audio_node_options();
    init_test_analyser_node_get_float_time_domain_data_method_support();
    init_wrap_analyser_node_get_float_time_domain_data_method();
    createNativeAnalyserNodeFactory = (cacheTestResult2, createIndexSizeError2) => {
      return (nativeContext, options) => {
        const nativeAnalyserNode = nativeContext.createAnalyser();
        assignNativeAudioNodeOptions(nativeAnalyserNode, options);
        if (!(options.maxDecibels > options.minDecibels)) {
          throw createIndexSizeError2();
        }
        assignNativeAudioNodeOption(nativeAnalyserNode, options, "fftSize");
        assignNativeAudioNodeOption(nativeAnalyserNode, options, "maxDecibels");
        assignNativeAudioNodeOption(nativeAnalyserNode, options, "minDecibels");
        assignNativeAudioNodeOption(nativeAnalyserNode, options, "smoothingTimeConstant");
        if (!cacheTestResult2(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () => testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))) {
          wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);
        }
        return nativeAnalyserNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js
var createNativeAudioBufferConstructor;
var init_native_audio_buffer_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-constructor.js"() {
    createNativeAudioBufferConstructor = (window5) => {
      if (window5 === null) {
        return null;
      }
      if (window5.hasOwnProperty("AudioBuffer")) {
        return window5.AudioBuffer;
      }
      return null;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js
var assignNativeAudioNodeAudioParamValue;
var init_assign_native_audio_node_audio_param_value = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/assign-native-audio-node-audio-param-value.js"() {
    assignNativeAudioNodeAudioParamValue = (nativeAudioNode, options, audioParam) => {
      const value = options[audioParam];
      if (value !== void 0 && value !== nativeAudioNode[audioParam].value) {
        nativeAudioNode[audioParam].value = value;
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js
var wrapAudioBufferSourceNodeStartMethodConsecutiveCalls;
var init_wrap_audio_buffer_source_node_start_method_consecutive_calls = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.js"() {
    init_invalid_state_error2();
    wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode) => {
      nativeAudioBufferSourceNode.start = /* @__PURE__ */ ((start) => {
        let isScheduled = false;
        return (when = 0, offset = 0, duration3) => {
          if (isScheduled) {
            throw createInvalidStateError2();
          }
          start.call(nativeAudioBufferSourceNode, when, offset, duration3);
          isScheduled = true;
        };
      })(nativeAudioBufferSourceNode.start);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js
var wrapAudioScheduledSourceNodeStartMethodNegativeParameters;
var init_wrap_audio_scheduled_source_node_start_method_negative_parameters = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.js"() {
    wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {
      nativeAudioScheduledSourceNode.start = /* @__PURE__ */ ((start) => {
        return (when = 0, offset = 0, duration3) => {
          if (typeof duration3 === "number" && duration3 < 0 || offset < 0 || when < 0) {
            throw new RangeError("The parameters can't be negative.");
          }
          start.call(nativeAudioScheduledSourceNode, when, offset, duration3);
        };
      })(nativeAudioScheduledSourceNode.start);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js
var wrapAudioScheduledSourceNodeStopMethodNegativeParameters;
var init_wrap_audio_scheduled_source_node_stop_method_negative_parameters = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.js"() {
    wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (nativeAudioScheduledSourceNode) => {
      nativeAudioScheduledSourceNode.stop = /* @__PURE__ */ ((stop) => {
        return (when = 0) => {
          if (when < 0) {
            throw new RangeError("The parameter can't be negative.");
          }
          stop.call(nativeAudioScheduledSourceNode, when);
        };
      })(nativeAudioScheduledSourceNode.stop);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js
var createNativeAudioBufferSourceNodeFactory;
var init_native_audio_buffer_source_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-audio-buffer-source-node-factory.js"() {
    init_assign_native_audio_node_audio_param_value();
    init_assign_native_audio_node_option();
    init_assign_native_audio_node_options();
    init_wrap_audio_buffer_source_node_start_method_consecutive_calls();
    init_wrap_audio_scheduled_source_node_start_method_negative_parameters();
    init_wrap_audio_scheduled_source_node_stop_method_negative_parameters();
    createNativeAudioBufferSourceNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioBufferSourceNodeStartMethodOffsetClampling, wrapAudioBufferSourceNodeStopMethodNullifiedBuffer, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {
      return (nativeContext, options) => {
        const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);
        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, "playbackRate");
        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, "buffer");
        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, "loop");
        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, "loopEnd");
        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, "loopStart");
        if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2, () => testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport2(nativeContext))) {
          wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);
        }
        if (!cacheTestResult2(testAudioBufferSourceNodeStartMethodOffsetClampingSupport2, () => testAudioBufferSourceNodeStartMethodOffsetClampingSupport2(nativeContext))) {
          wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);
        }
        if (!cacheTestResult2(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2, () => testAudioBufferSourceNodeStopMethodNullifiedBufferSupport2(nativeContext))) {
          wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);
        }
        if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
          wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);
        }
        if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {
          wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeAudioBufferSourceNode, nativeContext);
        }
        if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
          wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);
        }
        addSilentConnection2(nativeContext, nativeAudioBufferSourceNode);
        return nativeAudioBufferSourceNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js
var createNativeAudioContextConstructor;
var init_native_audio_context_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-audio-context-constructor.js"() {
    createNativeAudioContextConstructor = (window5) => {
      if (window5 === null) {
        return null;
      }
      if (window5.hasOwnProperty("AudioContext")) {
        return window5.AudioContext;
      }
      return window5.hasOwnProperty("webkitAudioContext") ? window5.webkitAudioContext : null;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js
var createNativeAudioDestinationNodeFactory;
var init_native_audio_destination_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-audio-destination-node.js"() {
    createNativeAudioDestinationNodeFactory = (createNativeGainNode2, overwriteAccessors2) => {
      return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {
        const nativeAudioDestinationNode = nativeContext.destination;
        if (nativeAudioDestinationNode.channelCount !== channelCount) {
          try {
            nativeAudioDestinationNode.channelCount = channelCount;
          } catch {
          }
        }
        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== "explicit") {
          nativeAudioDestinationNode.channelCountMode = "explicit";
        }
        if (nativeAudioDestinationNode.maxChannelCount === 0) {
          Object.defineProperty(nativeAudioDestinationNode, "maxChannelCount", {
            value: channelCount
          });
        }
        const gainNode = createNativeGainNode2(nativeContext, {
          channelCount,
          channelCountMode: nativeAudioDestinationNode.channelCountMode,
          channelInterpretation: nativeAudioDestinationNode.channelInterpretation,
          gain: 1
        });
        overwriteAccessors2(gainNode, "channelCount", (get) => () => get.call(gainNode), (set2) => (value) => {
          set2.call(gainNode, value);
          try {
            nativeAudioDestinationNode.channelCount = value;
          } catch (err) {
            if (value > nativeAudioDestinationNode.maxChannelCount) {
              throw err;
            }
          }
        });
        overwriteAccessors2(gainNode, "channelCountMode", (get) => () => get.call(gainNode), (set2) => (value) => {
          set2.call(gainNode, value);
          nativeAudioDestinationNode.channelCountMode = value;
        });
        overwriteAccessors2(gainNode, "channelInterpretation", (get) => () => get.call(gainNode), (set2) => (value) => {
          set2.call(gainNode, value);
          nativeAudioDestinationNode.channelInterpretation = value;
        });
        Object.defineProperty(gainNode, "maxChannelCount", {
          get: () => nativeAudioDestinationNode.maxChannelCount
        });
        gainNode.connect(nativeAudioDestinationNode);
        return gainNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js
var createNativeAudioWorkletNodeConstructor;
var init_native_audio_worklet_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-constructor.js"() {
    createNativeAudioWorkletNodeConstructor = (window5) => {
      if (window5 === null) {
        return null;
      }
      return window5.hasOwnProperty("AudioWorkletNode") ? window5.AudioWorkletNode : null;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js
var testClonabilityOfAudioWorkletNodeOptions;
var init_test_clonability_of_audio_worklet_node_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-clonability-of-audio-worklet-node-options.js"() {
    testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {
      const { port1 } = new MessageChannel();
      try {
        port1.postMessage(audioWorkletNodeOptions);
      } finally {
        port1.close();
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js
var createNativeAudioWorkletNodeFactory;
var init_native_audio_worklet_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-factory.js"() {
    init_test_clonability_of_audio_worklet_node_options();
    createNativeAudioWorkletNodeFactory = (createInvalidStateError3, createNativeAudioWorkletNodeFaker2, createNativeGainNode2, createNotSupportedError3, monitorConnections2) => {
      return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor2, name, processorConstructor, options) => {
        if (nativeAudioWorkletNodeConstructor2 !== null) {
          try {
            const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor2(nativeContext, name, options);
            const patchedEventListeners = /* @__PURE__ */ new Map();
            let onprocessorerror = null;
            Object.defineProperties(nativeAudioWorkletNode, {
              /*
               * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some
               * browsers have no native implementation to achieve a consistent behavior.
               */
              channelCount: {
                get: () => options.channelCount,
                set: () => {
                  throw createInvalidStateError3();
                }
              },
              channelCountMode: {
                get: () => "explicit",
                set: () => {
                  throw createInvalidStateError3();
                }
              },
              // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.
              onprocessorerror: {
                get: () => onprocessorerror,
                set: (value) => {
                  if (typeof onprocessorerror === "function") {
                    nativeAudioWorkletNode.removeEventListener("processorerror", onprocessorerror);
                  }
                  onprocessorerror = typeof value === "function" ? value : null;
                  if (typeof onprocessorerror === "function") {
                    nativeAudioWorkletNode.addEventListener("processorerror", onprocessorerror);
                  }
                }
              }
            });
            nativeAudioWorkletNode.addEventListener = /* @__PURE__ */ ((addEventListener) => {
              return (...args) => {
                if (args[0] === "processorerror") {
                  const unpatchedEventListener = typeof args[1] === "function" ? args[1] : typeof args[1] === "object" && args[1] !== null && typeof args[1].handleEvent === "function" ? args[1].handleEvent : null;
                  if (unpatchedEventListener !== null) {
                    const patchedEventListener = patchedEventListeners.get(args[1]);
                    if (patchedEventListener !== void 0) {
                      args[1] = patchedEventListener;
                    } else {
                      args[1] = (event) => {
                        if (event.type === "error") {
                          Object.defineProperties(event, {
                            type: { value: "processorerror" }
                          });
                          unpatchedEventListener(event);
                        } else {
                          unpatchedEventListener(new ErrorEvent(args[0], { ...event }));
                        }
                      };
                      patchedEventListeners.set(unpatchedEventListener, args[1]);
                    }
                  }
                }
                addEventListener.call(nativeAudioWorkletNode, "error", args[1], args[2]);
                return addEventListener.call(nativeAudioWorkletNode, ...args);
              };
            })(nativeAudioWorkletNode.addEventListener);
            nativeAudioWorkletNode.removeEventListener = /* @__PURE__ */ ((removeEventListener) => {
              return (...args) => {
                if (args[0] === "processorerror") {
                  const patchedEventListener = patchedEventListeners.get(args[1]);
                  if (patchedEventListener !== void 0) {
                    patchedEventListeners.delete(args[1]);
                    args[1] = patchedEventListener;
                  }
                }
                removeEventListener.call(nativeAudioWorkletNode, "error", args[1], args[2]);
                return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);
              };
            })(nativeAudioWorkletNode.removeEventListener);
            if (options.numberOfOutputs !== 0) {
              const nativeGainNode = createNativeGainNode2(nativeContext, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "discrete",
                gain: 0
              });
              nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);
              const whenConnected = () => nativeGainNode.disconnect();
              const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);
              return monitorConnections2(nativeAudioWorkletNode, whenConnected, whenDisconnected);
            }
            return nativeAudioWorkletNode;
          } catch (err) {
            if (err.code === 11) {
              throw createNotSupportedError3();
            }
            throw err;
          }
        }
        if (processorConstructor === void 0) {
          throw createNotSupportedError3();
        }
        testClonabilityOfAudioWorkletNodeOptions(options);
        return createNativeAudioWorkletNodeFaker2(nativeContext, baseLatency, processorConstructor, options);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js
var computeBufferSize;
var init_compute_buffer_size = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/compute-buffer-size.js"() {
    computeBufferSize = (baseLatency, sampleRate) => {
      if (baseLatency === null) {
        return 512;
      }
      return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js
var cloneAudioWorkletNodeOptions;
var init_clone_audio_worklet_node_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/clone-audio-worklet-node-options.js"() {
    cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions) => {
      return new Promise((resolve, reject) => {
        const { port1, port2 } = new MessageChannel();
        port1.onmessage = ({ data }) => {
          port1.close();
          port2.close();
          resolve(data);
        };
        port1.onmessageerror = ({ data }) => {
          port1.close();
          port2.close();
          reject(data);
        };
        port2.postMessage(audioWorkletNodeOptions);
      });
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js
var createAudioWorkletProcessorPromise;
var init_create_audio_worklet_processor_promise = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor-promise.js"() {
    init_clone_audio_worklet_node_options();
    createAudioWorkletProcessorPromise = async (processorConstructor, audioWorkletNodeOptions) => {
      const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);
      return new processorConstructor(clonedAudioWorkletNodeOptions);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js
var createAudioWorkletProcessor;
var init_create_audio_worklet_processor = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/create-audio-worklet-processor.js"() {
    init_globals();
    init_create_audio_worklet_processor_promise();
    createAudioWorkletProcessor = (nativeContext, nativeAudioWorkletNode, processorConstructor, audioWorkletNodeOptions) => {
      let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);
      if (nodeToProcessorMap === void 0) {
        nodeToProcessorMap = /* @__PURE__ */ new WeakMap();
        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);
      }
      const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);
      nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);
      return audioWorkletProcessorPromise;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js
var createNativeAudioWorkletNodeFakerFactory;
var init_native_audio_worklet_node_faker_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-audio-worklet-node-faker-factory.js"() {
    init_constants();
    init_compute_buffer_size();
    init_copy_from_channel();
    init_copy_to_channel();
    init_create_audio_worklet_processor();
    init_create_nested_arrays();
    init_read_only_map();
    createNativeAudioWorkletNodeFakerFactory = (connectMultipleOutputs2, createIndexSizeError2, createInvalidStateError3, createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNotSupportedError3, disconnectMultipleOutputs2, exposeCurrentFrameAndCurrentTime2, getActiveAudioWorkletNodeInputs2, monitorConnections2) => {
      return (nativeContext, baseLatency, processorConstructor, options) => {
        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {
          throw createNotSupportedError3();
        }
        const outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount);
        if (outputChannelCount.some((channelCount) => channelCount < 1)) {
          throw createNotSupportedError3();
        }
        if (outputChannelCount.length !== options.numberOfOutputs) {
          throw createIndexSizeError2();
        }
        if (options.channelCountMode !== "explicit") {
          throw createNotSupportedError3();
        }
        const numberOfInputChannels = options.channelCount * options.numberOfInputs;
        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);
        const numberOfParameters = processorConstructor.parameterDescriptors === void 0 ? 0 : processorConstructor.parameterDescriptors.length;
        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {
          throw createNotSupportedError3();
        }
        const messageChannel = new MessageChannel();
        const gainNodes = [];
        const inputChannelSplitterNodes = [];
        for (let i = 0; i < options.numberOfInputs; i += 1) {
          gainNodes.push(createNativeGainNode2(nativeContext, {
            channelCount: options.channelCount,
            channelCountMode: options.channelCountMode,
            channelInterpretation: options.channelInterpretation,
            gain: 1
          }));
          inputChannelSplitterNodes.push(createNativeChannelSplitterNode2(nativeContext, {
            channelCount: options.channelCount,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            numberOfOutputs: options.channelCount
          }));
        }
        const constantSourceNodes = [];
        if (processorConstructor.parameterDescriptors !== void 0) {
          for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {
            const constantSourceNode = createNativeConstantSourceNode2(nativeContext, {
              channelCount: 1,
              channelCountMode: "explicit",
              channelInterpretation: "discrete",
              offset: options.parameterData[name] !== void 0 ? options.parameterData[name] : defaultValue === void 0 ? 0 : defaultValue
            });
            Object.defineProperties(constantSourceNode.offset, {
              defaultValue: {
                get: () => defaultValue === void 0 ? 0 : defaultValue
              },
              maxValue: {
                get: () => maxValue === void 0 ? MOST_POSITIVE_SINGLE_FLOAT : maxValue
              },
              minValue: {
                get: () => minValue === void 0 ? MOST_NEGATIVE_SINGLE_FLOAT : minValue
              }
            });
            constantSourceNodes.push(constantSourceNode);
          }
        }
        const inputChannelMergerNode = createNativeChannelMergerNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "speakers",
          numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)
        });
        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
        const scriptProcessorNode = createNativeScriptProcessorNode2(
          nativeContext,
          bufferSize,
          numberOfInputChannels + numberOfParameters,
          // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.
          Math.max(1, numberOfOutputChannels)
        );
        const outputChannelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {
          channelCount: Math.max(1, numberOfOutputChannels),
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          numberOfOutputs: Math.max(1, numberOfOutputChannels)
        });
        const outputChannelMergerNodes = [];
        for (let i = 0; i < options.numberOfOutputs; i += 1) {
          outputChannelMergerNodes.push(createNativeChannelMergerNode2(nativeContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "speakers",
            numberOfInputs: outputChannelCount[i]
          }));
        }
        for (let i = 0; i < options.numberOfInputs; i += 1) {
          gainNodes[i].connect(inputChannelSplitterNodes[i]);
          for (let j = 0; j < options.channelCount; j += 1) {
            inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);
          }
        }
        const parameterMap = new ReadOnlyMap(processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.map(({ name }, index) => {
          const constantSourceNode = constantSourceNodes[index];
          constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);
          constantSourceNode.start(0);
          return [name, constantSourceNode.offset];
        }));
        inputChannelMergerNode.connect(scriptProcessorNode);
        let channelInterpretation = options.channelInterpretation;
        let onprocessorerror = null;
        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;
        const nativeAudioWorkletNodeFaker = {
          get bufferSize() {
            return bufferSize;
          },
          get channelCount() {
            return options.channelCount;
          },
          set channelCount(_) {
            throw createInvalidStateError3();
          },
          get channelCountMode() {
            return options.channelCountMode;
          },
          set channelCountMode(_) {
            throw createInvalidStateError3();
          },
          get channelInterpretation() {
            return channelInterpretation;
          },
          set channelInterpretation(value) {
            for (const gainNode of gainNodes) {
              gainNode.channelInterpretation = value;
            }
            channelInterpretation = value;
          },
          get context() {
            return scriptProcessorNode.context;
          },
          get inputs() {
            return gainNodes;
          },
          get numberOfInputs() {
            return options.numberOfInputs;
          },
          get numberOfOutputs() {
            return options.numberOfOutputs;
          },
          get onprocessorerror() {
            return onprocessorerror;
          },
          set onprocessorerror(value) {
            if (typeof onprocessorerror === "function") {
              nativeAudioWorkletNodeFaker.removeEventListener("processorerror", onprocessorerror);
            }
            onprocessorerror = typeof value === "function" ? value : null;
            if (typeof onprocessorerror === "function") {
              nativeAudioWorkletNodeFaker.addEventListener("processorerror", onprocessorerror);
            }
          },
          get parameters() {
            return parameterMap;
          },
          get port() {
            return messageChannel.port2;
          },
          addEventListener(...args) {
            return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
          },
          connect: connectMultipleOutputs2.bind(null, outputAudioNodes),
          disconnect: disconnectMultipleOutputs2.bind(null, outputAudioNodes),
          dispatchEvent(...args) {
            return scriptProcessorNode.dispatchEvent(args[0]);
          },
          removeEventListener(...args) {
            return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
          }
        };
        const patchedEventListeners = /* @__PURE__ */ new Map();
        messageChannel.port1.addEventListener = /* @__PURE__ */ ((addEventListener) => {
          return (...args) => {
            if (args[0] === "message") {
              const unpatchedEventListener = typeof args[1] === "function" ? args[1] : typeof args[1] === "object" && args[1] !== null && typeof args[1].handleEvent === "function" ? args[1].handleEvent : null;
              if (unpatchedEventListener !== null) {
                const patchedEventListener = patchedEventListeners.get(args[1]);
                if (patchedEventListener !== void 0) {
                  args[1] = patchedEventListener;
                } else {
                  args[1] = (event) => {
                    exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime, nativeContext.sampleRate, () => unpatchedEventListener(event));
                  };
                  patchedEventListeners.set(unpatchedEventListener, args[1]);
                }
              }
            }
            return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);
          };
        })(messageChannel.port1.addEventListener);
        messageChannel.port1.removeEventListener = /* @__PURE__ */ ((removeEventListener) => {
          return (...args) => {
            if (args[0] === "message") {
              const patchedEventListener = patchedEventListeners.get(args[1]);
              if (patchedEventListener !== void 0) {
                patchedEventListeners.delete(args[1]);
                args[1] = patchedEventListener;
              }
            }
            return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);
          };
        })(messageChannel.port1.removeEventListener);
        let onmessage = null;
        Object.defineProperty(messageChannel.port1, "onmessage", {
          get: () => onmessage,
          set: (value) => {
            if (typeof onmessage === "function") {
              messageChannel.port1.removeEventListener("message", onmessage);
            }
            onmessage = typeof value === "function" ? value : null;
            if (typeof onmessage === "function") {
              messageChannel.port1.addEventListener("message", onmessage);
              messageChannel.port1.start();
            }
          }
        });
        processorConstructor.prototype.port = messageChannel.port1;
        let audioWorkletProcessor = null;
        const audioWorkletProcessorPromise = createAudioWorkletProcessor(nativeContext, nativeAudioWorkletNodeFaker, processorConstructor, options);
        audioWorkletProcessorPromise.then((dWrkltPrcssr) => audioWorkletProcessor = dWrkltPrcssr);
        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);
        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);
        const parameters = processorConstructor.parameterDescriptors === void 0 ? [] : processorConstructor.parameterDescriptors.reduce((prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }), {});
        let isActive = true;
        const disconnectOutputsGraph = () => {
          if (options.numberOfOutputs > 0) {
            scriptProcessorNode.disconnect(outputChannelSplitterNode);
          }
          for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {
            const outputChannelMergerNode = outputChannelMergerNodes[i];
            for (let j = 0; j < outputChannelCount[i]; j += 1) {
              outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);
            }
            outputChannelSplitterNodeOutput += outputChannelCount[i];
          }
        };
        const activeInputIndexes = /* @__PURE__ */ new Map();
        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }) => {
          if (audioWorkletProcessor !== null) {
            const activeInputs = getActiveAudioWorkletNodeInputs2(nativeAudioWorkletNodeFaker);
            for (let i = 0; i < bufferSize; i += 128) {
              for (let j = 0; j < options.numberOfInputs; j += 1) {
                for (let k = 0; k < options.channelCount; k += 1) {
                  copyFromChannel(inputBuffer, inputs[j], k, k, i);
                }
              }
              if (processorConstructor.parameterDescriptors !== void 0) {
                processorConstructor.parameterDescriptors.forEach(({ name }, index) => {
                  copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);
                });
              }
              for (let j = 0; j < options.numberOfInputs; j += 1) {
                for (let k = 0; k < outputChannelCount[j]; k += 1) {
                  if (outputs[j][k].byteLength === 0) {
                    outputs[j][k] = new Float32Array(128);
                  }
                }
              }
              try {
                const potentiallyEmptyInputs = inputs.map((input, index) => {
                  const activeInput = activeInputs[index];
                  if (activeInput.size > 0) {
                    activeInputIndexes.set(index, bufferSize / 128);
                    return input;
                  }
                  const count = activeInputIndexes.get(index);
                  if (count === void 0) {
                    return [];
                  }
                  if (input.every((channelData) => channelData.every((sample) => sample === 0))) {
                    if (count === 1) {
                      activeInputIndexes.delete(index);
                    } else {
                      activeInputIndexes.set(index, count - 1);
                    }
                  }
                  return input;
                });
                const activeSourceFlag = exposeCurrentFrameAndCurrentTime2(nativeContext.currentTime + i / nativeContext.sampleRate, nativeContext.sampleRate, () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters));
                isActive = activeSourceFlag;
                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {
                  for (let k = 0; k < outputChannelCount[j]; k += 1) {
                    copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);
                  }
                  outputChannelSplitterNodeOutput += outputChannelCount[j];
                }
              } catch (error) {
                isActive = false;
                nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent("processorerror", {
                  colno: error.colno,
                  filename: error.filename,
                  lineno: error.lineno,
                  message: error.message
                }));
              }
              if (!isActive) {
                for (let j = 0; j < options.numberOfInputs; j += 1) {
                  gainNodes[j].disconnect(inputChannelSplitterNodes[j]);
                  for (let k = 0; k < options.channelCount; k += 1) {
                    inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);
                  }
                }
                if (processorConstructor.parameterDescriptors !== void 0) {
                  const length = processorConstructor.parameterDescriptors.length;
                  for (let j = 0; j < length; j += 1) {
                    const constantSourceNode = constantSourceNodes[j];
                    constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);
                    constantSourceNode.stop();
                  }
                }
                inputChannelMergerNode.disconnect(scriptProcessorNode);
                scriptProcessorNode.onaudioprocess = null;
                if (isConnected) {
                  disconnectOutputsGraph();
                } else {
                  disconnectFakeGraph();
                }
                break;
              }
            }
          }
        };
        let isConnected = false;
        const nativeGainNode = createNativeGainNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          gain: 0
        });
        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);
        const disconnectFakeGraph = () => {
          scriptProcessorNode.disconnect(nativeGainNode);
          nativeGainNode.disconnect();
        };
        const whenConnected = () => {
          if (isActive) {
            disconnectFakeGraph();
            if (options.numberOfOutputs > 0) {
              scriptProcessorNode.connect(outputChannelSplitterNode);
            }
            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {
              const outputChannelMergerNode = outputChannelMergerNodes[i];
              for (let j = 0; j < outputChannelCount[i]; j += 1) {
                outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);
              }
              outputChannelSplitterNodeOutput += outputChannelCount[i];
            }
          }
          isConnected = true;
        };
        const whenDisconnected = () => {
          if (isActive) {
            connectFakeGraph();
            disconnectOutputsGraph();
          }
          isConnected = false;
        };
        connectFakeGraph();
        return monitorConnections2(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node.js
var createNativeBiquadFilterNode;
var init_native_biquad_filter_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-biquad-filter-node.js"() {
    init_assign_native_audio_node_audio_param_value();
    init_assign_native_audio_node_option();
    init_assign_native_audio_node_options();
    createNativeBiquadFilterNode = (nativeContext, options) => {
      const nativeBiquadFilterNode = nativeContext.createBiquadFilter();
      assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);
      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, "Q");
      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, "detune");
      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, "frequency");
      assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, "gain");
      assignNativeAudioNodeOption(nativeBiquadFilterNode, options, "type");
      return nativeBiquadFilterNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js
var createNativeChannelMergerNodeFactory;
var init_native_channel_merger_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-channel-merger-node-factory.js"() {
    init_assign_native_audio_node_options();
    createNativeChannelMergerNodeFactory = (nativeAudioContextConstructor2, wrapChannelMergerNode2) => {
      return (nativeContext, options) => {
        const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);
        if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext") {
          wrapChannelMergerNode2(nativeContext, nativeChannelMergerNode);
        }
        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);
        return nativeChannelMergerNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js
var wrapChannelSplitterNode;
var init_wrap_channel_splitter_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-channel-splitter-node.js"() {
    init_invalid_state_error2();
    wrapChannelSplitterNode = (channelSplitterNode) => {
      const channelCount = channelSplitterNode.numberOfOutputs;
      Object.defineProperty(channelSplitterNode, "channelCount", {
        get: () => channelCount,
        set: (value) => {
          if (value !== channelCount) {
            throw createInvalidStateError2();
          }
        }
      });
      Object.defineProperty(channelSplitterNode, "channelCountMode", {
        get: () => "explicit",
        set: (value) => {
          if (value !== "explicit") {
            throw createInvalidStateError2();
          }
        }
      });
      Object.defineProperty(channelSplitterNode, "channelInterpretation", {
        get: () => "discrete",
        set: (value) => {
          if (value !== "discrete") {
            throw createInvalidStateError2();
          }
        }
      });
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node.js
var createNativeChannelSplitterNode;
var init_native_channel_splitter_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-channel-splitter-node.js"() {
    init_assign_native_audio_node_options();
    init_wrap_channel_splitter_node();
    createNativeChannelSplitterNode = (nativeContext, options) => {
      const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);
      assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);
      wrapChannelSplitterNode(nativeChannelSplitterNode);
      return nativeChannelSplitterNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js
var createNativeConstantSourceNodeFactory;
var init_native_constant_source_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-factory.js"() {
    init_assign_native_audio_node_audio_param_value();
    init_assign_native_audio_node_options();
    init_wrap_audio_scheduled_source_node_start_method_negative_parameters();
    init_wrap_audio_scheduled_source_node_stop_method_negative_parameters();
    createNativeConstantSourceNodeFactory = (addSilentConnection2, cacheTestResult2, createNativeConstantSourceNodeFaker2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2) => {
      return (nativeContext, options) => {
        if (nativeContext.createConstantSource === void 0) {
          return createNativeConstantSourceNodeFaker2(nativeContext, options);
        }
        const nativeConstantSourceNode = nativeContext.createConstantSource();
        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);
        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, "offset");
        if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
          wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);
        }
        if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
          wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);
        }
        addSilentConnection2(nativeContext, nativeConstantSourceNode);
        return nativeConstantSourceNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js
var interceptConnections;
var init_intercept_connections = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/intercept-connections.js"() {
    interceptConnections = (original, interceptor) => {
      original.connect = interceptor.connect.bind(interceptor);
      original.disconnect = interceptor.disconnect.bind(interceptor);
      return original;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js
var createNativeConstantSourceNodeFakerFactory;
var init_native_constant_source_node_faker_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-constant-source-node-faker-factory.js"() {
    init_intercept_connections();
    createNativeConstantSourceNodeFakerFactory = (addSilentConnection2, createNativeAudioBufferSourceNode2, createNativeGainNode2, monitorConnections2) => {
      return (nativeContext, { offset, ...audioNodeOptions }) => {
        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);
        const audioBufferSourceNode = createNativeAudioBufferSourceNode2(nativeContext, {
          buffer: null,
          channelCount: 2,
          channelCountMode: "max",
          channelInterpretation: "speakers",
          loop: false,
          loopEnd: 0,
          loopStart: 0,
          playbackRate: 1
        });
        const gainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: offset });
        const channelData = audioBuffer.getChannelData(0);
        channelData[0] = 1;
        channelData[1] = 1;
        audioBufferSourceNode.buffer = audioBuffer;
        audioBufferSourceNode.loop = true;
        const nativeConstantSourceNodeFaker = {
          get bufferSize() {
            return void 0;
          },
          get channelCount() {
            return gainNode.channelCount;
          },
          set channelCount(value) {
            gainNode.channelCount = value;
          },
          get channelCountMode() {
            return gainNode.channelCountMode;
          },
          set channelCountMode(value) {
            gainNode.channelCountMode = value;
          },
          get channelInterpretation() {
            return gainNode.channelInterpretation;
          },
          set channelInterpretation(value) {
            gainNode.channelInterpretation = value;
          },
          get context() {
            return gainNode.context;
          },
          get inputs() {
            return [];
          },
          get numberOfInputs() {
            return audioBufferSourceNode.numberOfInputs;
          },
          get numberOfOutputs() {
            return gainNode.numberOfOutputs;
          },
          get offset() {
            return gainNode.gain;
          },
          get onended() {
            return audioBufferSourceNode.onended;
          },
          set onended(value) {
            audioBufferSourceNode.onended = value;
          },
          addEventListener(...args) {
            return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);
          },
          dispatchEvent(...args) {
            return audioBufferSourceNode.dispatchEvent(args[0]);
          },
          removeEventListener(...args) {
            return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);
          },
          start(when = 0) {
            audioBufferSourceNode.start.call(audioBufferSourceNode, when);
          },
          stop(when = 0) {
            audioBufferSourceNode.stop.call(audioBufferSourceNode, when);
          }
        };
        const whenConnected = () => audioBufferSourceNode.connect(gainNode);
        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);
        addSilentConnection2(nativeContext, audioBufferSourceNode);
        return monitorConnections2(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js
var createNativeConvolverNodeFactory;
var init_native_convolver_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-convolver-node-factory.js"() {
    init_assign_native_audio_node_option();
    init_assign_native_audio_node_options();
    createNativeConvolverNodeFactory = (createNotSupportedError3, overwriteAccessors2) => {
      return (nativeContext, options) => {
        const nativeConvolverNode = nativeContext.createConvolver();
        assignNativeAudioNodeOptions(nativeConvolverNode, options);
        if (options.disableNormalization === nativeConvolverNode.normalize) {
          nativeConvolverNode.normalize = !options.disableNormalization;
        }
        assignNativeAudioNodeOption(nativeConvolverNode, options, "buffer");
        if (options.channelCount > 2) {
          throw createNotSupportedError3();
        }
        overwriteAccessors2(nativeConvolverNode, "channelCount", (get) => () => get.call(nativeConvolverNode), (set2) => (value) => {
          if (value > 2) {
            throw createNotSupportedError3();
          }
          return set2.call(nativeConvolverNode, value);
        });
        if (options.channelCountMode === "max") {
          throw createNotSupportedError3();
        }
        overwriteAccessors2(nativeConvolverNode, "channelCountMode", (get) => () => get.call(nativeConvolverNode), (set2) => (value) => {
          if (value === "max") {
            throw createNotSupportedError3();
          }
          return set2.call(nativeConvolverNode, value);
        });
        return nativeConvolverNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-delay-node.js
var createNativeDelayNode;
var init_native_delay_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-delay-node.js"() {
    init_assign_native_audio_node_audio_param_value();
    init_assign_native_audio_node_options();
    createNativeDelayNode = (nativeContext, options) => {
      const nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);
      assignNativeAudioNodeOptions(nativeDelayNode, options);
      assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, "delayTime");
      return nativeDelayNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js
var createNativeDynamicsCompressorNodeFactory;
var init_native_dynamics_compressor_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-dynamics-compressor-node-factory.js"() {
    init_assign_native_audio_node_audio_param_value();
    init_assign_native_audio_node_options();
    createNativeDynamicsCompressorNodeFactory = (createNotSupportedError3) => {
      return (nativeContext, options) => {
        const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();
        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);
        if (options.channelCount > 2) {
          throw createNotSupportedError3();
        }
        if (options.channelCountMode === "max") {
          throw createNotSupportedError3();
        }
        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, "attack");
        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, "knee");
        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, "ratio");
        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, "release");
        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, "threshold");
        return nativeDynamicsCompressorNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-gain-node.js
var createNativeGainNode;
var init_native_gain_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-gain-node.js"() {
    init_assign_native_audio_node_audio_param_value();
    init_assign_native_audio_node_options();
    createNativeGainNode = (nativeContext, options) => {
      const nativeGainNode = nativeContext.createGain();
      assignNativeAudioNodeOptions(nativeGainNode, options);
      assignNativeAudioNodeAudioParamValue(nativeGainNode, options, "gain");
      return nativeGainNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js
var createNativeIIRFilterNodeFactory;
var init_native_iir_filter_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-factory.js"() {
    init_assign_native_audio_node_options();
    createNativeIIRFilterNodeFactory = (createNativeIIRFilterNodeFaker2) => {
      return (nativeContext, baseLatency, options) => {
        if (nativeContext.createIIRFilter === void 0) {
          return createNativeIIRFilterNodeFaker2(nativeContext, baseLatency, options);
        }
        const nativeIIRFilterNode = nativeContext.createIIRFilter(options.feedforward, options.feedback);
        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);
        return nativeIIRFilterNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js
function divide(a, b) {
  const denominator = b[0] * b[0] + b[1] * b[1];
  return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];
}
function multiply(a, b) {
  return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];
}
function evaluatePolynomial(coefficient, z) {
  let result = [0, 0];
  for (let i = coefficient.length - 1; i >= 0; i -= 1) {
    result = multiply(result, z);
    result[0] += coefficient[i];
  }
  return result;
}
var createNativeIIRFilterNodeFakerFactory;
var init_native_iir_filter_node_faker_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-iir-filter-node-faker-factory.js"() {
    init_compute_buffer_size();
    init_filter_buffer();
    init_intercept_connections();
    createNativeIIRFilterNodeFakerFactory = (createInvalidAccessError2, createInvalidStateError3, createNativeScriptProcessorNode2, createNotSupportedError3) => {
      return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {
        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);
        const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);
        const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);
        const feedbackLength = convertedFeedback.length;
        const feedforwardLength = convertedFeedforward.length;
        const minLength = Math.min(feedbackLength, feedforwardLength);
        if (feedbackLength === 0 || feedbackLength > 20) {
          throw createNotSupportedError3();
        }
        if (convertedFeedback[0] === 0) {
          throw createInvalidStateError3();
        }
        if (feedforwardLength === 0 || feedforwardLength > 20) {
          throw createNotSupportedError3();
        }
        if (convertedFeedforward[0] === 0) {
          throw createInvalidStateError3();
        }
        if (convertedFeedback[0] !== 1) {
          for (let i = 0; i < feedforwardLength; i += 1) {
            convertedFeedforward[i] /= convertedFeedback[0];
          }
          for (let i = 1; i < feedbackLength; i += 1) {
            convertedFeedback[i] /= convertedFeedback[0];
          }
        }
        const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, bufferSize, channelCount, channelCount);
        scriptProcessorNode.channelCount = channelCount;
        scriptProcessorNode.channelCountMode = channelCountMode;
        scriptProcessorNode.channelInterpretation = channelInterpretation;
        const bufferLength = 32;
        const bufferIndexes = [];
        const xBuffers = [];
        const yBuffers = [];
        for (let i = 0; i < channelCount; i += 1) {
          bufferIndexes.push(0);
          const xBuffer = new Float32Array(bufferLength);
          const yBuffer = new Float32Array(bufferLength);
          xBuffer.fill(0);
          yBuffer.fill(0);
          xBuffers.push(xBuffer);
          yBuffers.push(yBuffer);
        }
        scriptProcessorNode.onaudioprocess = (event) => {
          const inputBuffer = event.inputBuffer;
          const outputBuffer = event.outputBuffer;
          const numberOfChannels = inputBuffer.numberOfChannels;
          for (let i = 0; i < numberOfChannels; i += 1) {
            const input = inputBuffer.getChannelData(i);
            const output = outputBuffer.getChannelData(i);
            bufferIndexes[i] = filterBuffer(convertedFeedback, feedbackLength, convertedFeedforward, feedforwardLength, minLength, xBuffers[i], yBuffers[i], bufferIndexes[i], bufferLength, input, output);
          }
        };
        const nyquist = nativeContext.sampleRate / 2;
        const nativeIIRFilterNodeFaker = {
          get bufferSize() {
            return bufferSize;
          },
          get channelCount() {
            return scriptProcessorNode.channelCount;
          },
          set channelCount(value) {
            scriptProcessorNode.channelCount = value;
          },
          get channelCountMode() {
            return scriptProcessorNode.channelCountMode;
          },
          set channelCountMode(value) {
            scriptProcessorNode.channelCountMode = value;
          },
          get channelInterpretation() {
            return scriptProcessorNode.channelInterpretation;
          },
          set channelInterpretation(value) {
            scriptProcessorNode.channelInterpretation = value;
          },
          get context() {
            return scriptProcessorNode.context;
          },
          get inputs() {
            return [scriptProcessorNode];
          },
          get numberOfInputs() {
            return scriptProcessorNode.numberOfInputs;
          },
          get numberOfOutputs() {
            return scriptProcessorNode.numberOfOutputs;
          },
          addEventListener(...args) {
            return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);
          },
          dispatchEvent(...args) {
            return scriptProcessorNode.dispatchEvent(args[0]);
          },
          getFrequencyResponse(frequencyHz, magResponse, phaseResponse) {
            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {
              throw createInvalidAccessError2();
            }
            const length = frequencyHz.length;
            for (let i = 0; i < length; i += 1) {
              const omega = -Math.PI * (frequencyHz[i] / nyquist);
              const z = [Math.cos(omega), Math.sin(omega)];
              const numerator = evaluatePolynomial(convertedFeedforward, z);
              const denominator = evaluatePolynomial(convertedFeedback, z);
              const response = divide(numerator, denominator);
              magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);
              phaseResponse[i] = Math.atan2(response[1], response[0]);
            }
          },
          removeEventListener(...args) {
            return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);
          }
        };
        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node.js
var createNativeMediaElementAudioSourceNode;
var init_native_media_element_audio_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-media-element-audio-source-node.js"() {
    createNativeMediaElementAudioSourceNode = (nativeAudioContext, options) => {
      return nativeAudioContext.createMediaElementSource(options.mediaElement);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node.js
var createNativeMediaStreamAudioDestinationNode;
var init_native_media_stream_audio_destination_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-destination-node.js"() {
    init_assign_native_audio_node_options();
    createNativeMediaStreamAudioDestinationNode = (nativeAudioContext, options) => {
      const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();
      assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);
      if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {
        Object.defineProperty(nativeMediaStreamAudioDestinationNode, "numberOfOutputs", { get: () => 0 });
      }
      return nativeMediaStreamAudioDestinationNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node.js
var createNativeMediaStreamAudioSourceNode;
var init_native_media_stream_audio_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-audio-source-node.js"() {
    createNativeMediaStreamAudioSourceNode = (nativeAudioContext, { mediaStream }) => {
      const audioStreamTracks = mediaStream.getAudioTracks();
      audioStreamTracks.sort((a, b) => a.id < b.id ? -1 : a.id > b.id ? 1 : 0);
      const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);
      const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));
      Object.defineProperty(nativeMediaStreamAudioSourceNode, "mediaStream", { value: mediaStream });
      return nativeMediaStreamAudioSourceNode;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js
var createNativeMediaStreamTrackAudioSourceNodeFactory;
var init_native_media_stream_track_audio_source_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-media-stream-track-audio-source-node-factory.js"() {
    createNativeMediaStreamTrackAudioSourceNodeFactory = (createInvalidStateError3, isNativeOfflineAudioContext2) => {
      return (nativeAudioContext, { mediaStreamTrack }) => {
        if (typeof nativeAudioContext.createMediaStreamTrackSource === "function") {
          return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);
        }
        const mediaStream = new MediaStream([mediaStreamTrack]);
        const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);
        if (mediaStreamTrack.kind !== "audio") {
          throw createInvalidStateError3();
        }
        if (isNativeOfflineAudioContext2(nativeAudioContext)) {
          throw new TypeError();
        }
        return nativeMediaStreamAudioSourceNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js
var createNativeOfflineAudioContextConstructor;
var init_native_offline_audio_context_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-offline-audio-context-constructor.js"() {
    createNativeOfflineAudioContextConstructor = (window5) => {
      if (window5 === null) {
        return null;
      }
      if (window5.hasOwnProperty("OfflineAudioContext")) {
        return window5.OfflineAudioContext;
      }
      return window5.hasOwnProperty("webkitOfflineAudioContext") ? window5.webkitOfflineAudioContext : null;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js
var createNativeOscillatorNodeFactory;
var init_native_oscillator_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-oscillator-node-factory.js"() {
    init_assign_native_audio_node_audio_param_value();
    init_assign_native_audio_node_option();
    init_assign_native_audio_node_options();
    init_wrap_audio_scheduled_source_node_start_method_negative_parameters();
    init_wrap_audio_scheduled_source_node_stop_method_negative_parameters();
    createNativeOscillatorNodeFactory = (addSilentConnection2, cacheTestResult2, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2) => {
      return (nativeContext, options) => {
        const nativeOscillatorNode = nativeContext.createOscillator();
        assignNativeAudioNodeOptions(nativeOscillatorNode, options);
        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, "detune");
        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, "frequency");
        if (options.periodicWave !== void 0) {
          nativeOscillatorNode.setPeriodicWave(options.periodicWave);
        } else {
          assignNativeAudioNodeOption(nativeOscillatorNode, options, "type");
        }
        if (!cacheTestResult2(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStartMethodNegativeParametersSupport2(nativeContext))) {
          wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);
        }
        if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2, () => testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport2(nativeContext))) {
          wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls2(nativeOscillatorNode, nativeContext);
        }
        if (!cacheTestResult2(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2, () => testAudioScheduledSourceNodeStopMethodNegativeParametersSupport2(nativeContext))) {
          wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);
        }
        addSilentConnection2(nativeContext, nativeOscillatorNode);
        return nativeOscillatorNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js
var createNativePannerNodeFactory;
var init_native_panner_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-factory.js"() {
    init_assign_native_audio_node_audio_param_value();
    init_assign_native_audio_node_option();
    init_assign_native_audio_node_options();
    createNativePannerNodeFactory = (createNativePannerNodeFaker2) => {
      return (nativeContext, options) => {
        const nativePannerNode = nativeContext.createPanner();
        if (nativePannerNode.orientationX === void 0) {
          return createNativePannerNodeFaker2(nativeContext, options);
        }
        assignNativeAudioNodeOptions(nativePannerNode, options);
        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "orientationX");
        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "orientationY");
        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "orientationZ");
        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "positionX");
        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "positionY");
        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, "positionZ");
        assignNativeAudioNodeOption(nativePannerNode, options, "coneInnerAngle");
        assignNativeAudioNodeOption(nativePannerNode, options, "coneOuterAngle");
        assignNativeAudioNodeOption(nativePannerNode, options, "coneOuterGain");
        assignNativeAudioNodeOption(nativePannerNode, options, "distanceModel");
        assignNativeAudioNodeOption(nativePannerNode, options, "maxDistance");
        assignNativeAudioNodeOption(nativePannerNode, options, "panningModel");
        assignNativeAudioNodeOption(nativePannerNode, options, "refDistance");
        assignNativeAudioNodeOption(nativePannerNode, options, "rolloffFactor");
        return nativePannerNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js
var createNativePannerNodeFakerFactory;
var init_native_panner_node_faker_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-panner-node-faker-factory.js"() {
    init_assign_native_audio_node_options();
    init_intercept_connections();
    createNativePannerNodeFakerFactory = (connectNativeAudioNodeToNativeAudioNode2, createInvalidStateError3, createNativeChannelMergerNode2, createNativeGainNode2, createNativeScriptProcessorNode2, createNativeWaveShaperNode2, createNotSupportedError3, disconnectNativeAudioNodeFromNativeAudioNode2, getFirstSample2, monitorConnections2) => {
      return (nativeContext, { coneInnerAngle, coneOuterAngle, coneOuterGain, distanceModel, maxDistance, orientationX, orientationY, orientationZ, panningModel, positionX, positionY, positionZ, refDistance, rolloffFactor, ...audioNodeOptions }) => {
        const pannerNode = nativeContext.createPanner();
        if (audioNodeOptions.channelCount > 2) {
          throw createNotSupportedError3();
        }
        if (audioNodeOptions.channelCountMode === "max") {
          throw createNotSupportedError3();
        }
        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);
        const SINGLE_CHANNEL_OPTIONS = {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete"
        };
        const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
          ...SINGLE_CHANNEL_OPTIONS,
          channelInterpretation: "speakers",
          numberOfInputs: 6
        });
        const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
        const orientationXGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });
        const orientationYGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const orientationZGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const positionXGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const positionYGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const positionZGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const scriptProcessorNode = createNativeScriptProcessorNode2(nativeContext, 256, 6, 1);
        const waveShaperNode = createNativeWaveShaperNode2(nativeContext, {
          ...SINGLE_CHANNEL_OPTIONS,
          curve: new Float32Array([1, 1]),
          oversample: "none"
        });
        let lastOrientation = [orientationX, orientationY, orientationZ];
        let lastPosition = [positionX, positionY, positionZ];
        const buffer = new Float32Array(1);
        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {
          const orientation = [
            getFirstSample2(inputBuffer, buffer, 0),
            getFirstSample2(inputBuffer, buffer, 1),
            getFirstSample2(inputBuffer, buffer, 2)
          ];
          if (orientation.some((value, index) => value !== lastOrientation[index])) {
            pannerNode.setOrientation(...orientation);
            lastOrientation = orientation;
          }
          const positon = [
            getFirstSample2(inputBuffer, buffer, 3),
            getFirstSample2(inputBuffer, buffer, 4),
            getFirstSample2(inputBuffer, buffer, 5)
          ];
          if (positon.some((value, index) => value !== lastPosition[index])) {
            pannerNode.setPosition(...positon);
            lastPosition = positon;
          }
        };
        Object.defineProperty(orientationYGainNode.gain, "defaultValue", { get: () => 0 });
        Object.defineProperty(orientationZGainNode.gain, "defaultValue", { get: () => 0 });
        Object.defineProperty(positionXGainNode.gain, "defaultValue", { get: () => 0 });
        Object.defineProperty(positionYGainNode.gain, "defaultValue", { get: () => 0 });
        Object.defineProperty(positionZGainNode.gain, "defaultValue", { get: () => 0 });
        const nativePannerNodeFaker = {
          get bufferSize() {
            return void 0;
          },
          get channelCount() {
            return pannerNode.channelCount;
          },
          set channelCount(value) {
            if (value > 2) {
              throw createNotSupportedError3();
            }
            inputGainNode.channelCount = value;
            pannerNode.channelCount = value;
          },
          get channelCountMode() {
            return pannerNode.channelCountMode;
          },
          set channelCountMode(value) {
            if (value === "max") {
              throw createNotSupportedError3();
            }
            inputGainNode.channelCountMode = value;
            pannerNode.channelCountMode = value;
          },
          get channelInterpretation() {
            return pannerNode.channelInterpretation;
          },
          set channelInterpretation(value) {
            inputGainNode.channelInterpretation = value;
            pannerNode.channelInterpretation = value;
          },
          get coneInnerAngle() {
            return pannerNode.coneInnerAngle;
          },
          set coneInnerAngle(value) {
            pannerNode.coneInnerAngle = value;
          },
          get coneOuterAngle() {
            return pannerNode.coneOuterAngle;
          },
          set coneOuterAngle(value) {
            pannerNode.coneOuterAngle = value;
          },
          get coneOuterGain() {
            return pannerNode.coneOuterGain;
          },
          set coneOuterGain(value) {
            if (value < 0 || value > 1) {
              throw createInvalidStateError3();
            }
            pannerNode.coneOuterGain = value;
          },
          get context() {
            return pannerNode.context;
          },
          get distanceModel() {
            return pannerNode.distanceModel;
          },
          set distanceModel(value) {
            pannerNode.distanceModel = value;
          },
          get inputs() {
            return [inputGainNode];
          },
          get maxDistance() {
            return pannerNode.maxDistance;
          },
          set maxDistance(value) {
            if (value < 0) {
              throw new RangeError();
            }
            pannerNode.maxDistance = value;
          },
          get numberOfInputs() {
            return pannerNode.numberOfInputs;
          },
          get numberOfOutputs() {
            return pannerNode.numberOfOutputs;
          },
          get orientationX() {
            return orientationXGainNode.gain;
          },
          get orientationY() {
            return orientationYGainNode.gain;
          },
          get orientationZ() {
            return orientationZGainNode.gain;
          },
          get panningModel() {
            return pannerNode.panningModel;
          },
          set panningModel(value) {
            pannerNode.panningModel = value;
          },
          get positionX() {
            return positionXGainNode.gain;
          },
          get positionY() {
            return positionYGainNode.gain;
          },
          get positionZ() {
            return positionZGainNode.gain;
          },
          get refDistance() {
            return pannerNode.refDistance;
          },
          set refDistance(value) {
            if (value < 0) {
              throw new RangeError();
            }
            pannerNode.refDistance = value;
          },
          get rolloffFactor() {
            return pannerNode.rolloffFactor;
          },
          set rolloffFactor(value) {
            if (value < 0) {
              throw new RangeError();
            }
            pannerNode.rolloffFactor = value;
          },
          addEventListener(...args) {
            return inputGainNode.addEventListener(args[0], args[1], args[2]);
          },
          dispatchEvent(...args) {
            return inputGainNode.dispatchEvent(args[0]);
          },
          removeEventListener(...args) {
            return inputGainNode.removeEventListener(args[0], args[1], args[2]);
          }
        };
        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {
          nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;
        }
        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {
          nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;
        }
        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {
          nativePannerNodeFaker.coneOuterGain = coneOuterGain;
        }
        if (distanceModel !== nativePannerNodeFaker.distanceModel) {
          nativePannerNodeFaker.distanceModel = distanceModel;
        }
        if (maxDistance !== nativePannerNodeFaker.maxDistance) {
          nativePannerNodeFaker.maxDistance = maxDistance;
        }
        if (orientationX !== nativePannerNodeFaker.orientationX.value) {
          nativePannerNodeFaker.orientationX.value = orientationX;
        }
        if (orientationY !== nativePannerNodeFaker.orientationY.value) {
          nativePannerNodeFaker.orientationY.value = orientationY;
        }
        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {
          nativePannerNodeFaker.orientationZ.value = orientationZ;
        }
        if (panningModel !== nativePannerNodeFaker.panningModel) {
          nativePannerNodeFaker.panningModel = panningModel;
        }
        if (positionX !== nativePannerNodeFaker.positionX.value) {
          nativePannerNodeFaker.positionX.value = positionX;
        }
        if (positionY !== nativePannerNodeFaker.positionY.value) {
          nativePannerNodeFaker.positionY.value = positionY;
        }
        if (positionZ !== nativePannerNodeFaker.positionZ.value) {
          nativePannerNodeFaker.positionZ.value = positionZ;
        }
        if (refDistance !== nativePannerNodeFaker.refDistance) {
          nativePannerNodeFaker.refDistance = refDistance;
        }
        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {
          nativePannerNodeFaker.rolloffFactor = rolloffFactor;
        }
        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {
          pannerNode.setOrientation(...lastOrientation);
        }
        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {
          pannerNode.setPosition(...lastPosition);
        }
        const whenConnected = () => {
          inputGainNode.connect(pannerNode);
          connectNativeAudioNodeToNativeAudioNode2(inputGainNode, waveShaperNode, 0, 0);
          waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);
          waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);
          waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);
          waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);
          waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);
          waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);
          channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);
        };
        const whenDisconnected = () => {
          inputGainNode.disconnect(pannerNode);
          disconnectNativeAudioNodeFromNativeAudioNode2(inputGainNode, waveShaperNode, 0, 0);
          waveShaperNode.disconnect(orientationXGainNode);
          orientationXGainNode.disconnect(channelMergerNode);
          waveShaperNode.disconnect(orientationYGainNode);
          orientationYGainNode.disconnect(channelMergerNode);
          waveShaperNode.disconnect(orientationZGainNode);
          orientationZGainNode.disconnect(channelMergerNode);
          waveShaperNode.disconnect(positionXGainNode);
          positionXGainNode.disconnect(channelMergerNode);
          waveShaperNode.disconnect(positionYGainNode);
          positionYGainNode.disconnect(channelMergerNode);
          waveShaperNode.disconnect(positionZGainNode);
          positionZGainNode.disconnect(channelMergerNode);
          channelMergerNode.disconnect(scriptProcessorNode);
          scriptProcessorNode.disconnect(nativeContext.destination);
        };
        return monitorConnections2(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js
var createNativePeriodicWaveFactory;
var init_native_periodic_wave_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-periodic-wave-factory.js"() {
    createNativePeriodicWaveFactory = (createIndexSizeError2) => {
      return (nativeContext, { disableNormalization, imag, real }) => {
        const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);
        const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);
        const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });
        if (Array.from(imag).length < 2) {
          throw createIndexSizeError2();
        }
        return nativePeriodicWave;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node.js
var createNativeScriptProcessorNode;
var init_native_script_processor_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-script-processor-node.js"() {
    createNativeScriptProcessorNode = (nativeContext, bufferSize, numberOfInputChannels, numberOfOutputChannels) => {
      return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js
var createNativeStereoPannerNodeFactory;
var init_native_stereo_panner_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-factory.js"() {
    init_assign_native_audio_node_audio_param_value();
    init_assign_native_audio_node_options();
    createNativeStereoPannerNodeFactory = (createNativeStereoPannerNodeFaker, createNotSupportedError3) => {
      return (nativeContext, options) => {
        const channelCountMode = options.channelCountMode;
        if (channelCountMode === "clamped-max") {
          throw createNotSupportedError3();
        }
        if (nativeContext.createStereoPanner === void 0) {
          return createNativeStereoPannerNodeFaker(nativeContext, options);
        }
        const nativeStereoPannerNode = nativeContext.createStereoPanner();
        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);
        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, "pan");
        Object.defineProperty(nativeStereoPannerNode, "channelCountMode", {
          get: () => channelCountMode,
          set: (value) => {
            if (value !== channelCountMode) {
              throw createNotSupportedError3();
            }
          }
        });
        return nativeStereoPannerNode;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js
var createNativeStereoPannerNodeFakerFactory;
var init_native_stereo_panner_node_faker_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-stereo-panner-node-faker-factory.js"() {
    init_intercept_connections();
    createNativeStereoPannerNodeFakerFactory = (createNativeChannelMergerNode2, createNativeChannelSplitterNode2, createNativeGainNode2, createNativeWaveShaperNode2, createNotSupportedError3, monitorConnections2) => {
      const CURVE_SIZE = 16385;
      const DC_CURVE = new Float32Array([1, 1]);
      const HALF_PI = Math.PI / 2;
      const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: "explicit", channelInterpretation: "discrete" };
      const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: "none" };
      const buildInternalGraphForMono = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);
        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);
        for (let i = 0; i < CURVE_SIZE; i += 1) {
          const x = i / (CURVE_SIZE - 1) * HALF_PI;
          leftWaveShaperCurve[i] = Math.cos(x);
          rightWaveShaperCurve[i] = Math.sin(x);
        }
        const leftGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const leftWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve });
        const panWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });
        const rightGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const rightWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve });
        return {
          connectGraph() {
            inputGainNode.connect(leftGainNode);
            inputGainNode.connect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
            inputGainNode.connect(rightGainNode);
            panWaveShaperNode.connect(panGainNode);
            panGainNode.connect(leftWaveShaperNode.inputs === void 0 ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
            panGainNode.connect(rightWaveShaperNode.inputs === void 0 ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
            leftWaveShaperNode.connect(leftGainNode.gain);
            rightWaveShaperNode.connect(rightGainNode.gain);
            leftGainNode.connect(channelMergerNode, 0, 0);
            rightGainNode.connect(channelMergerNode, 0, 1);
          },
          disconnectGraph() {
            inputGainNode.disconnect(leftGainNode);
            inputGainNode.disconnect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
            inputGainNode.disconnect(rightGainNode);
            panWaveShaperNode.disconnect(panGainNode);
            panGainNode.disconnect(leftWaveShaperNode.inputs === void 0 ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);
            panGainNode.disconnect(rightWaveShaperNode.inputs === void 0 ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);
            leftWaveShaperNode.disconnect(leftGainNode.gain);
            rightWaveShaperNode.disconnect(rightGainNode.gain);
            leftGainNode.disconnect(channelMergerNode, 0, 0);
            rightGainNode.disconnect(channelMergerNode, 0, 1);
          }
        };
      };
      const buildInternalGraphForStereo = (nativeContext, inputGainNode, panGainNode, channelMergerNode) => {
        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);
        const centerIndex = Math.floor(CURVE_SIZE / 2);
        for (let i = 0; i < CURVE_SIZE; i += 1) {
          if (i > centerIndex) {
            const x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;
            leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);
            leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);
            rightInputForLeftOutputWaveShaperCurve[i] = 0;
            rightInputForRightOutputWaveShaperCurve[i] = 1;
          } else {
            const x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;
            leftInputForLeftOutputWaveShaperCurve[i] = 1;
            leftInputForRightOutputWaveShaperCurve[i] = 0;
            rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);
            rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);
          }
        }
        const channelSplitterNode = createNativeChannelSplitterNode2(nativeContext, {
          channelCount: 2,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          numberOfOutputs: 2
        });
        const leftInputForLeftOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
          ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
          curve: leftInputForLeftOutputWaveShaperCurve
        });
        const leftInputForRightOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
          ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
          curve: leftInputForRightOutputWaveShaperCurve
        });
        const panWaveShaperNode = createNativeWaveShaperNode2(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE });
        const rightInputForLeftOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
          ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
          curve: rightInputForLeftOutputWaveShaperCurve
        });
        const rightInputForRightOutputGainNode = createNativeGainNode2(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });
        const rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode2(nativeContext, {
          ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,
          curve: rightInputForRightOutputWaveShaperCurve
        });
        return {
          connectGraph() {
            inputGainNode.connect(channelSplitterNode);
            inputGainNode.connect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
            channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);
            channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);
            channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);
            channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);
            panWaveShaperNode.connect(panGainNode);
            panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === void 0 ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
            panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === void 0 ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
            panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === void 0 ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
            panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === void 0 ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
            leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);
            leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);
            rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);
            rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);
            leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
            rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);
            leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
            rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);
          },
          disconnectGraph() {
            inputGainNode.disconnect(channelSplitterNode);
            inputGainNode.disconnect(panWaveShaperNode.inputs === void 0 ? panWaveShaperNode : panWaveShaperNode.inputs[0]);
            channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);
            channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);
            channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);
            channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);
            panWaveShaperNode.disconnect(panGainNode);
            panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === void 0 ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);
            panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === void 0 ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);
            panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === void 0 ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);
            panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === void 0 ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);
            leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);
            leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);
            rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);
            rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);
            leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
            rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);
            leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
            rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);
          }
        };
      };
      const buildInternalGraph = (nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) => {
        if (channelCount === 1) {
          return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);
        }
        if (channelCount === 2) {
          return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);
        }
        throw createNotSupportedError3();
      };
      return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {
        if (channelCountMode === "max") {
          throw createNotSupportedError3();
        }
        const channelMergerNode = createNativeChannelMergerNode2(nativeContext, {
          ...audioNodeOptions,
          channelCount: 1,
          channelCountMode,
          numberOfInputs: 2
        });
        const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });
        const panGainNode = createNativeGainNode2(nativeContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          gain: pan
        });
        let { connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode);
        Object.defineProperty(panGainNode.gain, "defaultValue", { get: () => 0 });
        Object.defineProperty(panGainNode.gain, "maxValue", { get: () => 1 });
        Object.defineProperty(panGainNode.gain, "minValue", { get: () => -1 });
        const nativeStereoPannerNodeFakerFactory2 = {
          get bufferSize() {
            return void 0;
          },
          get channelCount() {
            return inputGainNode.channelCount;
          },
          set channelCount(value) {
            if (inputGainNode.channelCount !== value) {
              if (isConnected) {
                disconnectGraph();
              }
              ({ connectGraph, disconnectGraph } = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode));
              if (isConnected) {
                connectGraph();
              }
            }
            inputGainNode.channelCount = value;
          },
          get channelCountMode() {
            return inputGainNode.channelCountMode;
          },
          set channelCountMode(value) {
            if (value === "clamped-max" || value === "max") {
              throw createNotSupportedError3();
            }
            inputGainNode.channelCountMode = value;
          },
          get channelInterpretation() {
            return inputGainNode.channelInterpretation;
          },
          set channelInterpretation(value) {
            inputGainNode.channelInterpretation = value;
          },
          get context() {
            return inputGainNode.context;
          },
          get inputs() {
            return [inputGainNode];
          },
          get numberOfInputs() {
            return inputGainNode.numberOfInputs;
          },
          get numberOfOutputs() {
            return inputGainNode.numberOfOutputs;
          },
          get pan() {
            return panGainNode.gain;
          },
          addEventListener(...args) {
            return inputGainNode.addEventListener(args[0], args[1], args[2]);
          },
          dispatchEvent(...args) {
            return inputGainNode.dispatchEvent(args[0]);
          },
          removeEventListener(...args) {
            return inputGainNode.removeEventListener(args[0], args[1], args[2]);
          }
        };
        let isConnected = false;
        const whenConnected = () => {
          connectGraph();
          isConnected = true;
        };
        const whenDisconnected = () => {
          disconnectGraph();
          isConnected = false;
        };
        return monitorConnections2(interceptConnections(nativeStereoPannerNodeFakerFactory2, channelMergerNode), whenConnected, whenDisconnected);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js
var createNativeWaveShaperNodeFactory;
var init_native_wave_shaper_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-factory.js"() {
    init_assign_native_audio_node_option();
    init_assign_native_audio_node_options();
    createNativeWaveShaperNodeFactory = (createConnectedNativeAudioBufferSourceNode2, createInvalidStateError3, createNativeWaveShaperNodeFaker2, isDCCurve2, monitorConnections2, nativeAudioContextConstructor2, overwriteAccessors2) => {
      return (nativeContext, options) => {
        const nativeWaveShaperNode = nativeContext.createWaveShaper();
        if (nativeAudioContextConstructor2 !== null && nativeAudioContextConstructor2.name === "webkitAudioContext" && nativeContext.createGain().gain.automationRate === void 0) {
          return createNativeWaveShaperNodeFaker2(nativeContext, options);
        }
        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);
        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);
        if (curve !== null && curve.length < 2) {
          throw createInvalidStateError3();
        }
        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, "curve");
        assignNativeAudioNodeOption(nativeWaveShaperNode, options, "oversample");
        let disconnectNativeAudioBufferSourceNode = null;
        let isConnected = false;
        overwriteAccessors2(nativeWaveShaperNode, "curve", (get) => () => get.call(nativeWaveShaperNode), (set2) => (value) => {
          set2.call(nativeWaveShaperNode, value);
          if (isConnected) {
            if (isDCCurve2(value) && disconnectNativeAudioBufferSourceNode === null) {
              disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, nativeWaveShaperNode);
            } else if (!isDCCurve2(value) && disconnectNativeAudioBufferSourceNode !== null) {
              disconnectNativeAudioBufferSourceNode();
              disconnectNativeAudioBufferSourceNode = null;
            }
          }
          return value;
        });
        const whenConnected = () => {
          isConnected = true;
          if (isDCCurve2(nativeWaveShaperNode.curve)) {
            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, nativeWaveShaperNode);
          }
        };
        const whenDisconnected = () => {
          isConnected = false;
          if (disconnectNativeAudioBufferSourceNode !== null) {
            disconnectNativeAudioBufferSourceNode();
            disconnectNativeAudioBufferSourceNode = null;
          }
        };
        return monitorConnections2(nativeWaveShaperNode, whenConnected, whenDisconnected);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js
var createNativeWaveShaperNodeFakerFactory;
var init_native_wave_shaper_node_faker_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/native-wave-shaper-node-faker-factory.js"() {
    init_assign_native_audio_node_options();
    init_intercept_connections();
    createNativeWaveShaperNodeFakerFactory = (createConnectedNativeAudioBufferSourceNode2, createInvalidStateError3, createNativeGainNode2, isDCCurve2, monitorConnections2) => {
      return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {
        const negativeWaveShaperNode = nativeContext.createWaveShaper();
        const positiveWaveShaperNode = nativeContext.createWaveShaper();
        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);
        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);
        const inputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
        const invertGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: -1 });
        const outputGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: 1 });
        const revertGainNode = createNativeGainNode2(nativeContext, { ...audioNodeOptions, gain: -1 });
        let disconnectNativeAudioBufferSourceNode = null;
        let isConnected = false;
        let unmodifiedCurve = null;
        const nativeWaveShaperNodeFaker = {
          get bufferSize() {
            return void 0;
          },
          get channelCount() {
            return negativeWaveShaperNode.channelCount;
          },
          set channelCount(value) {
            inputGainNode.channelCount = value;
            invertGainNode.channelCount = value;
            negativeWaveShaperNode.channelCount = value;
            outputGainNode.channelCount = value;
            positiveWaveShaperNode.channelCount = value;
            revertGainNode.channelCount = value;
          },
          get channelCountMode() {
            return negativeWaveShaperNode.channelCountMode;
          },
          set channelCountMode(value) {
            inputGainNode.channelCountMode = value;
            invertGainNode.channelCountMode = value;
            negativeWaveShaperNode.channelCountMode = value;
            outputGainNode.channelCountMode = value;
            positiveWaveShaperNode.channelCountMode = value;
            revertGainNode.channelCountMode = value;
          },
          get channelInterpretation() {
            return negativeWaveShaperNode.channelInterpretation;
          },
          set channelInterpretation(value) {
            inputGainNode.channelInterpretation = value;
            invertGainNode.channelInterpretation = value;
            negativeWaveShaperNode.channelInterpretation = value;
            outputGainNode.channelInterpretation = value;
            positiveWaveShaperNode.channelInterpretation = value;
            revertGainNode.channelInterpretation = value;
          },
          get context() {
            return negativeWaveShaperNode.context;
          },
          get curve() {
            return unmodifiedCurve;
          },
          set curve(value) {
            if (value !== null && value.length < 2) {
              throw createInvalidStateError3();
            }
            if (value === null) {
              negativeWaveShaperNode.curve = value;
              positiveWaveShaperNode.curve = value;
            } else {
              const curveLength = value.length;
              const negativeCurve = new Float32Array(curveLength + 2 - curveLength % 2);
              const positiveCurve = new Float32Array(curveLength + 2 - curveLength % 2);
              negativeCurve[0] = value[0];
              positiveCurve[0] = -value[curveLength - 1];
              const length = Math.ceil((curveLength + 1) / 2);
              const centerIndex = (curveLength + 1) / 2 - 1;
              for (let i = 1; i < length; i += 1) {
                const theoreticIndex = i / length * centerIndex;
                const lowerIndex = Math.floor(theoreticIndex);
                const upperIndex = Math.ceil(theoreticIndex);
                negativeCurve[i] = lowerIndex === upperIndex ? value[lowerIndex] : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * value[upperIndex];
                positiveCurve[i] = lowerIndex === upperIndex ? -value[curveLength - 1 - lowerIndex] : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) - (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];
              }
              negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;
              negativeWaveShaperNode.curve = negativeCurve;
              positiveWaveShaperNode.curve = positiveCurve;
            }
            unmodifiedCurve = value;
            if (isConnected) {
              if (isDCCurve2(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {
                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, inputGainNode);
              } else if (disconnectNativeAudioBufferSourceNode !== null) {
                disconnectNativeAudioBufferSourceNode();
                disconnectNativeAudioBufferSourceNode = null;
              }
            }
          },
          get inputs() {
            return [inputGainNode];
          },
          get numberOfInputs() {
            return negativeWaveShaperNode.numberOfInputs;
          },
          get numberOfOutputs() {
            return negativeWaveShaperNode.numberOfOutputs;
          },
          get oversample() {
            return negativeWaveShaperNode.oversample;
          },
          set oversample(value) {
            negativeWaveShaperNode.oversample = value;
            positiveWaveShaperNode.oversample = value;
          },
          addEventListener(...args) {
            return inputGainNode.addEventListener(args[0], args[1], args[2]);
          },
          dispatchEvent(...args) {
            return inputGainNode.dispatchEvent(args[0]);
          },
          removeEventListener(...args) {
            return inputGainNode.removeEventListener(args[0], args[1], args[2]);
          }
        };
        if (curve !== null) {
          nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);
        }
        if (oversample !== nativeWaveShaperNodeFaker.oversample) {
          nativeWaveShaperNodeFaker.oversample = oversample;
        }
        const whenConnected = () => {
          inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);
          inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);
          isConnected = true;
          if (isDCCurve2(unmodifiedCurve)) {
            disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode2(nativeContext, inputGainNode);
          }
        };
        const whenDisconnected = () => {
          inputGainNode.disconnect(negativeWaveShaperNode);
          negativeWaveShaperNode.disconnect(outputGainNode);
          inputGainNode.disconnect(invertGainNode);
          invertGainNode.disconnect(positiveWaveShaperNode);
          positiveWaveShaperNode.disconnect(revertGainNode);
          revertGainNode.disconnect(outputGainNode);
          isConnected = false;
          if (disconnectNativeAudioBufferSourceNode !== null) {
            disconnectNativeAudioBufferSourceNode();
            disconnectNativeAudioBufferSourceNode = null;
          }
        };
        return monitorConnections2(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js
var createNotSupportedError2;
var init_not_supported_error2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/not-supported-error.js"() {
    createNotSupportedError2 = () => new DOMException("", "NotSupportedError");
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js
var DEFAULT_OPTIONS16, createOfflineAudioContextConstructor;
var init_offline_audio_context_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/offline-audio-context-constructor.js"() {
    init_deactivate_audio_graph();
    init_test_promise_support();
    DEFAULT_OPTIONS16 = {
      numberOfChannels: 1
    };
    createOfflineAudioContextConstructor = (baseAudioContextConstructor2, cacheTestResult2, createInvalidStateError3, createNativeOfflineAudioContext2, startRendering2) => {
      return class OfflineAudioContext extends baseAudioContextConstructor2 {
        constructor(a, b, c2) {
          let options;
          if (typeof a === "number" && b !== void 0 && c2 !== void 0) {
            options = { length: b, numberOfChannels: a, sampleRate: c2 };
          } else if (typeof a === "object") {
            options = a;
          } else {
            throw new Error("The given parameters are not valid.");
          }
          const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS16, ...options };
          const nativeOfflineAudioContext = createNativeOfflineAudioContext2(numberOfChannels, length, sampleRate);
          if (!cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
            nativeOfflineAudioContext.addEventListener("statechange", /* @__PURE__ */ (() => {
              let i = 0;
              const delayStateChangeEvent = (event) => {
                if (this._state === "running") {
                  if (i > 0) {
                    nativeOfflineAudioContext.removeEventListener("statechange", delayStateChangeEvent);
                    event.stopImmediatePropagation();
                    this._waitForThePromiseToSettle(event);
                  } else {
                    i += 1;
                  }
                }
              };
              return delayStateChangeEvent;
            })());
          }
          super(nativeOfflineAudioContext, numberOfChannels);
          this._length = length;
          this._nativeOfflineAudioContext = nativeOfflineAudioContext;
          this._state = null;
        }
        get length() {
          if (this._nativeOfflineAudioContext.length === void 0) {
            return this._length;
          }
          return this._nativeOfflineAudioContext.length;
        }
        get state() {
          return this._state === null ? this._nativeOfflineAudioContext.state : this._state;
        }
        startRendering() {
          if (this._state === "running") {
            return Promise.reject(createInvalidStateError3());
          }
          this._state = "running";
          return startRendering2(this.destination, this._nativeOfflineAudioContext).finally(() => {
            this._state = null;
            deactivateAudioGraph(this);
          });
        }
        _waitForThePromiseToSettle(event) {
          if (this._state === null) {
            this._nativeOfflineAudioContext.dispatchEvent(event);
          } else {
            setTimeout(() => this._waitForThePromiseToSettle(event));
          }
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js
var DEFAULT_OPTIONS17, createOscillatorNodeConstructor;
var init_oscillator_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-constructor.js"() {
    init_is_active_audio_node();
    init_set_internal_state_to_active();
    init_set_internal_state_to_passive();
    DEFAULT_OPTIONS17 = {
      channelCount: 2,
      channelCountMode: "max",
      // This attribute has no effect for nodes with no inputs.
      channelInterpretation: "speakers",
      // This attribute has no effect for nodes with no inputs.
      detune: 0,
      frequency: 440,
      periodicWave: void 0,
      type: "sine"
    };
    createOscillatorNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativeOscillatorNode2, createOscillatorNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, wrapEventListener3) => {
      return class OscillatorNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS17, ...options };
          const nativeOscillatorNode = createNativeOscillatorNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const oscillatorNodeRenderer = isOffline ? createOscillatorNodeRenderer2() : null;
          const nyquist = context.sampleRate / 2;
          super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);
          this._detune = createAudioParam2(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);
          this._frequency = createAudioParam2(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);
          this._nativeOscillatorNode = nativeOscillatorNode;
          this._onended = null;
          this._oscillatorNodeRenderer = oscillatorNodeRenderer;
          if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== void 0) {
            this._oscillatorNodeRenderer.periodicWave = mergedOptions.periodicWave;
          }
        }
        get detune() {
          return this._detune;
        }
        get frequency() {
          return this._frequency;
        }
        get onended() {
          return this._onended;
        }
        set onended(value) {
          const wrappedListener = typeof value === "function" ? wrapEventListener3(this, value) : null;
          this._nativeOscillatorNode.onended = wrappedListener;
          const nativeOnEnded = this._nativeOscillatorNode.onended;
          this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;
        }
        get type() {
          return this._nativeOscillatorNode.type;
        }
        set type(value) {
          this._nativeOscillatorNode.type = value;
          if (this._oscillatorNodeRenderer !== null) {
            this._oscillatorNodeRenderer.periodicWave = null;
          }
        }
        setPeriodicWave(periodicWave) {
          this._nativeOscillatorNode.setPeriodicWave(periodicWave);
          if (this._oscillatorNodeRenderer !== null) {
            this._oscillatorNodeRenderer.periodicWave = periodicWave;
          }
        }
        start(when = 0) {
          this._nativeOscillatorNode.start(when);
          if (this._oscillatorNodeRenderer !== null) {
            this._oscillatorNodeRenderer.start = when;
          }
          if (this.context.state !== "closed") {
            setInternalStateToActive(this);
            const resetInternalStateToPassive = () => {
              this._nativeOscillatorNode.removeEventListener("ended", resetInternalStateToPassive);
              if (isActiveAudioNode(this)) {
                setInternalStateToPassive(this);
              }
            };
            this._nativeOscillatorNode.addEventListener("ended", resetInternalStateToPassive);
          }
        }
        stop(when = 0) {
          this._nativeOscillatorNode.stop(when);
          if (this._oscillatorNodeRenderer !== null) {
            this._oscillatorNodeRenderer.stop = when;
          }
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js
var createOscillatorNodeRendererFactory;
var init_oscillator_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/oscillator-node-renderer-factory.js"() {
    init_is_owned_by_context();
    createOscillatorNodeRendererFactory = (connectAudioParam2, createNativeOscillatorNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeOscillatorNodes = /* @__PURE__ */ new WeakMap();
        let periodicWave = null;
        let start = null;
        let stop = null;
        const createOscillatorNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeOscillatorNode = getNativeAudioNode2(proxy);
          const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);
          if (!nativeOscillatorNodeIsOwnedByContext) {
            const options = {
              channelCount: nativeOscillatorNode.channelCount,
              channelCountMode: nativeOscillatorNode.channelCountMode,
              channelInterpretation: nativeOscillatorNode.channelInterpretation,
              detune: nativeOscillatorNode.detune.value,
              frequency: nativeOscillatorNode.frequency.value,
              periodicWave: periodicWave === null ? void 0 : periodicWave,
              type: nativeOscillatorNode.type
            };
            nativeOscillatorNode = createNativeOscillatorNode2(nativeOfflineAudioContext, options);
            if (start !== null) {
              nativeOscillatorNode.start(start);
            }
            if (stop !== null) {
              nativeOscillatorNode.stop(stop);
            }
          }
          renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);
          if (!nativeOscillatorNodeIsOwnedByContext) {
            await renderAutomation2(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
            await renderAutomation2(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
          } else {
            await connectAudioParam2(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);
          }
          await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeOscillatorNode);
          return nativeOscillatorNode;
        };
        return {
          set periodicWave(value) {
            periodicWave = value;
          },
          set start(value) {
            start = value;
          },
          set stop(value) {
            stop = value;
          },
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);
            if (renderedNativeOscillatorNode !== void 0) {
              return Promise.resolve(renderedNativeOscillatorNode);
            }
            return createOscillatorNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js
var DEFAULT_OPTIONS18, createPannerNodeConstructor;
var init_panner_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/panner-node-constructor.js"() {
    init_constants();
    DEFAULT_OPTIONS18 = {
      channelCount: 2,
      channelCountMode: "clamped-max",
      channelInterpretation: "speakers",
      coneInnerAngle: 360,
      coneOuterAngle: 360,
      coneOuterGain: 0,
      distanceModel: "inverse",
      maxDistance: 1e4,
      orientationX: 1,
      orientationY: 0,
      orientationZ: 0,
      panningModel: "equalpower",
      positionX: 0,
      positionY: 0,
      positionZ: 0,
      refDistance: 1,
      rolloffFactor: 1
    };
    createPannerNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativePannerNode2, createPannerNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
      return class PannerNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS18, ...options };
          const nativePannerNode = createNativePannerNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const pannerNodeRenderer = isOffline ? createPannerNodeRenderer2() : null;
          super(context, false, nativePannerNode, pannerNodeRenderer);
          this._nativePannerNode = nativePannerNode;
          this._orientationX = createAudioParam2(this, isOffline, nativePannerNode.orientationX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
          this._orientationY = createAudioParam2(this, isOffline, nativePannerNode.orientationY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
          this._orientationZ = createAudioParam2(this, isOffline, nativePannerNode.orientationZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
          this._positionX = createAudioParam2(this, isOffline, nativePannerNode.positionX, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
          this._positionY = createAudioParam2(this, isOffline, nativePannerNode.positionY, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
          this._positionZ = createAudioParam2(this, isOffline, nativePannerNode.positionZ, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);
          setAudioNodeTailTime2(this, 1);
        }
        get coneInnerAngle() {
          return this._nativePannerNode.coneInnerAngle;
        }
        set coneInnerAngle(value) {
          this._nativePannerNode.coneInnerAngle = value;
        }
        get coneOuterAngle() {
          return this._nativePannerNode.coneOuterAngle;
        }
        set coneOuterAngle(value) {
          this._nativePannerNode.coneOuterAngle = value;
        }
        get coneOuterGain() {
          return this._nativePannerNode.coneOuterGain;
        }
        set coneOuterGain(value) {
          this._nativePannerNode.coneOuterGain = value;
        }
        get distanceModel() {
          return this._nativePannerNode.distanceModel;
        }
        set distanceModel(value) {
          this._nativePannerNode.distanceModel = value;
        }
        get maxDistance() {
          return this._nativePannerNode.maxDistance;
        }
        set maxDistance(value) {
          this._nativePannerNode.maxDistance = value;
        }
        get orientationX() {
          return this._orientationX;
        }
        get orientationY() {
          return this._orientationY;
        }
        get orientationZ() {
          return this._orientationZ;
        }
        get panningModel() {
          return this._nativePannerNode.panningModel;
        }
        set panningModel(value) {
          this._nativePannerNode.panningModel = value;
        }
        get positionX() {
          return this._positionX;
        }
        get positionY() {
          return this._positionY;
        }
        get positionZ() {
          return this._positionZ;
        }
        get refDistance() {
          return this._nativePannerNode.refDistance;
        }
        set refDistance(value) {
          this._nativePannerNode.refDistance = value;
        }
        get rolloffFactor() {
          return this._nativePannerNode.rolloffFactor;
        }
        set rolloffFactor(value) {
          this._nativePannerNode.rolloffFactor = value;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js
var createPannerNodeRendererFactory;
var init_panner_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/panner-node-renderer-factory.js"() {
    init_native_audio_node_faker();
    init_is_owned_by_context();
    createPannerNodeRendererFactory = (connectAudioParam2, createNativeChannelMergerNode2, createNativeConstantSourceNode2, createNativeGainNode2, createNativePannerNode2, getNativeAudioNode2, nativeOfflineAudioContextConstructor2, renderAutomation2, renderInputsOfAudioNode2, renderNativeOfflineAudioContext2) => {
      return () => {
        const renderedNativeAudioNodes = /* @__PURE__ */ new WeakMap();
        let renderedBufferPromise = null;
        const createAudioNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeGainNode = null;
          let nativePannerNode = getNativeAudioNode2(proxy);
          const commonAudioNodeOptions = {
            channelCount: nativePannerNode.channelCount,
            channelCountMode: nativePannerNode.channelCountMode,
            channelInterpretation: nativePannerNode.channelInterpretation
          };
          const commonNativePannerNodeOptions = {
            ...commonAudioNodeOptions,
            coneInnerAngle: nativePannerNode.coneInnerAngle,
            coneOuterAngle: nativePannerNode.coneOuterAngle,
            coneOuterGain: nativePannerNode.coneOuterGain,
            distanceModel: nativePannerNode.distanceModel,
            maxDistance: nativePannerNode.maxDistance,
            panningModel: nativePannerNode.panningModel,
            refDistance: nativePannerNode.refDistance,
            rolloffFactor: nativePannerNode.rolloffFactor
          };
          const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);
          if ("bufferSize" in nativePannerNode) {
            nativeGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
          } else if (!nativePannerNodeIsOwnedByContext) {
            const options = {
              ...commonNativePannerNodeOptions,
              orientationX: nativePannerNode.orientationX.value,
              orientationY: nativePannerNode.orientationY.value,
              orientationZ: nativePannerNode.orientationZ.value,
              positionX: nativePannerNode.positionX.value,
              positionY: nativePannerNode.positionY.value,
              positionZ: nativePannerNode.positionZ.value
            };
            nativePannerNode = createNativePannerNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);
          if (nativeGainNode !== null) {
            if (renderedBufferPromise === null) {
              if (nativeOfflineAudioContextConstructor2 === null) {
                throw new Error("Missing the native OfflineAudioContext constructor.");
              }
              const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor2(
                6,
                // Bug #17: Safari does not yet expose the length.
                proxy.context.length,
                nativeOfflineAudioContext.sampleRate
              );
              const nativeChannelMergerNode = createNativeChannelMergerNode2(partialOfflineAudioContext, {
                channelCount: 1,
                channelCountMode: "explicit",
                channelInterpretation: "speakers",
                numberOfInputs: 6
              });
              nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);
              renderedBufferPromise = (async () => {
                const nativeConstantSourceNodes = await Promise.all([
                  proxy.orientationX,
                  proxy.orientationY,
                  proxy.orientationZ,
                  proxy.positionX,
                  proxy.positionY,
                  proxy.positionZ
                ].map(async (audioParam, index) => {
                  const nativeConstantSourceNode = createNativeConstantSourceNode2(partialOfflineAudioContext, {
                    channelCount: 1,
                    channelCountMode: "explicit",
                    channelInterpretation: "discrete",
                    offset: index === 0 ? 1 : 0
                  });
                  await renderAutomation2(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);
                  return nativeConstantSourceNode;
                }));
                for (let i = 0; i < 6; i += 1) {
                  nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);
                  nativeConstantSourceNodes[i].start(0);
                }
                return renderNativeOfflineAudioContext2(partialOfflineAudioContext);
              })();
            }
            const renderedBuffer = await renderedBufferPromise;
            const inputGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
            await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, inputGainNode);
            const channelDatas = [];
            for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {
              channelDatas.push(renderedBuffer.getChannelData(i));
            }
            let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];
            let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];
            let gateGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });
            let partialPannerNode = createNativePannerNode2(nativeOfflineAudioContext, {
              ...commonNativePannerNodeOptions,
              orientationX: lastOrientation[0],
              orientationY: lastOrientation[1],
              orientationZ: lastOrientation[2],
              positionX: lastPosition[0],
              positionY: lastPosition[1],
              positionZ: lastPosition[2]
            });
            inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
            partialPannerNode.connect(nativeGainNode);
            for (let i = 128; i < renderedBuffer.length; i += 128) {
              const orientation = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];
              const positon = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];
              if (orientation.some((value, index) => value !== lastOrientation[index]) || positon.some((value, index) => value !== lastPosition[index])) {
                lastOrientation = orientation;
                lastPosition = positon;
                const currentTime = i / nativeOfflineAudioContext.sampleRate;
                gateGainNode.gain.setValueAtTime(0, currentTime);
                gateGainNode = createNativeGainNode2(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });
                partialPannerNode = createNativePannerNode2(nativeOfflineAudioContext, {
                  ...commonNativePannerNodeOptions,
                  orientationX: lastOrientation[0],
                  orientationY: lastOrientation[1],
                  orientationZ: lastOrientation[2],
                  positionX: lastPosition[0],
                  positionY: lastPosition[1],
                  positionZ: lastPosition[2]
                });
                gateGainNode.gain.setValueAtTime(1, currentTime);
                inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]);
                partialPannerNode.connect(nativeGainNode);
              }
            }
            return nativeGainNode;
          }
          if (!nativePannerNodeIsOwnedByContext) {
            await renderAutomation2(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
            await renderAutomation2(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
            await renderAutomation2(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
            await renderAutomation2(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
            await renderAutomation2(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
            await renderAutomation2(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
          } else {
            await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);
            await connectAudioParam2(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);
          }
          if (isNativeAudioNodeFaker(nativePannerNode)) {
            await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);
          } else {
            await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativePannerNode);
          }
          return nativePannerNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);
            if (renderedNativeGainNodeOrNativePannerNode !== void 0) {
              return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);
            }
            return createAudioNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js
var DEFAULT_OPTIONS19, createPeriodicWaveConstructor;
var init_periodic_wave_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/periodic-wave-constructor.js"() {
    DEFAULT_OPTIONS19 = {
      disableNormalization: false
    };
    createPeriodicWaveConstructor = (createNativePeriodicWave2, getNativeContext2, periodicWaveStore, sanitizePeriodicWaveOptions2) => {
      return class PeriodicWave {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = sanitizePeriodicWaveOptions2({ ...DEFAULT_OPTIONS19, ...options });
          const periodicWave = createNativePeriodicWave2(nativeContext, mergedOptions);
          periodicWaveStore.add(periodicWave);
          return periodicWave;
        }
        static [Symbol.hasInstance](instance) {
          return instance !== null && typeof instance === "object" && Object.getPrototypeOf(instance) === PeriodicWave.prototype || periodicWaveStore.has(instance);
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/render-automation.js
var createRenderAutomation;
var init_render_automation = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/render-automation.js"() {
    createRenderAutomation = (getAudioParamRenderer, renderInputsOfAudioParam2) => {
      return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {
        const audioParamRenderer = getAudioParamRenderer(audioParam);
        audioParamRenderer.replay(nativeAudioParam);
        return renderInputsOfAudioParam2(audioParam, nativeOfflineAudioContext, nativeAudioParam);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js
var createRenderInputsOfAudioNode;
var init_render_inputs_of_audio_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-node.js"() {
    createRenderInputsOfAudioNode = (getAudioNodeConnections2, getAudioNodeRenderer2, isPartOfACycle2) => {
      return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {
        const audioNodeConnections = getAudioNodeConnections2(audioNode);
        await Promise.all(audioNodeConnections.activeInputs.map((connections, input) => Array.from(connections).map(async ([source, output]) => {
          const audioNodeRenderer = getAudioNodeRenderer2(source);
          const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
          const destination = audioNode.context.destination;
          if (!isPartOfACycle2(source) && (audioNode !== destination || !isPartOfACycle2(audioNode))) {
            renderedNativeAudioNode.connect(nativeAudioNode, output, input);
          }
        })).reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], []));
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js
var createRenderInputsOfAudioParam;
var init_render_inputs_of_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/render-inputs-of-audio-param.js"() {
    createRenderInputsOfAudioParam = (getAudioNodeRenderer2, getAudioParamConnections2, isPartOfACycle2) => {
      return async (audioParam, nativeOfflineAudioContext, nativeAudioParam) => {
        const audioParamConnections = getAudioParamConnections2(audioParam);
        await Promise.all(Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {
          const audioNodeRenderer = getAudioNodeRenderer2(source);
          const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);
          if (!isPartOfACycle2(source)) {
            renderedNativeAudioNode.connect(nativeAudioParam, output);
          }
        }));
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js
var createRenderNativeOfflineAudioContext;
var init_render_native_offline_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/render-native-offline-audio-context.js"() {
    init_test_promise_support();
    createRenderNativeOfflineAudioContext = (cacheTestResult2, createNativeGainNode2, createNativeScriptProcessorNode2, testOfflineAudioContextCurrentTimeSupport) => {
      return (nativeOfflineAudioContext) => {
        if (cacheTestResult2(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {
          return Promise.resolve(cacheTestResult2(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)).then((isOfflineAudioContextCurrentTimeSupported) => {
            if (!isOfflineAudioContextCurrentTimeSupported) {
              const scriptProcessorNode = createNativeScriptProcessorNode2(nativeOfflineAudioContext, 512, 0, 1);
              nativeOfflineAudioContext.oncomplete = () => {
                scriptProcessorNode.onaudioprocess = null;
                scriptProcessorNode.disconnect();
              };
              scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime;
              scriptProcessorNode.connect(nativeOfflineAudioContext.destination);
            }
            return nativeOfflineAudioContext.startRendering();
          });
        }
        return new Promise((resolve) => {
          const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {
            channelCount: 1,
            channelCountMode: "explicit",
            channelInterpretation: "discrete",
            gain: 0
          });
          nativeOfflineAudioContext.oncomplete = (event) => {
            gainNode.disconnect();
            resolve(event.renderedBuffer);
          };
          gainNode.connect(nativeOfflineAudioContext.destination);
          nativeOfflineAudioContext.startRendering();
        });
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/set-active-audio-worklet-node-inputs.js
var createSetActiveAudioWorkletNodeInputs;
var init_set_active_audio_worklet_node_inputs = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/set-active-audio-worklet-node-inputs.js"() {
    createSetActiveAudioWorkletNodeInputs = (activeAudioWorkletNodeInputsStore2) => {
      return (nativeAudioWorkletNode, activeInputs) => {
        activeAudioWorkletNodeInputsStore2.set(nativeAudioWorkletNode, activeInputs);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/set-audio-node-tail-time.js
var createSetAudioNodeTailTime;
var init_set_audio_node_tail_time = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/set-audio-node-tail-time.js"() {
    createSetAudioNodeTailTime = (audioNodeTailTimeStore2) => {
      return (audioNode, tailTime) => audioNodeTailTimeStore2.set(audioNode, tailTime);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js
var createStartRendering;
var init_start_rendering = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/start-rendering.js"() {
    init_wrap_audio_buffer_get_channel_data_method();
    createStartRendering = (audioBufferStore2, cacheTestResult2, getAudioNodeRenderer2, getUnrenderedAudioWorkletNodes2, renderNativeOfflineAudioContext2, testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, wrapAudioBufferCopyChannelMethods2, wrapAudioBufferCopyChannelMethodsOutOfBounds2) => {
      return (destination, nativeOfflineAudioContext) => getAudioNodeRenderer2(destination).render(destination, nativeOfflineAudioContext).then(() => Promise.all(Array.from(getUnrenderedAudioWorkletNodes2(nativeOfflineAudioContext)).map((audioWorkletNode) => getAudioNodeRenderer2(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)))).then(() => renderNativeOfflineAudioContext2(nativeOfflineAudioContext)).then((audioBuffer) => {
        if (typeof audioBuffer.copyFromChannel !== "function") {
          wrapAudioBufferCopyChannelMethods2(audioBuffer);
          wrapAudioBufferGetChannelDataMethod(audioBuffer);
        } else if (!cacheTestResult2(testAudioBufferCopyChannelMethodsOutOfBoundsSupport2, () => testAudioBufferCopyChannelMethodsOutOfBoundsSupport2(audioBuffer))) {
          wrapAudioBufferCopyChannelMethodsOutOfBounds2(audioBuffer);
        }
        audioBufferStore2.add(audioBuffer);
        return audioBuffer;
      });
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js
var DEFAULT_OPTIONS20, createStereoPannerNodeConstructor;
var init_stereo_panner_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-constructor.js"() {
    DEFAULT_OPTIONS20 = {
      channelCount: 2,
      /*
       * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent
       * behavior.
       */
      channelCountMode: "explicit",
      channelInterpretation: "speakers",
      pan: 0
    };
    createStereoPannerNodeConstructor = (audioNodeConstructor2, createAudioParam2, createNativeStereoPannerNode2, createStereoPannerNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2) => {
      return class StereoPannerNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS20, ...options };
          const nativeStereoPannerNode = createNativeStereoPannerNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const stereoPannerNodeRenderer = isOffline ? createStereoPannerNodeRenderer2() : null;
          super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);
          this._pan = createAudioParam2(this, isOffline, nativeStereoPannerNode.pan);
        }
        get pan() {
          return this._pan;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js
var createStereoPannerNodeRendererFactory;
var init_stereo_panner_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/stereo-panner-node-renderer-factory.js"() {
    init_native_audio_node_faker();
    init_is_owned_by_context();
    createStereoPannerNodeRendererFactory = (connectAudioParam2, createNativeStereoPannerNode2, getNativeAudioNode2, renderAutomation2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeStereoPannerNodes = /* @__PURE__ */ new WeakMap();
        const createStereoPannerNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeStereoPannerNode = getNativeAudioNode2(proxy);
          const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);
          if (!nativeStereoPannerNodeIsOwnedByContext) {
            const options = {
              channelCount: nativeStereoPannerNode.channelCount,
              channelCountMode: nativeStereoPannerNode.channelCountMode,
              channelInterpretation: nativeStereoPannerNode.channelInterpretation,
              pan: nativeStereoPannerNode.pan.value
            };
            nativeStereoPannerNode = createNativeStereoPannerNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);
          if (!nativeStereoPannerNodeIsOwnedByContext) {
            await renderAutomation2(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
          } else {
            await connectAudioParam2(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);
          }
          if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {
            await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);
          } else {
            await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);
          }
          return nativeStereoPannerNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);
            if (renderedNativeStereoPannerNode !== void 0) {
              return Promise.resolve(renderedNativeStereoPannerNode);
            }
            return createStereoPannerNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js
var createTestAudioBufferConstructorSupport;
var init_test_audio_buffer_constructor_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-constructor-support.js"() {
    createTestAudioBufferConstructorSupport = (nativeAudioBufferConstructor2) => {
      return () => {
        if (nativeAudioBufferConstructor2 === null) {
          return false;
        }
        try {
          new nativeAudioBufferConstructor2({ length: 1, sampleRate: 44100 });
        } catch {
          return false;
        }
        return true;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-copy-channel-methods-subarray-support.js
var init_test_audio_buffer_copy_channel_methods_subarray_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-audio-buffer-copy-channel-methods-subarray-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-close-method-support.js
var init_test_audio_context_close_method_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-close-method-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-decode-audio-data-method-type-error-support.js
var init_test_audio_context_decode_audio_data_method_type_error_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-decode-audio-data-method-type-error-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-options-support.js
var init_test_audio_context_options_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-audio-context-options-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-audio-node-connect-method-support.js
var init_test_audio_node_connect_method_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-audio-node-connect-method-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-no-outputs-support.js
var init_test_audio_worklet_processor_no_outputs_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-no-outputs-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-post-message-support.js
var createTestAudioWorkletProcessorPostMessageSupport;
var init_test_audio_worklet_processor_post_message_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-audio-worklet-processor-post-message-support.js"() {
    createTestAudioWorkletProcessorPostMessageSupport = (nativeAudioWorkletNodeConstructor2, nativeOfflineAudioContextConstructor2) => {
      return async () => {
        if (nativeAudioWorkletNodeConstructor2 === null) {
          return true;
        }
        if (nativeOfflineAudioContextConstructor2 === null) {
          return false;
        }
        const blob3 = new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'], {
          type: "application/javascript; charset=utf-8"
        });
        const offlineAudioContext = new nativeOfflineAudioContextConstructor2(1, 128, 44100);
        const url4 = URL.createObjectURL(blob3);
        let isEmittingMessageEvents = false;
        let isEmittingProcessorErrorEvents = false;
        try {
          await offlineAudioContext.audioWorklet.addModule(url4);
          const audioWorkletNode = new nativeAudioWorkletNodeConstructor2(offlineAudioContext, "a", { numberOfOutputs: 0 });
          const oscillator = offlineAudioContext.createOscillator();
          audioWorkletNode.port.onmessage = () => isEmittingMessageEvents = true;
          audioWorkletNode.onprocessorerror = () => isEmittingProcessorErrorEvents = true;
          oscillator.connect(audioWorkletNode);
          oscillator.start(0);
          await offlineAudioContext.startRendering();
          await new Promise((resolve) => setTimeout(resolve));
        } catch {
        } finally {
          URL.revokeObjectURL(url4);
        }
        return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-channel-merger-node-channel-count-support.js
var init_test_channel_merger_node_channel_count_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-channel-merger-node-channel-count-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-constant-source-node-accurate-scheduling-support.js
var init_test_constant_source_node_accurate_scheduling_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-constant-source-node-accurate-scheduling-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-buffer-reassignability-support.js
var init_test_convolver_node_buffer_reassignability_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-buffer-reassignability-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-channel-count-support.js
var init_test_convolver_node_channel_count_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-convolver-node-channel-count-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-is-secure-context-support.js
var init_test_is_secure_context_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-is-secure-context-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js
var init_test_media_stream_audio_source_node_media_stream_without_audio_track_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js
var createTestOfflineAudioContextCurrentTimeSupport;
var init_test_offline_audio_context_current_time_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-offline-audio-context-current-time-support.js"() {
    createTestOfflineAudioContextCurrentTimeSupport = (createNativeGainNode2, nativeOfflineAudioContextConstructor2) => {
      return () => {
        if (nativeOfflineAudioContextConstructor2 === null) {
          return Promise.resolve(false);
        }
        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor2(1, 1, 44100);
        const gainNode = createNativeGainNode2(nativeOfflineAudioContext, {
          channelCount: 1,
          channelCountMode: "explicit",
          channelInterpretation: "discrete",
          gain: 0
        });
        return new Promise((resolve) => {
          nativeOfflineAudioContext.oncomplete = () => {
            gainNode.disconnect();
            resolve(nativeOfflineAudioContext.currentTime !== 0);
          };
          nativeOfflineAudioContext.startRendering();
        });
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/test-stereo-panner-node-default-value-support.js
var init_test_stereo_panner_node_default_value_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/test-stereo-panner-node-default-value-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js
var createUnknownError;
var init_unknown_error = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/unknown-error.js"() {
    createUnknownError = () => new DOMException("", "UnknownError");
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js
var DEFAULT_OPTIONS21, createWaveShaperNodeConstructor;
var init_wave_shaper_node_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-constructor.js"() {
    DEFAULT_OPTIONS21 = {
      channelCount: 2,
      channelCountMode: "max",
      channelInterpretation: "speakers",
      curve: null,
      oversample: "none"
    };
    createWaveShaperNodeConstructor = (audioNodeConstructor2, createInvalidStateError3, createNativeWaveShaperNode2, createWaveShaperNodeRenderer2, getNativeContext2, isNativeOfflineAudioContext2, setAudioNodeTailTime2) => {
      return class WaveShaperNode extends audioNodeConstructor2 {
        constructor(context, options) {
          const nativeContext = getNativeContext2(context);
          const mergedOptions = { ...DEFAULT_OPTIONS21, ...options };
          const nativeWaveShaperNode = createNativeWaveShaperNode2(nativeContext, mergedOptions);
          const isOffline = isNativeOfflineAudioContext2(nativeContext);
          const waveShaperNodeRenderer = isOffline ? createWaveShaperNodeRenderer2() : null;
          super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);
          this._isCurveNullified = false;
          this._nativeWaveShaperNode = nativeWaveShaperNode;
          setAudioNodeTailTime2(this, 1);
        }
        get curve() {
          if (this._isCurveNullified) {
            return null;
          }
          return this._nativeWaveShaperNode.curve;
        }
        set curve(value) {
          if (value === null) {
            this._isCurveNullified = true;
            this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);
          } else {
            if (value.length < 2) {
              throw createInvalidStateError3();
            }
            this._isCurveNullified = false;
            this._nativeWaveShaperNode.curve = value;
          }
        }
        get oversample() {
          return this._nativeWaveShaperNode.oversample;
        }
        set oversample(value) {
          this._nativeWaveShaperNode.oversample = value;
        }
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js
var createWaveShaperNodeRendererFactory;
var init_wave_shaper_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/wave-shaper-node-renderer-factory.js"() {
    init_native_audio_node_faker();
    init_is_owned_by_context();
    createWaveShaperNodeRendererFactory = (createNativeWaveShaperNode2, getNativeAudioNode2, renderInputsOfAudioNode2) => {
      return () => {
        const renderedNativeWaveShaperNodes = /* @__PURE__ */ new WeakMap();
        const createWaveShaperNode = async (proxy, nativeOfflineAudioContext) => {
          let nativeWaveShaperNode = getNativeAudioNode2(proxy);
          const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);
          if (!nativeWaveShaperNodeIsOwnedByContext) {
            const options = {
              channelCount: nativeWaveShaperNode.channelCount,
              channelCountMode: nativeWaveShaperNode.channelCountMode,
              channelInterpretation: nativeWaveShaperNode.channelInterpretation,
              curve: nativeWaveShaperNode.curve,
              oversample: nativeWaveShaperNode.oversample
            };
            nativeWaveShaperNode = createNativeWaveShaperNode2(nativeOfflineAudioContext, options);
          }
          renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);
          if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {
            await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);
          } else {
            await renderInputsOfAudioNode2(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);
          }
          return nativeWaveShaperNode;
        };
        return {
          render(proxy, nativeOfflineAudioContext) {
            const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);
            if (renderedNativeWaveShaperNode !== void 0) {
              return Promise.resolve(renderedNativeWaveShaperNode);
            }
            return createWaveShaperNode(proxy, nativeOfflineAudioContext);
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/window.js
var createWindow2;
var init_window3 = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/window.js"() {
    createWindow2 = () => typeof window === "undefined" ? null : window;
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js
var createWrapAudioBufferCopyChannelMethods;
var init_wrap_audio_buffer_copy_channel_methods = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods.js"() {
    createWrapAudioBufferCopyChannelMethods = (convertNumberToUnsignedLong2, createIndexSizeError2) => {
      return (audioBuffer) => {
        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
          const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
          const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
          if (channelNumber >= audioBuffer.numberOfChannels) {
            throw createIndexSizeError2();
          }
          const audioBufferLength = audioBuffer.length;
          const channelData = audioBuffer.getChannelData(channelNumber);
          const destinationLength = destination.length;
          for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {
            destination[i] = channelData[i + bufferOffset];
          }
        };
        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
          const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
          const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
          if (channelNumber >= audioBuffer.numberOfChannels) {
            throw createIndexSizeError2();
          }
          const audioBufferLength = audioBuffer.length;
          const channelData = audioBuffer.getChannelData(channelNumber);
          const sourceLength = source.length;
          for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {
            channelData[i + bufferOffset] = source[i];
          }
        };
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js
var createWrapAudioBufferCopyChannelMethodsOutOfBounds;
var init_wrap_audio_buffer_copy_channel_methods_out_of_bounds = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.js"() {
    createWrapAudioBufferCopyChannelMethodsOutOfBounds = (convertNumberToUnsignedLong2) => {
      return (audioBuffer) => {
        audioBuffer.copyFromChannel = /* @__PURE__ */ ((copyFromChannel2) => {
          return (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
            const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
            const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
            if (bufferOffset < audioBuffer.length) {
              return copyFromChannel2.call(audioBuffer, destination, channelNumber, bufferOffset);
            }
          };
        })(audioBuffer.copyFromChannel);
        audioBuffer.copyToChannel = /* @__PURE__ */ ((copyToChannel2) => {
          return (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {
            const bufferOffset = convertNumberToUnsignedLong2(bufferOffsetAsNumber);
            const channelNumber = convertNumberToUnsignedLong2(channelNumberAsNumber);
            if (bufferOffset < audioBuffer.length) {
              return copyToChannel2.call(audioBuffer, source, channelNumber, bufferOffset);
            }
          };
        })(audioBuffer.copyToChannel);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js
var createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer;
var init_wrap_audio_buffer_source_node_stop_method_nullified_buffer = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.js"() {
    createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer = (overwriteAccessors2) => {
      return (nativeAudioBufferSourceNode, nativeContext) => {
        const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);
        if (nativeAudioBufferSourceNode.buffer === null) {
          nativeAudioBufferSourceNode.buffer = nullifiedBuffer;
        }
        overwriteAccessors2(nativeAudioBufferSourceNode, "buffer", (get) => () => {
          const value = get.call(nativeAudioBufferSourceNode);
          return value === nullifiedBuffer ? null : value;
        }, (set2) => (value) => {
          return set2.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);
        });
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js
var createWrapChannelMergerNode;
var init_wrap_channel_merger_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/factories/wrap-channel-merger-node.js"() {
    createWrapChannelMergerNode = (createInvalidStateError3, monitorConnections2) => {
      return (nativeContext, channelMergerNode) => {
        channelMergerNode.channelCount = 1;
        channelMergerNode.channelCountMode = "explicit";
        Object.defineProperty(channelMergerNode, "channelCount", {
          get: () => 1,
          set: () => {
            throw createInvalidStateError3();
          }
        });
        Object.defineProperty(channelMergerNode, "channelCountMode", {
          get: () => "explicit",
          set: () => {
            throw createInvalidStateError3();
          }
        });
        const audioBufferSourceNode = nativeContext.createBufferSource();
        const whenConnected = () => {
          const length = channelMergerNode.numberOfInputs;
          for (let i = 0; i < length; i += 1) {
            audioBufferSourceNode.connect(channelMergerNode, 0, i);
          }
        };
        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);
        monitorConnections2(channelMergerNode, whenConnected, whenDisconnected);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/get-first-sample.js
var getFirstSample;
var init_get_first_sample = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/get-first-sample.js"() {
    getFirstSample = (audioBuffer, buffer, channelNumber) => {
      if (audioBuffer.copyFromChannel === void 0) {
        return audioBuffer.getChannelData(channelNumber)[0];
      }
      audioBuffer.copyFromChannel(buffer, channelNumber);
      return buffer[0];
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js
var isDCCurve;
var init_is_dc_curve = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/is-dc-curve.js"() {
    isDCCurve = (curve) => {
      if (curve === null) {
        return false;
      }
      const length = curve.length;
      if (length % 2 !== 0) {
        return curve[Math.floor(length / 2)] !== 0;
      }
      return curve[length / 2 - 1] + curve[length / 2] !== 0;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js
var overwriteAccessors;
var init_overwrite_accessors = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/overwrite-accessors.js"() {
    overwriteAccessors = (object3, property, createGetter, createSetter) => {
      let prototype = object3;
      while (!prototype.hasOwnProperty(property)) {
        prototype = Object.getPrototypeOf(prototype);
      }
      const { get, set: set2 } = Object.getOwnPropertyDescriptor(prototype, property);
      Object.defineProperty(object3, property, { get: createGetter(get), set: createSetter(set2) });
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/sanitize-audio-worklet-node-options.js
var sanitizeAudioWorkletNodeOptions;
var init_sanitize_audio_worklet_node_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/sanitize-audio-worklet-node-options.js"() {
    sanitizeAudioWorkletNodeOptions = (options) => {
      return {
        ...options,
        outputChannelCount: options.outputChannelCount !== void 0 ? options.outputChannelCount : options.numberOfInputs === 1 && options.numberOfOutputs === 1 ? (
          /*
           * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why
           * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That
           * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.
           */
          [options.channelCount]
        ) : Array.from({ length: options.numberOfOutputs }, () => 1)
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/sanitize-channel-splitter-options.js
var sanitizeChannelSplitterOptions;
var init_sanitize_channel_splitter_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/sanitize-channel-splitter-options.js"() {
    sanitizeChannelSplitterOptions = (options) => {
      return { ...options, channelCount: options.numberOfOutputs };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/sanitize-periodic-wave-options.js
var sanitizePeriodicWaveOptions;
var init_sanitize_periodic_wave_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/sanitize-periodic-wave-options.js"() {
    sanitizePeriodicWaveOptions = (options) => {
      const { imag, real } = options;
      if (imag === void 0) {
        if (real === void 0) {
          return { ...options, imag: [0, 0], real: [0, 0] };
        }
        return { ...options, imag: Array.from(real, () => 0), real };
      }
      if (real === void 0) {
        return { ...options, imag, real: Array.from(imag, () => 0) };
      }
      return { ...options, imag, real };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/set-value-at-time-until-possible.js
var setValueAtTimeUntilPossible;
var init_set_value_at_time_until_possible = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/set-value-at-time-until-possible.js"() {
    setValueAtTimeUntilPossible = (audioParam, value, startTime) => {
      try {
        audioParam.setValueAtTime(value, startTime);
      } catch (err) {
        if (err.code !== 9) {
          throw err;
        }
        setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.js
var testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport;
var init_test_audio_buffer_source_node_start_method_consecutive_calls_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.js"() {
    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext) => {
      const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
      nativeAudioBufferSourceNode.start();
      try {
        nativeAudioBufferSourceNode.start();
      } catch {
        return true;
      }
      return false;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.js
var testAudioBufferSourceNodeStartMethodOffsetClampingSupport;
var init_test_audio_buffer_source_node_start_method_offset_clamping_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.js"() {
    testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext) => {
      const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
      const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
      nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
      try {
        nativeAudioBufferSourceNode.start(0, 1);
      } catch {
        return false;
      }
      return true;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js
var testAudioBufferSourceNodeStopMethodNullifiedBufferSupport;
var init_test_audio_buffer_source_node_stop_method_nullified_buffer_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.js"() {
    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext) => {
      const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
      nativeAudioBufferSourceNode.start();
      try {
        nativeAudioBufferSourceNode.stop();
      } catch {
        return false;
      }
      return true;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.js
var testAudioScheduledSourceNodeStartMethodNegativeParametersSupport;
var init_test_audio_scheduled_source_node_start_method_negative_parameters_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.js"() {
    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext) => {
      const nativeAudioBufferSourceNode = nativeContext.createOscillator();
      try {
        nativeAudioBufferSourceNode.start(-1);
      } catch (err) {
        return err instanceof RangeError;
      }
      return false;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js
var testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport;
var init_test_audio_scheduled_source_node_stop_method_consecutive_calls_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.js"() {
    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext) => {
      const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);
      const nativeAudioBufferSourceNode = nativeContext.createBufferSource();
      nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;
      nativeAudioBufferSourceNode.start();
      nativeAudioBufferSourceNode.stop();
      try {
        nativeAudioBufferSourceNode.stop();
        return true;
      } catch {
        return false;
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js
var testAudioScheduledSourceNodeStopMethodNegativeParametersSupport;
var init_test_audio_scheduled_source_node_stop_method_negative_parameters_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.js"() {
    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext) => {
      const nativeAudioBufferSourceNode = nativeContext.createOscillator();
      try {
        nativeAudioBufferSourceNode.stop(-1);
      } catch (err) {
        return err instanceof RangeError;
      }
      return false;
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-audio-worklet-node-options-clonability.js
var testAudioWorkletNodeOptionsClonability;
var init_test_audio_worklet_node_options_clonability = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-audio-worklet-node-options-clonability.js"() {
    testAudioWorkletNodeOptionsClonability = (audioWorkletNodeOptions) => {
      const { port1, port2 } = new MessageChannel();
      try {
        port1.postMessage(audioWorkletNodeOptions);
      } finally {
        port1.close();
        port2.close();
      }
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-dom-exception-constructor-support.js
var init_test_dom_exception_constructor_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-dom-exception-constructor-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/test-transferables-support.js
var init_test_transferables_support = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/test-transferables-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js
var wrapAudioBufferSourceNodeStartMethodOffsetClamping;
var init_wrap_audio_buffer_source_node_start_method_offset_clamping = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.js"() {
    wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode) => {
      nativeAudioBufferSourceNode.start = /* @__PURE__ */ ((start) => {
        return (when = 0, offset = 0, duration3) => {
          const buffer = nativeAudioBufferSourceNode.buffer;
          const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);
          if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {
            start.call(nativeAudioBufferSourceNode, when, 0, 0);
          } else {
            start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration3);
          }
        };
      })(nativeAudioBufferSourceNode.start);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js
var wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls;
var init_wrap_audio_scheduled_source_node_stop_method_consecutive_calls = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.js"() {
    init_intercept_connections();
    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = (nativeAudioScheduledSourceNode, nativeContext) => {
      const nativeGainNode = nativeContext.createGain();
      nativeAudioScheduledSourceNode.connect(nativeGainNode);
      const disconnectGainNode = /* @__PURE__ */ ((disconnect3) => {
        return () => {
          disconnect3.call(nativeAudioScheduledSourceNode, nativeGainNode);
          nativeAudioScheduledSourceNode.removeEventListener("ended", disconnectGainNode);
        };
      })(nativeAudioScheduledSourceNode.disconnect);
      nativeAudioScheduledSourceNode.addEventListener("ended", disconnectGainNode);
      interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);
      nativeAudioScheduledSourceNode.stop = /* @__PURE__ */ ((stop) => {
        let isStopped = false;
        return (when = 0) => {
          if (isStopped) {
            try {
              stop.call(nativeAudioScheduledSourceNode, when);
            } catch {
              nativeGainNode.gain.setValueAtTime(0, when);
            }
          } else {
            stop.call(nativeAudioScheduledSourceNode, when);
            isStopped = true;
          }
        };
      })(nativeAudioScheduledSourceNode.stop);
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js
var wrapEventListener;
var init_wrap_event_listener = __esm({
  "node_modules/standardized-audio-context/build/es2019/helpers/wrap-event-listener.js"() {
    wrapEventListener = (target, eventListener) => {
      return (event) => {
        const descriptor = { value: target };
        Object.defineProperties(event, {
          currentTarget: descriptor,
          target: descriptor
        });
        if (typeof eventListener === "function") {
          return eventListener.call(target, event);
        }
        return eventListener.handleEvent.call(target, event);
      };
    };
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/analyser-node.js
var init_analyser_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/analyser-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/analyser-options.js
var init_analyser_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/analyser-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer.js
var init_audio_buffer = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-options.js
var init_audio_buffer_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-node.js
var init_audio_buffer_source_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-node-renderer.js
var init_audio_buffer_source_node_renderer = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-node-renderer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-options.js
var init_audio_buffer_source_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-buffer-source-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-context.js
var init_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-context-options.js
var init_audio_context_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-context-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-destination-node.js
var init_audio_destination_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-destination-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-listener.js
var init_audio_listener = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-listener.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-node.js
var init_audio_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-node-options.js
var init_audio_node_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-node-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-node-renderer.js
var init_audio_node_renderer = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-node-renderer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-param.js
var init_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-param.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-param-descriptor.js
var init_audio_param_descriptor = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-param-descriptor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-param-renderer.js
var init_audio_param_renderer2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-param-renderer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-scheduled-source-node.js
var init_audio_scheduled_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-scheduled-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-scheduled-source-node-event-map.js
var init_audio_scheduled_source_node_event_map = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-scheduled-source-node-event-map.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet.js
var init_audio_worklet = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node.js
var init_audio_worklet_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node-event-map.js
var init_audio_worklet_node_event_map = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node-event-map.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node-options.js
var init_audio_worklet_node_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-node-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-processor.js
var init_audio_worklet_processor = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-processor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-processor-constructor.js
var init_audio_worklet_processor_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/audio-worklet-processor-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/automation.js
var init_automation = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/automation.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/base-audio-context.js
var init_base_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/base-audio-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/biquad-filter-node.js
var init_biquad_filter_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/biquad-filter-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/biquad-filter-options.js
var init_biquad_filter_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/biquad-filter-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/channel-merger-options.js
var init_channel_merger_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/channel-merger-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/channel-splitter-options.js
var init_channel_splitter_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/channel-splitter-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/common-audio-context.js
var init_common_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/common-audio-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/common-offline-audio-context.js
var init_common_offline_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/common-offline-audio-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-node.js
var init_constant_source_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-node-renderer.js
var init_constant_source_node_renderer = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-node-renderer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-options.js
var init_constant_source_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/constant-source-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/convolver-node.js
var init_convolver_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/convolver-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/convolver-options.js
var init_convolver_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/convolver-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/delay-node.js
var init_delay_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/delay-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/delay-options.js
var init_delay_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/delay-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/dynamics-compressor-node.js
var init_dynamics_compressor_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/dynamics-compressor-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/dynamics-compressor-options.js
var init_dynamics_compressor_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/dynamics-compressor-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/event-target.js
var init_event_target = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/event-target.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/gain-node.js
var init_gain_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/gain-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/gain-options.js
var init_gain_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/gain-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/iir-filter-node.js
var init_iir_filter_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/iir-filter-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/iir-filter-options.js
var init_iir_filter_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/iir-filter-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/media-element-audio-source-node.js
var init_media_element_audio_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/media-element-audio-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/media-element-audio-source-options.js
var init_media_element_audio_source_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/media-element-audio-source-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-destination-node.js
var init_media_stream_audio_destination_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-destination-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-source-node.js
var init_media_stream_audio_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-source-options.js
var init_media_stream_audio_source_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-audio-source-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-track-audio-source-node.js
var init_media_stream_track_audio_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-track-audio-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-track-audio-source-options.js
var init_media_stream_track_audio_source_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/media-stream-track-audio-source-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/minimal-audio-context.js
var init_minimal_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/minimal-audio-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/minimal-base-audio-context.js
var init_minimal_base_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/minimal-base-audio-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/minimal-base-audio-context-event-map.js
var init_minimal_base_audio_context_event_map = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/minimal-base-audio-context-event-map.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/minimal-offline-audio-context.js
var init_minimal_offline_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/minimal-offline-audio-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/native-audio-node-faker.js
var init_native_audio_node_faker2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/native-audio-node-faker.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/native-audio-worklet-node-faker.js
var init_native_audio_worklet_node_faker = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/native-audio-worklet-node-faker.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/native-constant-source-node-faker.js
var init_native_constant_source_node_faker = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/native-constant-source-node-faker.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/native-convolver-node-faker.js
var init_native_convolver_node_faker = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/native-convolver-node-faker.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/native-iir-filter-node-faker.js
var init_native_iir_filter_node_faker = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/native-iir-filter-node-faker.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/native-panner-node-faker.js
var init_native_panner_node_faker = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/native-panner-node-faker.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/native-stereo-panner-node-faker.js
var init_native_stereo_panner_node_faker = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/native-stereo-panner-node-faker.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/native-wave-shaper-node-faker.js
var init_native_wave_shaper_node_faker = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/native-wave-shaper-node-faker.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-completion-event.js
var init_offline_audio_completion_event = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-completion-event.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context.js
var init_offline_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context-constructor.js
var init_offline_audio_context_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context-options.js
var init_offline_audio_context_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/offline-audio-context-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-node.js
var init_oscillator_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-node-renderer.js
var init_oscillator_node_renderer = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-node-renderer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-options.js
var init_oscillator_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/oscillator-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/panner-node.js
var init_panner_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/panner-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/panner-options.js
var init_panner_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/panner-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave.js
var init_periodic_wave = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave-constraints.js
var init_periodic_wave_constraints = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave-constraints.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave-options.js
var init_periodic_wave_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/periodic-wave-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/read-only-map.js
var init_read_only_map2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/read-only-map.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/stereo-panner-node.js
var init_stereo_panner_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/stereo-panner-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/stereo-panner-options.js
var init_stereo_panner_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/stereo-panner-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/wave-shaper-node.js
var init_wave_shaper_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/wave-shaper-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/wave-shaper-options.js
var init_wave_shaper_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/wave-shaper-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/worklet-options.js
var init_worklet_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/worklet-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/interfaces/index.js
var init_interfaces8 = __esm({
  "node_modules/standardized-audio-context/build/es2019/interfaces/index.js"() {
    init_analyser_node();
    init_analyser_options();
    init_audio_buffer();
    init_audio_buffer_options();
    init_audio_buffer_source_node2();
    init_audio_buffer_source_node_renderer();
    init_audio_buffer_source_options();
    init_audio_context();
    init_audio_context_options();
    init_audio_destination_node();
    init_audio_listener();
    init_audio_node2();
    init_audio_node_options();
    init_audio_node_renderer();
    init_audio_param();
    init_audio_param_descriptor();
    init_audio_param_renderer2();
    init_audio_scheduled_source_node();
    init_audio_scheduled_source_node_event_map();
    init_audio_worklet();
    init_audio_worklet_node2();
    init_audio_worklet_node_event_map();
    init_audio_worklet_node_options();
    init_audio_worklet_processor();
    init_audio_worklet_processor_constructor();
    init_automation();
    init_base_audio_context();
    init_biquad_filter_node2();
    init_biquad_filter_options();
    init_channel_merger_options();
    init_channel_splitter_options();
    init_common_audio_context();
    init_common_offline_audio_context();
    init_constant_source_node2();
    init_constant_source_node_renderer();
    init_constant_source_options();
    init_convolver_node();
    init_convolver_options();
    init_delay_node2();
    init_delay_options();
    init_dynamics_compressor_node();
    init_dynamics_compressor_options();
    init_event_target();
    init_gain_node2();
    init_gain_options();
    init_iir_filter_node();
    init_iir_filter_options();
    init_media_element_audio_source_node();
    init_media_element_audio_source_options();
    init_media_stream_audio_destination_node();
    init_media_stream_audio_source_node();
    init_media_stream_audio_source_options();
    init_media_stream_track_audio_source_node();
    init_media_stream_track_audio_source_options();
    init_minimal_audio_context();
    init_minimal_base_audio_context();
    init_minimal_base_audio_context_event_map();
    init_minimal_offline_audio_context();
    init_native_audio_node_faker2();
    init_native_audio_worklet_node_faker();
    init_native_constant_source_node_faker();
    init_native_convolver_node_faker();
    init_native_iir_filter_node_faker();
    init_native_panner_node_faker();
    init_native_stereo_panner_node_faker();
    init_native_wave_shaper_node_faker();
    init_offline_audio_completion_event();
    init_offline_audio_context();
    init_offline_audio_context_constructor2();
    init_offline_audio_context_options();
    init_oscillator_node2();
    init_oscillator_node_renderer();
    init_oscillator_options();
    init_panner_node();
    init_panner_options();
    init_periodic_wave();
    init_periodic_wave_constraints();
    init_periodic_wave_options();
    init_read_only_map2();
    init_stereo_panner_node2();
    init_stereo_panner_options();
    init_wave_shaper_node();
    init_wave_shaper_options();
    init_worklet_options();
  }
});

// node_modules/standardized-audio-context/build/es2019/types/abort-error-factory.js
var init_abort_error_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/abort-error-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/active-audio-worklet-node-inputs-store.js
var init_active_audio_worklet_node_inputs_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/active-audio-worklet-node-inputs-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/active-input-connection.js
var init_active_input_connection = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/active-input-connection.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-active-input-connection-to-audio-node-factory.js
var init_add_active_input_connection_to_audio_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-active-input-connection-to-audio-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-active-input-connection-to-audio-node-function.js
var init_add_active_input_connection_to_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-active-input-connection-to-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-audio-node-connections-factory.js
var init_add_audio_node_connections_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-audio-node-connections-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-audio-node-connections-function.js
var init_add_audio_node_connections_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-audio-node-connections-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-audio-param-connections-factory.js
var init_add_audio_param_connections_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-audio-param-connections-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-audio-param-connections-function.js
var init_add_audio_param_connections_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-audio-param-connections-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-audio-worklet-module-factory.js
var init_add_audio_worklet_module_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-audio-worklet-module-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-audio-worklet-module-function.js
var init_add_audio_worklet_module_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-audio-worklet-module-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-connection-to-audio-node-factory.js
var init_add_connection_to_audio_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-connection-to-audio-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-connection-to-audio-node-function.js
var init_add_connection_to_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-connection-to-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-passive-input-connection-to-audio-node-factory.js
var init_add_passive_input_connection_to_audio_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-passive-input-connection-to-audio-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-passive-input-connection-to-audio-node-function.js
var init_add_passive_input_connection_to_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-passive-input-connection-to-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-silent-connection-factory.js
var init_add_silent_connection_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-silent-connection-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-silent-connection-function.js
var init_add_silent_connection_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-silent-connection-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-unrendered-audio-worklet-node-factory.js
var init_add_unrendered_audio_worklet_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-unrendered-audio-worklet-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/add-unrendered-audio-worklet-node-function.js
var init_add_unrendered_audio_worklet_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/add-unrendered-audio-worklet-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/analyser-node-constructor.js
var init_analyser_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/analyser-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/analyser-node-constructor-factory.js
var init_analyser_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/analyser-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/analyser-node-renderer-factory.js
var init_analyser_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/analyser-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/analyser-node-renderer-factory-factory.js
var init_analyser_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/analyser-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/any-audio-buffer.js
var init_any_audio_buffer = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/any-audio-buffer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/any-context.js
var init_any_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/any-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-buffer-constructor.js
var init_audio_buffer_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-buffer-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-buffer-constructor-factory.js
var init_audio_buffer_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-buffer-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-constructor.js
var init_audio_buffer_source_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-constructor-factory.js
var init_audio_buffer_source_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer.js
var init_audio_buffer_source_node_renderer2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer-factory.js
var init_audio_buffer_source_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer-factory-factory.js
var init_audio_buffer_source_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-buffer-source-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-buffer-store.js
var init_audio_buffer_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-buffer-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-context-constructor.js
var init_audio_context_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-context-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-context-constructor-factory.js
var init_audio_context_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-context-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-context-latency-category.js
var init_audio_context_latency_category = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-context-latency-category.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-context-state.js
var init_audio_context_state = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-context-state.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-constructor.js
var init_audio_destination_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-constructor-factory.js
var init_audio_destination_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-renderer-factory.js
var init_audio_destination_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-destination-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-listener-factory.js
var init_audio_listener_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-listener-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-listener-factory-factory.js
var init_audio_listener_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-listener-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-node-connections.js
var init_audio_node_connections = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-node-connections.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-node-connections-store.js
var init_audio_node_connections_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-node-connections-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-node-constructor.js
var init_audio_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-node-constructor-factory.js
var init_audio_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-node-output-connection.js
var init_audio_node_output_connection2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-node-output-connection.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-node-renderer.js
var init_audio_node_renderer2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-node-renderer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-node-store.js
var init_audio_node_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-node-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-node-tail-time-store.js
var init_audio_node_tail_time_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-node-tail-time-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-param-audio-node-store.js
var init_audio_param_audio_node_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-param-audio-node-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-param-connections.js
var init_audio_param_connections = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-param-connections.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-param-connections-store.js
var init_audio_param_connections_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-param-connections-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-param-factory.js
var init_audio_param_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-param-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-param-factory-factory.js
var init_audio_param_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-param-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-param-map.js
var init_audio_param_map = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-param-map.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-param-output-connection.js
var init_audio_param_output_connection = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-param-output-connection.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-param-renderer-factory.js
var init_audio_param_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-param-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-param-store.js
var init_audio_param_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-param-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-constructor.js
var init_audio_worklet_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-constructor-factory.js
var init_audio_worklet_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-renderer-factory.js
var init_audio_worklet_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-renderer-factory-factory.js
var init_audio_worklet_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/audio-worklet-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/backup-offline-audio-context-store.js
var init_backup_offline_audio_context_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/backup-offline-audio-context-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/base-audio-context-constructor.js
var init_base_audio_context_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/base-audio-context-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/base-audio-context-constructor-factory.js
var init_base_audio_context_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/base-audio-context-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-constructor.js
var init_biquad_filter_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-constructor-factory.js
var init_biquad_filter_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-renderer-factory.js
var init_biquad_filter_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-renderer-factory-factory.js
var init_biquad_filter_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/biquad-filter-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/biquad-filter-type.js
var init_biquad_filter_type = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/biquad-filter-type.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/channel-count-mode.js
var init_channel_count_mode = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/channel-count-mode.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/channel-interpretation.js
var init_channel_interpretation = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/channel-interpretation.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-constructor.js
var init_channel_merger_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-constructor-factory.js
var init_channel_merger_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-renderer-factory.js
var init_channel_merger_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-renderer-factory-factory.js
var init_channel_merger_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/channel-merger-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-constructor.js
var init_channel_splitter_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-constructor-factory.js
var init_channel_splitter_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-renderer-factory.js
var init_channel_splitter_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-renderer-factory-factory.js
var init_channel_splitter_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/channel-splitter-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/cache-test-result-factory.js
var init_cache_test_result_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/cache-test-result-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/cache-test-result-function.js
var init_cache_test_result_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/cache-test-result-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/connect-audio-param-factory.js
var init_connect_audio_param_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/connect-audio-param-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/connect-audio-param-function.js
var init_connect_audio_param_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/connect-audio-param-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/connect-multiple-outputs-factory.js
var init_connect_multiple_outputs_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/connect-multiple-outputs-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/connect-multiple-outputs-function.js
var init_connect_multiple_outputs_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/connect-multiple-outputs-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/connect-native-audio-node-to-native-audio-node-function.js
var init_connect_native_audio_node_to_native_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/connect-native-audio-node-to-native-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/connected-native-audio-buffer-source-node-factory.js
var init_connected_native_audio_buffer_source_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/connected-native-audio-buffer-source-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/connected-native-audio-buffer-source-node-factory-factory.js
var init_connected_native_audio_buffer_source_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/connected-native-audio-buffer-source-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/constant-source-node-constructor.js
var init_constant_source_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/constant-source-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/constant-source-node-constructor-factory.js
var init_constant_source_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/constant-source-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer.js
var init_constant_source_node_renderer2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer-factory.js
var init_constant_source_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer-factory-factory.js
var init_constant_source_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/constant-source-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/constructor.js
var init_constructor = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/context.js
var init_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/context-store.js
var init_context_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/context-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/convert-number-to-unsigned-long-factory.js
var init_convert_number_to_unsigned_long_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/convert-number-to-unsigned-long-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/convert-number-to-unsigned-long-function.js
var init_convert_number_to_unsigned_long_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/convert-number-to-unsigned-long-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/convolver-node-constructor.js
var init_convolver_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/convolver-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/convolver-node-constructor-factory.js
var init_convolver_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/convolver-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/convolver-node-renderer-factory.js
var init_convolver_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/convolver-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/convolver-node-renderer-factory-factory.js
var init_convolver_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/convolver-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/create-native-offline-audio-context-factory.js
var init_create_native_offline_audio_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/create-native-offline-audio-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/create-native-offline-audio-context-function.js
var init_create_native_offline_audio_context_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/create-native-offline-audio-context-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/cycle-counters.js
var init_cycle_counters = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/cycle-counters.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/data-clone-error-factory.js
var init_data_clone_error_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/data-clone-error-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/decode-audio-data-factory.js
var init_decode_audio_data_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/decode-audio-data-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/decode-audio-data-function.js
var init_decode_audio_data_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/decode-audio-data-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/decode-error-callback.js
var init_decode_error_callback = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/decode-error-callback.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/decode-success-callback.js
var init_decode_success_callback = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/decode-success-callback.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/decrement-cycle-counter-factory.js
var init_decrement_cycle_counter_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/decrement-cycle-counter-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/decrement-cycle-counter-function.js
var init_decrement_cycle_counter_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/decrement-cycle-counter-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/delay-node-constructor.js
var init_delay_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/delay-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/delay-node-constructor-factory.js
var init_delay_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/delay-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/delay-node-renderer-factory.js
var init_delay_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/delay-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/delay-node-renderer-factory-factory.js
var init_delay_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/delay-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/delete-active-input-connection-to-audio-node-factory.js
var init_delete_active_input_connection_to_audio_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/delete-active-input-connection-to-audio-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/delete-active-input-connection-to-audio-node-function.js
var init_delete_active_input_connection_to_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/delete-active-input-connection-to-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/delete-unrendered-audio-worklet-node-factory.js
var init_delete_unrendered_audio_worklet_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/delete-unrendered-audio-worklet-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/delete-unrendered-audio-worklet-node-function.js
var init_delete_unrendered_audio_worklet_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/delete-unrendered-audio-worklet-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/detect-cycles-factory.js
var init_detect_cycles_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/detect-cycles-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/detect-cycles-function.js
var init_detect_cycles_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/detect-cycles-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/disconnect-multiple-outputs-factory.js
var init_disconnect_multiple_outputs_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/disconnect-multiple-outputs-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/disconnect-multiple-outputs-function.js
var init_disconnect_multiple_outputs_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/disconnect-multiple-outputs-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/disconnect-native-audio-node-from-native-audio-node-function.js
var init_disconnect_native_audio_node_from_native_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/disconnect-native-audio-node-from-native-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/distance-model-type.js
var init_distance_model_type = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/distance-model-type.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-constructor.js
var init_dynamics_compressor_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-constructor-factory.js
var init_dynamics_compressor_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-renderer-factory.js
var init_dynamics_compressor_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-renderer-factory-factory.js
var init_dynamics_compressor_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/dynamics-compressor-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/encoding-error-factory.js
var init_encoding_error_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/encoding-error-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/error-event-handler.js
var init_error_event_handler = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/error-event-handler.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/evaluate-audio-worklet-global-scope-function.js
var init_evaluate_audio_worklet_global_scope_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/evaluate-audio-worklet-global-scope-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/evaluate-source-factory.js
var init_evaluate_source_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/evaluate-source-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/evaluate-source-function.js
var init_evaluate_source_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/evaluate-source-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/event-handler.js
var init_event_handler2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/event-handler.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/event-target-constructor.js
var init_event_target_constructor3 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/event-target-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/event-target-constructor-factory.js
var init_event_target_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/event-target-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/expose-current-frame-and-current-time-factory.js
var init_expose_current_frame_and_current_time_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/expose-current-frame-and-current-time-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/expose-current-frame-and-current-time-function.js
var init_expose_current_frame_and_current_time_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/expose-current-frame-and-current-time-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/fetch-source-factory.js
var init_fetch_source_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/fetch-source-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/fetch-source-function.js
var init_fetch_source_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/fetch-source-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/gain-node-constructor.js
var init_gain_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/gain-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/gain-node-constructor-factory.js
var init_gain_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/gain-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/gain-node-renderer-factory.js
var init_gain_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/gain-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/gain-node-renderer-factory-factory.js
var init_gain_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/gain-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-active-audio-worklet-node-inputs-factory.js
var init_get_active_audio_worklet_node_inputs_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-active-audio-worklet-node-inputs-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-active-audio-worklet-node-inputs-function.js
var init_get_active_audio_worklet_node_inputs_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-active-audio-worklet-node-inputs-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-audio-node-connections-function.js
var init_get_audio_node_connections_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-audio-node-connections-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-audio-node-renderer-factory.js
var init_get_audio_node_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-audio-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-audio-node-renderer-function.js
var init_get_audio_node_renderer_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-audio-node-renderer-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-audio-node-tail-time-factory.js
var init_get_audio_node_tail_time_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-audio-node-tail-time-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-audio-node-tail-time-function.js
var init_get_audio_node_tail_time_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-audio-node-tail-time-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-audio-param-connections-function.js
var init_get_audio_param_connections_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-audio-param-connections-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-audio-param-renderer-factory.js
var init_get_audio_param_renderer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-audio-param-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-audio-param-renderer-function.js
var init_get_audio_param_renderer_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-audio-param-renderer-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-backup-offline-audio-context-factory.js
var init_get_backup_offline_audio_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-backup-offline-audio-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-backup-offline-audio-context-function.js
var init_get_backup_offline_audio_context_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-backup-offline-audio-context-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-event-listeners-of-audio-node-function.js
var init_get_event_listeners_of_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-event-listeners-of-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-first-sample-function.js
var init_get_first_sample_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-first-sample-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-native-audio-node-function.js
var init_get_native_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-native-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-native-audio-param-function.js
var init_get_native_audio_param_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-native-audio-param-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-native-context-factory.js
var init_get_native_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-native-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-native-context-function.js
var init_get_native_context_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-native-context-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-or-create-backup-offline-audio-context-factory.js
var init_get_or_create_backup_offline_audio_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-or-create-backup-offline-audio-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-or-create-backup-offline-audio-context-function.js
var init_get_or_create_backup_offline_audio_context_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-or-create-backup-offline-audio-context-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-unrendered-audio-worklet-nodes-factory.js
var init_get_unrendered_audio_worklet_nodes_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-unrendered-audio-worklet-nodes-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-unrendered-audio-worklet-nodes-function.js
var init_get_unrendered_audio_worklet_nodes_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-unrendered-audio-worklet-nodes-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/get-value-for-key-function.js
var init_get_value_for_key_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/get-value-for-key-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-constructor.js
var init_iir_filter_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-constructor-factory.js
var init_iir_filter_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-renderer-factory.js
var init_iir_filter_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-renderer-factory-factory.js
var init_iir_filter_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/iir-filter-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-factory.js
var init_increment_cycle_counter_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-factory-factory.js
var init_increment_cycle_counter_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-function.js
var init_increment_cycle_counter_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/increment-cycle-counter-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/index-size-error-factory.js
var init_index_size_error_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/index-size-error-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/insert-element-in-set-function.js
var init_insert_element_in_set_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/insert-element-in-set-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/internal-state-event-listener.js
var init_internal_state_event_listener = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/internal-state-event-listener.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/invalid-access-error-factory.js
var init_invalid_access_error_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/invalid-access-error-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/invalid-state-error-factory.js
var init_invalid_state_error_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/invalid-state-error-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-active-audio-node-function.js
var init_is_active_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-active-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-any-audio-context-factory.js
var init_is_any_audio_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-any-audio-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-any-audio-context-function.js
var init_is_any_audio_context_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-any-audio-context-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-any-audio-node-factory.js
var init_is_any_audio_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-any-audio-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-any-audio-node-function.js
var init_is_any_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-any-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-any-audio-param-factory.js
var init_is_any_audio_param_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-any-audio-param-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-any-audio-param-function.js
var init_is_any_audio_param_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-any-audio-param-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-any-offline-audio-context-factory.js
var init_is_any_offline_audio_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-any-offline-audio-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-any-offline-audio-context-function.js
var init_is_any_offline_audio_context_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-any-offline-audio-context-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-dc-curve-function.js
var init_is_dc_curve_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-dc-curve-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-native-audio-context-factory.js
var init_is_native_audio_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-native-audio-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-native-audio-context-function.js
var init_is_native_audio_context_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-native-audio-context-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-native-audio-node-factory.js
var init_is_native_audio_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-native-audio-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-native-audio-node-function.js
var init_is_native_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-native-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-native-audio-param-factory.js
var init_is_native_audio_param_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-native-audio-param-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-native-audio-param-function.js
var init_is_native_audio_param_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-native-audio-param-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-native-context-factory.js
var init_is_native_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-native-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-native-context-function.js
var init_is_native_context_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-native-context-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-native-offline-audio-context-factory.js
var init_is_native_offline_audio_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-native-offline-audio-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-native-offline-audio-context-function.js
var init_is_native_offline_audio_context_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-native-offline-audio-context-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-part-of-a-cycle-function.js
var init_is_part_of_a_cycle_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-part-of-a-cycle-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-passive-audio-node-function.js
var init_is_passive_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-passive-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-secure-context-factory.js
var init_is_secure_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-secure-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/is-supported-promise-factory.js
var init_is_supported_promise_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/is-supported-promise-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/media-element-audio-source-node-constructor.js
var init_media_element_audio_source_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/media-element-audio-source-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/media-element-audio-source-node-constructor-factory.js
var init_media_element_audio_source_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/media-element-audio-source-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-destination-node-constructor.js
var init_media_stream_audio_destination_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-destination-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-destination-node-constructor-factory.js
var init_media_stream_audio_destination_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-destination-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-source-node-constructor.js
var init_media_stream_audio_source_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-source-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-source-node-constructor-factory.js
var init_media_stream_audio_source_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/media-stream-audio-source-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/media-stream-track-audio-source-node-constructor.js
var init_media_stream_track_audio_source_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/media-stream-track-audio-source-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/media-stream-track-audio-source-node-constructor-factory.js
var init_media_stream_track_audio_source_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/media-stream-track-audio-source-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/minimal-audio-context-constructor.js
var init_minimal_audio_context_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/minimal-audio-context-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/minimal-audio-context-constructor-factory.js
var init_minimal_audio_context_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/minimal-audio-context-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/minimal-base-audio-context-constructor.js
var init_minimal_base_audio_context_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/minimal-base-audio-context-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/minimal-base-audio-context-constructor-factory.js
var init_minimal_base_audio_context_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/minimal-base-audio-context-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/minimal-offline-audio-context-constructor.js
var init_minimal_offline_audio_context_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/minimal-offline-audio-context-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/minimal-offline-audio-context-constructor-factory.js
var init_minimal_offline_audio_context_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/minimal-offline-audio-context-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/monitor-connections-factory.js
var init_monitor_connections_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/monitor-connections-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/monitor-connections-function.js
var init_monitor_connections_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/monitor-connections-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-analyser-node.js
var init_native_analyser_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-analyser-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-analyser-node-factory.js
var init_native_analyser_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-analyser-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-analyser-node-factory-factory.js
var init_native_analyser_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-analyser-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer.js
var init_native_audio_buffer = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-constructor.js
var init_native_audio_buffer_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-constructor-factory.js
var init_native_audio_buffer_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node.js
var init_native_audio_buffer_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node-factory.js
var init_native_audio_buffer_source_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node-factory-factory.js
var init_native_audio_buffer_source_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-buffer-source-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-context.js
var init_native_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-context-constructor.js
var init_native_audio_context_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-context-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-context-constructor-factory.js
var init_native_audio_context_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-context-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node.js
var init_native_audio_destination_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node-factory.js
var init_native_audio_destination_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node-factory-factory.js
var init_native_audio_destination_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-destination-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-listener.js
var init_native_audio_listener = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-listener.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-node.js
var init_native_audio_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-param.js
var init_native_audio_param = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-param.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-param-map.js
var init_native_audio_param_map = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-param-map.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet.js
var init_native_audio_worklet = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node.js
var init_native_audio_worklet_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-constructor.js
var init_native_audio_worklet_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-constructor-factory.js
var init_native_audio_worklet_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-factory.js
var init_native_audio_worklet_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-factory-factory.js
var init_native_audio_worklet_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-faker-factory.js
var init_native_audio_worklet_node_faker_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-faker-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-faker-factory-factory.js
var init_native_audio_worklet_node_faker_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-faker-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-options.js
var init_native_audio_worklet_node_options = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-audio-worklet-node-options.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-biquad-filter-node.js
var init_native_biquad_filter_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-biquad-filter-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-biquad-filter-node-factory.js
var init_native_biquad_filter_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-biquad-filter-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node.js
var init_native_channel_merger_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node-factory.js
var init_native_channel_merger_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node-factory-factory.js
var init_native_channel_merger_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-channel-merger-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-channel-splitter-node.js
var init_native_channel_splitter_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-channel-splitter-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-channel-splitter-node-factory.js
var init_native_channel_splitter_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-channel-splitter-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node.js
var init_native_constant_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-factory.js
var init_native_constant_source_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-factory-factory.js
var init_native_constant_source_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-faker-factory.js
var init_native_constant_source_node_faker_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-faker-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-faker-factory-factory.js
var init_native_constant_source_node_faker_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-constant-source-node-faker-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-context.js
var init_native_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-convolver-node.js
var init_native_convolver_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-convolver-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-convolver-node-factory.js
var init_native_convolver_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-convolver-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-convolver-node-factory-factory.js
var init_native_convolver_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-convolver-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-delay-node-factory.js
var init_native_delay_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-delay-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-delay-node.js
var init_native_delay_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-delay-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node.js
var init_native_dynamics_compressor_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node-factory.js
var init_native_dynamics_compressor_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node-factory-factory.js
var init_native_dynamics_compressor_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-dynamics-compressor-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-event-target.js
var init_native_event_target = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-event-target.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-gain-node.js
var init_native_gain_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-gain-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-gain-node-factory.js
var init_native_gain_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-gain-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node.js
var init_native_iir_filter_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-factory.js
var init_native_iir_filter_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-factory-factory.js
var init_native_iir_filter_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-faker-factory.js
var init_native_iir_filter_node_faker_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-faker-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-faker-factory-factory.js
var init_native_iir_filter_node_faker_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-iir-filter-node-faker-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-media-element-audio-source-node.js
var init_native_media_element_audio_source_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-media-element-audio-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-media-element-audio-source-node-factory.js
var init_native_media_element_audio_source_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-media-element-audio-source-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-destination-node.js
var init_native_media_stream_audio_destination_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-destination-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-destination-node-factory.js
var init_native_media_stream_audio_destination_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-destination-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-source-node.js
var init_native_media_stream_audio_source_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-source-node-factory.js
var init_native_media_stream_audio_source_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-media-stream-audio-source-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node.js
var init_native_media_stream_track_audio_source_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node-factory.js
var init_native_media_stream_track_audio_source_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node-factory-factory.js
var init_native_media_stream_track_audio_source_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-media-stream-track-audio-source-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context.js
var init_native_offline_audio_context = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context-constructor.js
var init_native_offline_audio_context_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context-constructor-factory.js
var init_native_offline_audio_context_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-offline-audio-context-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node.js
var init_native_oscillator_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node-factory.js
var init_native_oscillator_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node-factory-factory.js
var init_native_oscillator_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-oscillator-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-panner-node.js
var init_native_panner_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-panner-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-panner-node-factory.js
var init_native_panner_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-panner-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-panner-node-factory-factory.js
var init_native_panner_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-panner-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-panner-node-faker-factory.js
var init_native_panner_node_faker_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-panner-node-faker-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-panner-node-faker-factory-factory.js
var init_native_panner_node_faker_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-panner-node-faker-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave.js
var init_native_periodic_wave = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave-factory.js
var init_native_periodic_wave_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave-factory-factory.js
var init_native_periodic_wave_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-periodic-wave-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-script-processor-node.js
var init_native_script_processor_node2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-script-processor-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-script-processor-node-factory.js
var init_native_script_processor_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-script-processor-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node.js
var init_native_stereo_panner_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-factory.js
var init_native_stereo_panner_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-factory-factory.js
var init_native_stereo_panner_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-faker-factory.js
var init_native_stereo_panner_node_faker_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-faker-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-faker-factory-factory.js
var init_native_stereo_panner_node_faker_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-stereo-panner-node-faker-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node.js
var init_native_wave_shaper_node = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-factory.js
var init_native_wave_shaper_node_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-factory-factory.js
var init_native_wave_shaper_node_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-faker-factory.js
var init_native_wave_shaper_node_faker_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-faker-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-faker-factory-factory.js
var init_native_wave_shaper_node_faker_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/native-wave-shaper-node-faker-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/not-supported-error-factory.js
var init_not_supported_error_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/not-supported-error-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/offline-audio-context-constructor-factory.js
var init_offline_audio_context_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/offline-audio-context-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/oscillator-node-constructor.js
var init_oscillator_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/oscillator-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/oscillator-node-constructor-factory.js
var init_oscillator_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/oscillator-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer.js
var init_oscillator_node_renderer2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer-factory.js
var init_oscillator_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer-factory-factory.js
var init_oscillator_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/oscillator-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/oscillator-type.js
var init_oscillator_type = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/oscillator-type.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/output-connection.js
var init_output_connection = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/output-connection.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/over-sample-type.js
var init_over_sample_type = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/over-sample-type.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/overwrite-accessors-function.js
var init_overwrite_accessors_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/overwrite-accessors-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/panner-node-constructor.js
var init_panner_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/panner-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/panner-node-constructor-factory.js
var init_panner_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/panner-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/panner-node-renderer-factory.js
var init_panner_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/panner-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/panner-node-renderer-factory-factory.js
var init_panner_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/panner-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/panning-model-type.js
var init_panning_model_type = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/panning-model-type.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/passive-audio-node-input-connection.js
var init_passive_audio_node_input_connection = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/passive-audio-node-input-connection.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/passive-audio-param-input-connection.js
var init_passive_audio_param_input_connection = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/passive-audio-param-input-connection.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/periodic-wave-constructor.js
var init_periodic_wave_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/periodic-wave-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/periodic-wave-constructor-factory.js
var init_periodic_wave_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/periodic-wave-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/pick-element-from-set-function.js
var init_pick_element_from_set_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/pick-element-from-set-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/render-automation-factory.js
var init_render_automation_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/render-automation-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/render-automation-function.js
var init_render_automation_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/render-automation-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-node-factory.js
var init_render_inputs_of_audio_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-node-function.js
var init_render_inputs_of_audio_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-param-factory.js
var init_render_inputs_of_audio_param_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-param-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-param-function.js
var init_render_inputs_of_audio_param_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/render-inputs-of-audio-param-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/render-native-offline-audio-context-factory.js
var init_render_native_offline_audio_context_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/render-native-offline-audio-context-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/render-native-offline-audio-context-function.js
var init_render_native_offline_audio_context_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/render-native-offline-audio-context-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/sanitize-audio-worklet-node-options-function.js
var init_sanitize_audio_worklet_node_options_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/sanitize-audio-worklet-node-options-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/sanitize-channel-splitter-options-function.js
var init_sanitize_channel_splitter_options_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/sanitize-channel-splitter-options-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/sanitize-periodic-wave-options-function.js
var init_sanitize_periodic_wave_options_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/sanitize-periodic-wave-options-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/set-active-audio-worklet-node-inputs-factory.js
var init_set_active_audio_worklet_node_inputs_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/set-active-audio-worklet-node-inputs-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/set-active-audio-worklet-node-inputs-function.js
var init_set_active_audio_worklet_node_inputs_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/set-active-audio-worklet-node-inputs-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/set-audio-node-tail-time-factory.js
var init_set_audio_node_tail_time_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/set-audio-node-tail-time-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/set-audio-node-tail-time-function.js
var init_set_audio_node_tail_time_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/set-audio-node-tail-time-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/set-value-at-time-until-possible-function.js
var init_set_value_at_time_until_possible_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/set-value-at-time-until-possible-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/start-rendering-factory.js
var init_start_rendering_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/start-rendering-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/start-rendering-function.js
var init_start_rendering_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/start-rendering-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-constructor.js
var init_stereo_panner_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-constructor-factory.js
var init_stereo_panner_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-renderer-factory-factory.js
var init_stereo_panner_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-renderer-factory.js
var init_stereo_panner_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/stereo-panner-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-audio-buffer-copy-channel-methods-subarray-support-factory.js
var init_test_audio_buffer_copy_channel_methods_subarray_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-audio-buffer-copy-channel-methods-subarray-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-audio-buffer-constructor-support-factory.js
var init_test_audio_buffer_constructor_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-audio-buffer-constructor-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-audio-context-close-method-support-factory.js
var init_test_audio_context_close_method_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-audio-context-close-method-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-audio-context-decode-audio-data-method-type-error-support-factory.js
var init_test_audio_context_decode_audio_data_method_type_error_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-audio-context-decode-audio-data-method-type-error-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-audio-context-options-support-factory.js
var init_test_audio_context_options_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-audio-context-options-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-audio-node-connect-method-support-factory.js
var init_test_audio_node_connect_method_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-audio-node-connect-method-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-node-options-clonability-function.js
var init_test_audio_worklet_node_options_clonability_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-node-options-clonability-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-processor-no-outputs-support-factory.js
var init_test_audio_worklet_processor_no_outputs_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-processor-no-outputs-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-processor-post-message-support-factory.js
var init_test_audio_worklet_processor_post_message_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-audio-worklet-processor-post-message-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-channel-merger-node-channel-count-support-factory.js
var init_test_channel_merger_node_channel_count_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-channel-merger-node-channel-count-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-constant-source-node-accurate-scheduling-support-factory.js
var init_test_constant_source_node_accurate_scheduling_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-constant-source-node-accurate-scheduling-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-convolver-node-buffer-reassignability-support-factory.js
var init_test_convolver_node_buffer_reassignability_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-convolver-node-buffer-reassignability-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-convolver-node-channel-count-support-factory.js
var init_test_convolver_node_channel_count_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-convolver-node-channel-count-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-is-secure-context-support-factory.js
var init_test_is_secure_context_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-is-secure-context-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js
var init_test_media_stream_audio_source_node_media_stream_without_audio_track_support2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-media-stream-audio-source-node-media-stream-without-audio-track-support.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-offline-audio-context-current-time-support-factory.js
var init_test_offline_audio_context_current_time_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-offline-audio-context-current-time-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/test-stereo-panner-node-default-value-support-factory.js
var init_test_stereo_panner_node_default_value_support_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/test-stereo-panner-node-default-value-support-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/unknown-error-factory.js
var init_unknown_error_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/unknown-error-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/unrendered-audio-worklet-node-store.js
var init_unrendered_audio_worklet_node_store = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/unrendered-audio-worklet-node-store.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/unrendered-audio-worklet-nodes.js
var init_unrendered_audio_worklet_nodes = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/unrendered-audio-worklet-nodes.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-constructor.js
var init_wave_shaper_node_constructor2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-constructor.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-constructor-factory.js
var init_wave_shaper_node_constructor_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-constructor-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-renderer-factory-factory.js
var init_wave_shaper_node_renderer_factory_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-renderer-factory-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-renderer-factory.js
var init_wave_shaper_node_renderer_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wave-shaper-node-renderer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/window.js
var init_window4 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/window.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/window-factory.js
var init_window_factory2 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/window-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-factory.js
var init_wrap_audio_buffer_copy_channel_methods_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-function.js
var init_wrap_audio_buffer_copy_channel_methods_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-out-of-bounds-factory.js
var init_wrap_audio_buffer_copy_channel_methods_out_of_bounds_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-out-of-bounds-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-out-of-bounds-function.js
var init_wrap_audio_buffer_copy_channel_methods_out_of_bounds_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-copy-channel-methods-out-of-bounds-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-start-method-offset-clamping-function.js
var init_wrap_audio_buffer_source_node_start_method_offset_clamping_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-start-method-offset-clamping-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-stop-method-nullified-buffer-factory.js
var init_wrap_audio_buffer_source_node_stop_method_nullified_buffer_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-stop-method-nullified-buffer-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-stop-method-nullified-buffer-function.js
var init_wrap_audio_buffer_source_node_stop_method_nullified_buffer_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-audio-buffer-source-node-stop-method-nullified-buffer-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-audio-scheduled-source-node-stop-method-consecutive-calls-function.js
var init_wrap_audio_scheduled_source_node_stop_method_consecutive_calls_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-audio-scheduled-source-node-stop-method-consecutive-calls-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-channel-merger-node-factory.js
var init_wrap_channel_merger_node_factory = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-channel-merger-node-factory.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-channel-merger-node-function.js
var init_wrap_channel_merger_node_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-channel-merger-node-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/wrap-event-listener-function.js
var init_wrap_event_listener_function = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/wrap-event-listener-function.js"() {
  }
});

// node_modules/standardized-audio-context/build/es2019/types/index.js
var init_types10 = __esm({
  "node_modules/standardized-audio-context/build/es2019/types/index.js"() {
    init_abort_error_factory();
    init_active_audio_worklet_node_inputs_store();
    init_active_input_connection();
    init_add_active_input_connection_to_audio_node_factory();
    init_add_active_input_connection_to_audio_node_function();
    init_add_audio_node_connections_factory();
    init_add_audio_node_connections_function();
    init_add_audio_param_connections_factory();
    init_add_audio_param_connections_function();
    init_add_audio_worklet_module_factory();
    init_add_audio_worklet_module_function();
    init_add_connection_to_audio_node_factory();
    init_add_connection_to_audio_node_function();
    init_add_passive_input_connection_to_audio_node_factory();
    init_add_passive_input_connection_to_audio_node_function();
    init_add_silent_connection_factory();
    init_add_silent_connection_function();
    init_add_unrendered_audio_worklet_node_factory();
    init_add_unrendered_audio_worklet_node_function();
    init_analyser_node_constructor2();
    init_analyser_node_constructor_factory();
    init_analyser_node_renderer_factory2();
    init_analyser_node_renderer_factory_factory();
    init_any_audio_buffer();
    init_any_context();
    init_audio_buffer_constructor2();
    init_audio_buffer_constructor_factory();
    init_audio_buffer_source_node_constructor2();
    init_audio_buffer_source_node_constructor_factory();
    init_audio_buffer_source_node_renderer2();
    init_audio_buffer_source_node_renderer_factory2();
    init_audio_buffer_source_node_renderer_factory_factory();
    init_audio_buffer_store();
    init_audio_context_constructor2();
    init_audio_context_constructor_factory();
    init_audio_context_latency_category();
    init_audio_context_state();
    init_audio_destination_node_constructor2();
    init_audio_destination_node_constructor_factory();
    init_audio_destination_node_renderer_factory2();
    init_audio_listener_factory2();
    init_audio_listener_factory_factory();
    init_audio_node_connections();
    init_audio_node_connections_store();
    init_audio_node_constructor2();
    init_audio_node_constructor_factory();
    init_audio_node_output_connection2();
    init_audio_node_renderer2();
    init_audio_node_store();
    init_audio_node_tail_time_store();
    init_audio_param_audio_node_store();
    init_audio_param_connections();
    init_audio_param_connections_store();
    init_audio_param_factory2();
    init_audio_param_factory_factory();
    init_audio_param_map();
    init_audio_param_output_connection();
    init_audio_param_renderer_factory();
    init_audio_param_store();
    init_audio_worklet_node_constructor2();
    init_audio_worklet_node_constructor_factory();
    init_audio_worklet_node_renderer_factory2();
    init_audio_worklet_node_renderer_factory_factory();
    init_backup_offline_audio_context_store();
    init_base_audio_context_constructor2();
    init_base_audio_context_constructor_factory();
    init_biquad_filter_node_constructor2();
    init_biquad_filter_node_constructor_factory();
    init_biquad_filter_node_renderer_factory2();
    init_biquad_filter_node_renderer_factory_factory();
    init_biquad_filter_type();
    init_channel_count_mode();
    init_channel_interpretation();
    init_channel_merger_node_constructor2();
    init_channel_merger_node_constructor_factory();
    init_channel_merger_node_renderer_factory2();
    init_channel_merger_node_renderer_factory_factory();
    init_channel_splitter_node_constructor2();
    init_channel_splitter_node_constructor_factory();
    init_channel_splitter_node_renderer_factory2();
    init_channel_splitter_node_renderer_factory_factory();
    init_cache_test_result_factory();
    init_cache_test_result_function();
    init_connect_audio_param_factory();
    init_connect_audio_param_function();
    init_connect_multiple_outputs_factory();
    init_connect_multiple_outputs_function();
    init_connect_native_audio_node_to_native_audio_node_function();
    init_connected_native_audio_buffer_source_node_factory2();
    init_connected_native_audio_buffer_source_node_factory_factory();
    init_constant_source_node_constructor2();
    init_constant_source_node_constructor_factory();
    init_constant_source_node_renderer2();
    init_constant_source_node_renderer_factory2();
    init_constant_source_node_renderer_factory_factory();
    init_constructor();
    init_context();
    init_context_store();
    init_convert_number_to_unsigned_long_factory();
    init_convert_number_to_unsigned_long_function();
    init_convolver_node_constructor2();
    init_convolver_node_constructor_factory();
    init_convolver_node_renderer_factory2();
    init_convolver_node_renderer_factory_factory();
    init_create_native_offline_audio_context_factory();
    init_create_native_offline_audio_context_function();
    init_cycle_counters();
    init_data_clone_error_factory();
    init_decode_audio_data_factory();
    init_decode_audio_data_function();
    init_decode_error_callback();
    init_decode_success_callback();
    init_decrement_cycle_counter_factory();
    init_decrement_cycle_counter_function();
    init_delay_node_constructor2();
    init_delay_node_constructor_factory();
    init_delay_node_renderer_factory2();
    init_delay_node_renderer_factory_factory();
    init_delete_active_input_connection_to_audio_node_factory();
    init_delete_active_input_connection_to_audio_node_function();
    init_delete_unrendered_audio_worklet_node_factory();
    init_delete_unrendered_audio_worklet_node_function();
    init_detect_cycles_factory();
    init_detect_cycles_function();
    init_disconnect_multiple_outputs_factory();
    init_disconnect_multiple_outputs_function();
    init_disconnect_native_audio_node_from_native_audio_node_function();
    init_distance_model_type();
    init_dynamics_compressor_node_constructor2();
    init_dynamics_compressor_node_constructor_factory();
    init_dynamics_compressor_node_renderer_factory2();
    init_dynamics_compressor_node_renderer_factory_factory();
    init_encoding_error_factory();
    init_error_event_handler();
    init_evaluate_audio_worklet_global_scope_function();
    init_evaluate_source_factory();
    init_evaluate_source_function();
    init_event_handler2();
    init_event_target_constructor3();
    init_event_target_constructor_factory();
    init_expose_current_frame_and_current_time_factory();
    init_expose_current_frame_and_current_time_function();
    init_fetch_source_factory();
    init_fetch_source_function();
    init_gain_node_constructor2();
    init_gain_node_constructor_factory();
    init_gain_node_renderer_factory2();
    init_gain_node_renderer_factory_factory();
    init_get_active_audio_worklet_node_inputs_factory();
    init_get_active_audio_worklet_node_inputs_function();
    init_get_audio_node_connections_function();
    init_get_audio_node_renderer_factory();
    init_get_audio_node_renderer_function();
    init_get_audio_node_tail_time_factory();
    init_get_audio_node_tail_time_function();
    init_get_audio_param_connections_function();
    init_get_audio_param_renderer_factory();
    init_get_audio_param_renderer_function();
    init_get_backup_offline_audio_context_factory();
    init_get_backup_offline_audio_context_function();
    init_get_event_listeners_of_audio_node_function();
    init_get_first_sample_function();
    init_get_native_audio_node_function();
    init_get_native_audio_param_function();
    init_get_native_context_factory();
    init_get_native_context_function();
    init_get_or_create_backup_offline_audio_context_factory();
    init_get_or_create_backup_offline_audio_context_function();
    init_get_unrendered_audio_worklet_nodes_factory();
    init_get_unrendered_audio_worklet_nodes_function();
    init_get_value_for_key_function();
    init_iir_filter_node_constructor2();
    init_iir_filter_node_constructor_factory();
    init_iir_filter_node_renderer_factory2();
    init_iir_filter_node_renderer_factory_factory();
    init_increment_cycle_counter_factory2();
    init_increment_cycle_counter_factory_factory();
    init_increment_cycle_counter_function();
    init_index_size_error_factory();
    init_insert_element_in_set_function();
    init_internal_state_event_listener();
    init_invalid_access_error_factory();
    init_invalid_state_error_factory();
    init_is_active_audio_node_function();
    init_is_any_audio_context_factory();
    init_is_any_audio_context_function();
    init_is_any_audio_node_factory();
    init_is_any_audio_node_function();
    init_is_any_audio_param_factory();
    init_is_any_audio_param_function();
    init_is_any_offline_audio_context_factory();
    init_is_any_offline_audio_context_function();
    init_is_dc_curve_function();
    init_is_native_audio_context_factory();
    init_is_native_audio_context_function();
    init_is_native_audio_node_factory();
    init_is_native_audio_node_function();
    init_is_native_audio_param_factory();
    init_is_native_audio_param_function();
    init_is_native_context_factory();
    init_is_native_context_function();
    init_is_native_offline_audio_context_factory();
    init_is_native_offline_audio_context_function();
    init_is_part_of_a_cycle_function();
    init_is_passive_audio_node_function();
    init_is_secure_context_factory();
    init_is_supported_promise_factory();
    init_media_element_audio_source_node_constructor2();
    init_media_element_audio_source_node_constructor_factory();
    init_media_stream_audio_destination_node_constructor2();
    init_media_stream_audio_destination_node_constructor_factory();
    init_media_stream_audio_source_node_constructor2();
    init_media_stream_audio_source_node_constructor_factory();
    init_media_stream_track_audio_source_node_constructor2();
    init_media_stream_track_audio_source_node_constructor_factory();
    init_minimal_audio_context_constructor2();
    init_minimal_audio_context_constructor_factory();
    init_minimal_base_audio_context_constructor2();
    init_minimal_base_audio_context_constructor_factory();
    init_minimal_offline_audio_context_constructor2();
    init_minimal_offline_audio_context_constructor_factory();
    init_monitor_connections_factory();
    init_monitor_connections_function();
    init_native_analyser_node();
    init_native_analyser_node_factory2();
    init_native_analyser_node_factory_factory();
    init_native_audio_buffer();
    init_native_audio_buffer_constructor2();
    init_native_audio_buffer_constructor_factory();
    init_native_audio_buffer_source_node();
    init_native_audio_buffer_source_node_factory2();
    init_native_audio_buffer_source_node_factory_factory();
    init_native_audio_context();
    init_native_audio_context_constructor2();
    init_native_audio_context_constructor_factory();
    init_native_audio_destination_node2();
    init_native_audio_destination_node_factory();
    init_native_audio_destination_node_factory_factory();
    init_native_audio_listener();
    init_native_audio_node2();
    init_native_audio_param();
    init_native_audio_param_map();
    init_native_audio_worklet();
    init_native_audio_worklet_node();
    init_native_audio_worklet_node_constructor2();
    init_native_audio_worklet_node_constructor_factory();
    init_native_audio_worklet_node_factory2();
    init_native_audio_worklet_node_factory_factory();
    init_native_audio_worklet_node_faker_factory2();
    init_native_audio_worklet_node_faker_factory_factory();
    init_native_audio_worklet_node_options();
    init_native_biquad_filter_node2();
    init_native_biquad_filter_node_factory();
    init_native_channel_merger_node();
    init_native_channel_merger_node_factory2();
    init_native_channel_merger_node_factory_factory();
    init_native_channel_splitter_node2();
    init_native_channel_splitter_node_factory();
    init_native_constant_source_node();
    init_native_constant_source_node_factory2();
    init_native_constant_source_node_factory_factory();
    init_native_constant_source_node_faker_factory2();
    init_native_constant_source_node_faker_factory_factory();
    init_native_context();
    init_native_convolver_node();
    init_native_convolver_node_factory2();
    init_native_convolver_node_factory_factory();
    init_native_delay_node_factory();
    init_native_delay_node2();
    init_native_dynamics_compressor_node();
    init_native_dynamics_compressor_node_factory2();
    init_native_dynamics_compressor_node_factory_factory();
    init_native_event_target();
    init_native_gain_node2();
    init_native_gain_node_factory();
    init_native_iir_filter_node();
    init_native_iir_filter_node_factory2();
    init_native_iir_filter_node_factory_factory();
    init_native_iir_filter_node_faker_factory2();
    init_native_iir_filter_node_faker_factory_factory();
    init_native_media_element_audio_source_node2();
    init_native_media_element_audio_source_node_factory();
    init_native_media_stream_audio_destination_node2();
    init_native_media_stream_audio_destination_node_factory();
    init_native_media_stream_audio_source_node2();
    init_native_media_stream_audio_source_node_factory();
    init_native_media_stream_track_audio_source_node();
    init_native_media_stream_track_audio_source_node_factory2();
    init_native_media_stream_track_audio_source_node_factory_factory();
    init_native_offline_audio_context();
    init_native_offline_audio_context_constructor2();
    init_native_offline_audio_context_constructor_factory();
    init_native_oscillator_node();
    init_native_oscillator_node_factory2();
    init_native_oscillator_node_factory_factory();
    init_native_panner_node();
    init_native_panner_node_factory2();
    init_native_panner_node_factory_factory();
    init_native_panner_node_faker_factory2();
    init_native_panner_node_faker_factory_factory();
    init_native_periodic_wave();
    init_native_periodic_wave_factory2();
    init_native_periodic_wave_factory_factory();
    init_native_script_processor_node2();
    init_native_script_processor_node_factory();
    init_native_stereo_panner_node();
    init_native_stereo_panner_node_factory2();
    init_native_stereo_panner_node_factory_factory();
    init_native_stereo_panner_node_faker_factory2();
    init_native_stereo_panner_node_faker_factory_factory();
    init_native_wave_shaper_node();
    init_native_wave_shaper_node_factory2();
    init_native_wave_shaper_node_factory_factory();
    init_native_wave_shaper_node_faker_factory2();
    init_native_wave_shaper_node_faker_factory_factory();
    init_not_supported_error_factory();
    init_offline_audio_context_constructor_factory();
    init_oscillator_node_constructor2();
    init_oscillator_node_constructor_factory();
    init_oscillator_node_renderer2();
    init_oscillator_node_renderer_factory2();
    init_oscillator_node_renderer_factory_factory();
    init_oscillator_type();
    init_output_connection();
    init_over_sample_type();
    init_overwrite_accessors_function();
    init_panner_node_constructor2();
    init_panner_node_constructor_factory();
    init_panner_node_renderer_factory2();
    init_panner_node_renderer_factory_factory();
    init_panning_model_type();
    init_passive_audio_node_input_connection();
    init_passive_audio_param_input_connection();
    init_periodic_wave_constructor2();
    init_periodic_wave_constructor_factory();
    init_pick_element_from_set_function();
    init_render_automation_factory();
    init_render_automation_function();
    init_render_inputs_of_audio_node_factory();
    init_render_inputs_of_audio_node_function();
    init_render_inputs_of_audio_param_factory();
    init_render_inputs_of_audio_param_function();
    init_render_native_offline_audio_context_factory();
    init_render_native_offline_audio_context_function();
    init_sanitize_audio_worklet_node_options_function();
    init_sanitize_channel_splitter_options_function();
    init_sanitize_periodic_wave_options_function();
    init_set_active_audio_worklet_node_inputs_factory();
    init_set_active_audio_worklet_node_inputs_function();
    init_set_audio_node_tail_time_factory();
    init_set_audio_node_tail_time_function();
    init_set_value_at_time_until_possible_function();
    init_start_rendering_factory();
    init_start_rendering_function();
    init_stereo_panner_node_constructor2();
    init_stereo_panner_node_constructor_factory();
    init_stereo_panner_node_renderer_factory_factory();
    init_stereo_panner_node_renderer_factory2();
    init_test_audio_buffer_copy_channel_methods_subarray_support_factory();
    init_test_audio_buffer_constructor_support_factory();
    init_test_audio_context_close_method_support_factory();
    init_test_audio_context_decode_audio_data_method_type_error_support_factory();
    init_test_audio_context_options_support_factory();
    init_test_audio_node_connect_method_support_factory();
    init_test_audio_worklet_node_options_clonability_function();
    init_test_audio_worklet_processor_no_outputs_support_factory();
    init_test_audio_worklet_processor_post_message_support_factory();
    init_test_channel_merger_node_channel_count_support_factory();
    init_test_constant_source_node_accurate_scheduling_support_factory();
    init_test_convolver_node_buffer_reassignability_support_factory();
    init_test_convolver_node_channel_count_support_factory();
    init_test_is_secure_context_support_factory();
    init_test_media_stream_audio_source_node_media_stream_without_audio_track_support2();
    init_test_offline_audio_context_current_time_support_factory();
    init_test_stereo_panner_node_default_value_support_factory();
    init_unknown_error_factory();
    init_unrendered_audio_worklet_node_store();
    init_unrendered_audio_worklet_nodes();
    init_wave_shaper_node_constructor2();
    init_wave_shaper_node_constructor_factory();
    init_wave_shaper_node_renderer_factory_factory();
    init_wave_shaper_node_renderer_factory2();
    init_window4();
    init_window_factory2();
    init_wrap_audio_buffer_copy_channel_methods_factory();
    init_wrap_audio_buffer_copy_channel_methods_function();
    init_wrap_audio_buffer_copy_channel_methods_out_of_bounds_factory();
    init_wrap_audio_buffer_copy_channel_methods_out_of_bounds_function();
    init_wrap_audio_buffer_source_node_start_method_offset_clamping_function();
    init_wrap_audio_buffer_source_node_stop_method_nullified_buffer_factory();
    init_wrap_audio_buffer_source_node_stop_method_nullified_buffer_function();
    init_wrap_audio_scheduled_source_node_stop_method_consecutive_calls_function();
    init_wrap_channel_merger_node_factory();
    init_wrap_channel_merger_node_function();
    init_wrap_event_listener_function();
  }
});

// node_modules/standardized-audio-context/build/es2019/module.js
var addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, deleteActiveInputConnectionToAudioNode, audioNodeTailTimeStore, getAudioNodeTailTime, cacheTestResult, window3, createNativeAnalyserNode, getAudioNodeRenderer, renderInputsOfAudioNode, createAnalyserNodeRenderer, getNativeContext, nativeOfflineAudioContextConstructor, isNativeOfflineAudioContext, audioParamAudioNodeStore, eventTargetConstructor, nativeAudioContextConstructor, isNativeAudioContext, isNativeAudioNode2, isNativeAudioParam, nativeAudioWorkletNodeConstructor, audioNodeConstructor, analyserNodeConstructor, audioBufferStore, nativeAudioBufferConstructor, convertNumberToUnsignedLong, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds, audioBufferConstructor, addSilentConnection, renderInputsOfAudioParam, connectAudioParam, createNativeAudioBufferSourceNode, renderAutomation, createAudioBufferSourceNodeRenderer, createAudioParam, audioBufferSourceNodeConstructor, audioDestinationNodeConstructor, createBiquadFilterNodeRenderer, setAudioNodeTailTime, biquadFilterNodeConstructor, monitorConnections, wrapChannelMergerNode, createNativeChannelMergerNode, createChannelMergerNodeRenderer, channelMergerNodeConstructor, createChannelSplitterNodeRenderer, channelSplitterNodeConstructor, createNativeConstantSourceNodeFaker, createNativeConstantSourceNode, createConstantSourceNodeRenderer, constantSourceNodeConstructor, createNativeConvolverNode, createConvolverNodeRenderer, convolverNodeConstructor, createDelayNodeRenderer, delayNodeConstructor, createNativeDynamicsCompressorNode, createDynamicsCompressorNodeRenderer, dynamicsCompressorNodeConstructor, createGainNodeRenderer, gainNodeConstructor, createNativeIIRFilterNodeFaker, renderNativeOfflineAudioContext, createIIRFilterNodeRenderer, createNativeIIRFilterNode, iIRFilterNodeConstructor, createAudioListener, unrenderedAudioWorkletNodeStore, minimalBaseAudioContextConstructor, createNativeOscillatorNode, createOscillatorNodeRenderer, oscillatorNodeConstructor, createConnectedNativeAudioBufferSourceNode, createNativeWaveShaperNodeFaker, createNativeWaveShaperNode, createNativePannerNodeFaker, createNativePannerNode, createPannerNodeRenderer, pannerNodeConstructor, createNativePeriodicWave, periodicWaveConstructor, nativeStereoPannerNodeFakerFactory, createNativeStereoPannerNode, createStereoPannerNodeRenderer, stereoPannerNodeConstructor, createWaveShaperNodeRenderer, waveShaperNodeConstructor, isSecureContext, exposeCurrentFrameAndCurrentTime, backupOfflineAudioContextStore, getOrCreateBackupOfflineAudioContext, addAudioWorkletModule, isNativeContext, decodeAudioData, baseAudioContextConstructor, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, mediaStreamTrackAudioSourceNodeConstructor, audioContextConstructor, getUnrenderedAudioWorkletNodes, addUnrenderedAudioWorkletNode, connectMultipleOutputs, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, activeAudioWorkletNodeInputsStore, getActiveAudioWorkletNodeInputs, createNativeAudioWorkletNodeFaker, createNativeAudioWorkletNode, createAudioWorkletNodeRenderer, getBackupOfflineAudioContext, setActiveAudioWorkletNodeInputs, audioWorkletNodeConstructor, minimalAudioContextConstructor, createNativeOfflineAudioContext, startRendering, minimalOfflineAudioContextConstructor, offlineAudioContextConstructor, isAnyAudioContext, isAnyAudioNode, isAnyAudioParam, isAnyOfflineAudioContext;
var init_module11 = __esm({
  "node_modules/standardized-audio-context/build/es2019/module.js"() {
    init_module10();
    init_abort_error();
    init_add_active_input_connection_to_audio_node();
    init_add_audio_node_connections();
    init_add_audio_param_connections();
    init_add_audio_worklet_module();
    init_add_connection_to_audio_node();
    init_add_passive_input_connection_to_audio_node();
    init_add_silent_connection();
    init_add_unrendered_audio_worklet_node();
    init_analyser_node_constructor();
    init_analyser_node_renderer_factory();
    init_audio_buffer_constructor();
    init_audio_buffer_source_node_constructor();
    init_audio_buffer_source_node_renderer_factory();
    init_audio_context_constructor();
    init_audio_destination_node_constructor();
    init_audio_destination_node_renderer_factory();
    init_audio_listener_factory();
    init_audio_node_constructor();
    init_audio_param_factory();
    init_audio_param_renderer();
    init_audio_worklet_node_constructor();
    init_audio_worklet_node_renderer_factory();
    init_base_audio_context_constructor();
    init_biquad_filter_node_constructor();
    init_biquad_filter_node_renderer_factory();
    init_cache_test_result();
    init_channel_merger_node_constructor();
    init_channel_merger_node_renderer_factory();
    init_channel_splitter_node_constructor();
    init_channel_splitter_node_renderer_factory();
    init_connect_audio_param();
    init_connect_multiple_outputs();
    init_connected_native_audio_buffer_source_node_factory();
    init_constant_source_node_constructor();
    init_constant_source_node_renderer_factory();
    init_convert_number_to_unsigned_long();
    init_convolver_node_constructor();
    init_convolver_node_renderer_factory();
    init_create_native_offline_audio_context();
    init_data_clone_error();
    init_decode_audio_data();
    init_decrement_cycle_counter();
    init_delay_node_constructor();
    init_delay_node_renderer_factory();
    init_delete_active_input_connection_to_audio_node();
    init_delete_unrendered_audio_worklet_node();
    init_detect_cycles();
    init_disconnect_multiple_outputs();
    init_dynamics_compressor_node_constructor();
    init_dynamics_compressor_node_renderer_factory();
    init_encoding_error();
    init_evaluate_source();
    init_event_target_constructor2();
    init_expose_current_frame_and_current_time();
    init_fetch_source();
    init_gain_node_constructor();
    init_gain_node_renderer_factory();
    init_get_active_audio_worklet_node_inputs();
    init_get_audio_node_renderer();
    init_get_audio_node_tail_time();
    init_get_audio_param_renderer();
    init_get_backup_offline_audio_context();
    init_get_native_context();
    init_get_or_create_backup_offline_audio_context();
    init_get_unrendered_audio_worklet_nodes();
    init_iir_filter_node_constructor();
    init_iir_filter_node_renderer_factory();
    init_increment_cycle_counter_factory();
    init_index_size_error();
    init_invalid_access_error();
    init_invalid_state_error2();
    init_is_any_audio_context();
    init_is_any_audio_node();
    init_is_any_audio_param();
    init_is_any_offline_audio_context();
    init_is_native_audio_context();
    init_is_native_audio_node();
    init_is_native_audio_param();
    init_is_native_context();
    init_is_native_offline_audio_context();
    init_is_secure_context();
    init_is_supported_promise2();
    init_media_element_audio_source_node_constructor();
    init_media_stream_audio_destination_node_constructor();
    init_media_stream_audio_source_node_constructor();
    init_media_stream_track_audio_source_node_constructor();
    init_minimal_audio_context_constructor();
    init_minimal_base_audio_context_constructor();
    init_minimal_offline_audio_context_constructor();
    init_monitor_connections();
    init_native_analyser_node_factory();
    init_native_audio_buffer_constructor();
    init_native_audio_buffer_source_node_factory();
    init_native_audio_context_constructor();
    init_native_audio_destination_node();
    init_native_audio_worklet_node_constructor();
    init_native_audio_worklet_node_factory();
    init_native_audio_worklet_node_faker_factory();
    init_native_biquad_filter_node();
    init_native_channel_merger_node_factory();
    init_native_channel_splitter_node();
    init_native_constant_source_node_factory();
    init_native_constant_source_node_faker_factory();
    init_native_convolver_node_factory();
    init_native_delay_node();
    init_native_dynamics_compressor_node_factory();
    init_native_gain_node();
    init_native_iir_filter_node_factory();
    init_native_iir_filter_node_faker_factory();
    init_native_media_element_audio_source_node();
    init_native_media_stream_audio_destination_node();
    init_native_media_stream_audio_source_node();
    init_native_media_stream_track_audio_source_node_factory();
    init_native_offline_audio_context_constructor();
    init_native_oscillator_node_factory();
    init_native_panner_node_factory();
    init_native_panner_node_faker_factory();
    init_native_periodic_wave_factory();
    init_native_script_processor_node();
    init_native_stereo_panner_node_factory();
    init_native_stereo_panner_node_faker_factory();
    init_native_wave_shaper_node_factory();
    init_native_wave_shaper_node_faker_factory();
    init_not_supported_error2();
    init_offline_audio_context_constructor();
    init_oscillator_node_constructor();
    init_oscillator_node_renderer_factory();
    init_panner_node_constructor();
    init_panner_node_renderer_factory();
    init_periodic_wave_constructor();
    init_render_automation();
    init_render_inputs_of_audio_node();
    init_render_inputs_of_audio_param();
    init_render_native_offline_audio_context();
    init_set_active_audio_worklet_node_inputs();
    init_set_audio_node_tail_time();
    init_start_rendering();
    init_stereo_panner_node_constructor();
    init_stereo_panner_node_renderer_factory();
    init_test_audio_buffer_constructor_support();
    init_test_audio_buffer_copy_channel_methods_subarray_support();
    init_test_audio_context_close_method_support();
    init_test_audio_context_decode_audio_data_method_type_error_support();
    init_test_audio_context_options_support();
    init_test_audio_node_connect_method_support();
    init_test_audio_worklet_processor_no_outputs_support();
    init_test_audio_worklet_processor_post_message_support();
    init_test_channel_merger_node_channel_count_support();
    init_test_constant_source_node_accurate_scheduling_support();
    init_test_convolver_node_buffer_reassignability_support();
    init_test_convolver_node_channel_count_support();
    init_test_is_secure_context_support();
    init_test_media_stream_audio_source_node_media_stream_without_audio_track_support();
    init_test_offline_audio_context_current_time_support();
    init_test_stereo_panner_node_default_value_support();
    init_unknown_error();
    init_wave_shaper_node_constructor();
    init_wave_shaper_node_renderer_factory();
    init_window3();
    init_wrap_audio_buffer_copy_channel_methods();
    init_wrap_audio_buffer_copy_channel_methods_out_of_bounds();
    init_wrap_audio_buffer_source_node_stop_method_nullified_buffer();
    init_wrap_channel_merger_node();
    init_globals();
    init_connect_native_audio_node_to_native_audio_node();
    init_disconnect_native_audio_node_from_native_audio_node();
    init_get_audio_node_connections();
    init_get_audio_param_connections();
    init_get_event_listeners_of_audio_node();
    init_get_first_sample();
    init_get_native_audio_node();
    init_get_native_audio_param();
    init_get_value_for_key();
    init_insert_element_in_set();
    init_is_active_audio_node();
    init_is_dc_curve();
    init_is_part_of_a_cycle();
    init_is_passive_audio_node();
    init_overwrite_accessors();
    init_pick_element_from_set();
    init_sanitize_audio_worklet_node_options();
    init_sanitize_channel_splitter_options();
    init_sanitize_periodic_wave_options();
    init_set_value_at_time_until_possible();
    init_test_audio_buffer_copy_channel_methods_out_of_bounds_support();
    init_test_audio_buffer_source_node_start_method_consecutive_calls_support();
    init_test_audio_buffer_source_node_start_method_offset_clamping_support();
    init_test_audio_buffer_source_node_stop_method_nullified_buffer_support();
    init_test_audio_scheduled_source_node_start_method_negative_parameters_support();
    init_test_audio_scheduled_source_node_stop_method_consecutive_calls_support();
    init_test_audio_scheduled_source_node_stop_method_negative_parameters_support();
    init_test_audio_worklet_node_options_clonability();
    init_test_dom_exception_constructor_support();
    init_test_promise_support();
    init_test_transferables_support();
    init_wrap_audio_buffer_source_node_start_method_offset_clamping();
    init_wrap_audio_scheduled_source_node_stop_method_consecutive_calls();
    init_wrap_event_listener();
    init_interfaces8();
    init_types10();
    addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);
    addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);
    deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);
    audioNodeTailTimeStore = /* @__PURE__ */ new WeakMap();
    getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);
    cacheTestResult = createCacheTestResult(/* @__PURE__ */ new Map(), /* @__PURE__ */ new WeakMap());
    window3 = createWindow2();
    createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);
    getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);
    renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);
    createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);
    getNativeContext = createGetNativeContext(CONTEXT_STORE);
    nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window3);
    isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);
    audioParamAudioNodeStore = /* @__PURE__ */ new WeakMap();
    eventTargetConstructor = createEventTargetConstructor2(wrapEventListener);
    nativeAudioContextConstructor = createNativeAudioContextConstructor(window3);
    isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);
    isNativeAudioNode2 = createIsNativeAudioNode(window3);
    isNativeAudioParam = createIsNativeAudioParam(window3);
    nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window3);
    audioNodeConstructor = createAudioNodeConstructor(createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE), createAddConnectionToAudioNode(addActiveInputConnectionToAudioNode, addPassiveInputConnectionToAudioNode, connectNativeAudioNodeToNativeAudioNode, deleteActiveInputConnectionToAudioNode, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getAudioNodeTailTime, getEventListenersOfAudioNode, getNativeAudioNode, insertElementInSet, isActiveAudioNode, isPartOfACycle, isPassiveAudioNode), cacheTestResult, createIncrementCycleCounterFactory(CYCLE_COUNTERS, disconnectNativeAudioNodeFromNativeAudioNode, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, isActiveAudioNode), createIndexSizeError, createInvalidAccessError, createNotSupportedError2, createDecrementCycleCounter(connectNativeAudioNodeToNativeAudioNode, CYCLE_COUNTERS, getAudioNodeConnections, getNativeAudioNode, getNativeAudioParam, getNativeContext, isActiveAudioNode, isNativeOfflineAudioContext), createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey), eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode2, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor);
    analyserNodeConstructor = createAnalyserNodeConstructor(audioNodeConstructor, createAnalyserNodeRenderer, createIndexSizeError, createNativeAnalyserNode, getNativeContext, isNativeOfflineAudioContext);
    audioBufferStore = /* @__PURE__ */ new WeakSet();
    nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window3);
    convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));
    wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);
    wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);
    audioBufferConstructor = createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError2, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor), wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
    addSilentConnection = createAddSilentConnection(createNativeGainNode);
    renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);
    connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);
    createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(addSilentConnection, cacheTestResult, testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, testAudioBufferSourceNodeStartMethodOffsetClampingSupport, testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioBufferSourceNodeStartMethodOffsetClamping, createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors), wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
    renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);
    createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(connectAudioParam, createNativeAudioBufferSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
    createAudioParam = createAudioParamFactory(createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE), audioParamAudioNodeStore, AUDIO_PARAM_STORE, createAudioParamRenderer, createCancelAndHoldAutomationEvent, createCancelScheduledValuesAutomationEvent, createExponentialRampToValueAutomationEvent, createLinearRampToValueAutomationEvent, createSetTargetAutomationEvent, createSetValueAutomationEvent, createSetValueCurveAutomationEvent, nativeAudioContextConstructor, setValueAtTimeUntilPossible);
    audioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError2, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
    audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(audioNodeConstructor, createAudioDestinationNodeRenderer, createIndexSizeError, createInvalidStateError2, createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors), getNativeContext, isNativeOfflineAudioContext, renderInputsOfAudioNode);
    createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(connectAudioParam, createNativeBiquadFilterNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
    setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);
    biquadFilterNodeConstructor = createBiquadFilterNodeConstructor(audioNodeConstructor, createAudioParam, createBiquadFilterNodeRenderer, createInvalidAccessError, createNativeBiquadFilterNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
    monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode2);
    wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError2, monitorConnections);
    createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);
    createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(createNativeChannelMergerNode, getNativeAudioNode, renderInputsOfAudioNode);
    channelMergerNodeConstructor = createChannelMergerNodeConstructor(audioNodeConstructor, createChannelMergerNodeRenderer, createNativeChannelMergerNode, getNativeContext, isNativeOfflineAudioContext);
    createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(createNativeChannelSplitterNode, getNativeAudioNode, renderInputsOfAudioNode);
    channelSplitterNodeConstructor = createChannelSplitterNodeConstructor(audioNodeConstructor, createChannelSplitterNodeRenderer, createNativeChannelSplitterNode, getNativeContext, isNativeOfflineAudioContext, sanitizeChannelSplitterOptions);
    createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(addSilentConnection, createNativeAudioBufferSourceNode, createNativeGainNode, monitorConnections);
    createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(addSilentConnection, cacheTestResult, createNativeConstantSourceNodeFaker, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport);
    createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(connectAudioParam, createNativeConstantSourceNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
    constantSourceNodeConstructor = createConstantSourceNodeConstructor(audioNodeConstructor, createAudioParam, createConstantSourceNodeRenderer, createNativeConstantSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
    createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError2, overwriteAccessors);
    createConvolverNodeRenderer = createConvolverNodeRendererFactory(createNativeConvolverNode, getNativeAudioNode, renderInputsOfAudioNode);
    convolverNodeConstructor = createConvolverNodeConstructor(audioNodeConstructor, createConvolverNodeRenderer, createNativeConvolverNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
    createDelayNodeRenderer = createDelayNodeRendererFactory(connectAudioParam, createNativeDelayNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
    delayNodeConstructor = createDelayNodeConstructor(audioNodeConstructor, createAudioParam, createDelayNodeRenderer, createNativeDelayNode, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
    createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError2);
    createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(connectAudioParam, createNativeDynamicsCompressorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
    dynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(audioNodeConstructor, createAudioParam, createDynamicsCompressorNodeRenderer, createNativeDynamicsCompressorNode, createNotSupportedError2, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
    createGainNodeRenderer = createGainNodeRendererFactory(connectAudioParam, createNativeGainNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
    gainNodeConstructor = createGainNodeConstructor(audioNodeConstructor, createAudioParam, createGainNodeRenderer, createNativeGainNode, getNativeContext, isNativeOfflineAudioContext);
    createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(createInvalidAccessError, createInvalidStateError2, createNativeScriptProcessorNode, createNotSupportedError2);
    renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(cacheTestResult, createNativeGainNode, createNativeScriptProcessorNode, createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor));
    createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(createNativeAudioBufferSourceNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
    createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);
    iIRFilterNodeConstructor = createIIRFilterNodeConstructor(audioNodeConstructor, createNativeIIRFilterNode, createIIRFilterNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
    createAudioListener = createAudioListenerFactory(createAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeScriptProcessorNode, createNotSupportedError2, getFirstSample, isNativeOfflineAudioContext, overwriteAccessors);
    unrenderedAudioWorkletNodeStore = /* @__PURE__ */ new WeakMap();
    minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(audioDestinationNodeConstructor, createAudioListener, eventTargetConstructor, isNativeOfflineAudioContext, unrenderedAudioWorkletNodeStore, wrapEventListener);
    createNativeOscillatorNode = createNativeOscillatorNodeFactory(addSilentConnection, cacheTestResult, testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls);
    createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(connectAudioParam, createNativeOscillatorNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
    oscillatorNodeConstructor = createOscillatorNodeConstructor(audioNodeConstructor, createAudioParam, createNativeOscillatorNode, createOscillatorNodeRenderer, getNativeContext, isNativeOfflineAudioContext, wrapEventListener);
    createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);
    createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError2, createNativeGainNode, isDCCurve, monitorConnections);
    createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(createConnectedNativeAudioBufferSourceNode, createInvalidStateError2, createNativeWaveShaperNodeFaker, isDCCurve, monitorConnections, nativeAudioContextConstructor, overwriteAccessors);
    createNativePannerNodeFaker = createNativePannerNodeFakerFactory(connectNativeAudioNodeToNativeAudioNode, createInvalidStateError2, createNativeChannelMergerNode, createNativeGainNode, createNativeScriptProcessorNode, createNativeWaveShaperNode, createNotSupportedError2, disconnectNativeAudioNodeFromNativeAudioNode, getFirstSample, monitorConnections);
    createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);
    createPannerNodeRenderer = createPannerNodeRendererFactory(connectAudioParam, createNativeChannelMergerNode, createNativeConstantSourceNode, createNativeGainNode, createNativePannerNode, getNativeAudioNode, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
    pannerNodeConstructor = createPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativePannerNode, createPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
    createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);
    periodicWaveConstructor = createPeriodicWaveConstructor(createNativePeriodicWave, getNativeContext, /* @__PURE__ */ new WeakSet(), sanitizePeriodicWaveOptions);
    nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError2, monitorConnections);
    createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError2);
    createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(connectAudioParam, createNativeStereoPannerNode, getNativeAudioNode, renderAutomation, renderInputsOfAudioNode);
    stereoPannerNodeConstructor = createStereoPannerNodeConstructor(audioNodeConstructor, createAudioParam, createNativeStereoPannerNode, createStereoPannerNodeRenderer, getNativeContext, isNativeOfflineAudioContext);
    createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(createNativeWaveShaperNode, getNativeAudioNode, renderInputsOfAudioNode);
    waveShaperNodeConstructor = createWaveShaperNodeConstructor(audioNodeConstructor, createInvalidStateError2, createNativeWaveShaperNode, createWaveShaperNodeRenderer, getNativeContext, isNativeOfflineAudioContext, setAudioNodeTailTime);
    isSecureContext = createIsSecureContext(window3);
    exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window3);
    backupOfflineAudioContextStore = /* @__PURE__ */ new WeakMap();
    getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(backupOfflineAudioContextStore, nativeOfflineAudioContextConstructor);
    addAudioWorkletModule = isSecureContext ? createAddAudioWorkletModule(
      cacheTestResult,
      createNotSupportedError2,
      createEvaluateSource(window3),
      exposeCurrentFrameAndCurrentTime,
      createFetchSource(createAbortError),
      getNativeContext,
      getOrCreateBackupOfflineAudioContext,
      isNativeOfflineAudioContext,
      nativeAudioWorkletNodeConstructor,
      /* @__PURE__ */ new WeakMap(),
      /* @__PURE__ */ new WeakMap(),
      createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),
      // @todo window is guaranteed to be defined because isSecureContext checks that as well.
      window3
    ) : void 0;
    isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);
    decodeAudioData = createDecodeAudioData(audioBufferStore, cacheTestResult, createDataCloneError, createEncodingError, /* @__PURE__ */ new WeakSet(), getNativeContext, isNativeContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, testPromiseSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
    baseAudioContextConstructor = createBaseAudioContextConstructor(addAudioWorkletModule, analyserNodeConstructor, audioBufferConstructor, audioBufferSourceNodeConstructor, biquadFilterNodeConstructor, channelMergerNodeConstructor, channelSplitterNodeConstructor, constantSourceNodeConstructor, convolverNodeConstructor, decodeAudioData, delayNodeConstructor, dynamicsCompressorNodeConstructor, gainNodeConstructor, iIRFilterNodeConstructor, minimalBaseAudioContextConstructor, oscillatorNodeConstructor, pannerNodeConstructor, periodicWaveConstructor, stereoPannerNodeConstructor, waveShaperNodeConstructor);
    mediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaElementAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
    mediaStreamAudioDestinationNodeConstructor = createMediaStreamAudioDestinationNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioDestinationNode, getNativeContext, isNativeOfflineAudioContext);
    mediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamAudioSourceNode, getNativeContext, isNativeOfflineAudioContext);
    createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(createInvalidStateError2, isNativeOfflineAudioContext);
    mediaStreamTrackAudioSourceNodeConstructor = createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);
    audioContextConstructor = createAudioContextConstructor(baseAudioContextConstructor, createInvalidStateError2, createNotSupportedError2, createUnknownError, mediaElementAudioSourceNodeConstructor, mediaStreamAudioDestinationNodeConstructor, mediaStreamAudioSourceNodeConstructor, mediaStreamTrackAudioSourceNodeConstructor, nativeAudioContextConstructor);
    getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);
    addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);
    connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);
    deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);
    disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);
    activeAudioWorkletNodeInputsStore = /* @__PURE__ */ new WeakMap();
    getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);
    createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(connectMultipleOutputs, createIndexSizeError, createInvalidStateError2, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, createNativeScriptProcessorNode, createNotSupportedError2, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getActiveAudioWorkletNodeInputs, monitorConnections);
    createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(createInvalidStateError2, createNativeAudioWorkletNodeFaker, createNativeGainNode, createNotSupportedError2, monitorConnections);
    createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext);
    getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);
    setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);
    audioWorkletNodeConstructor = isSecureContext ? createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) : void 0;
    minimalAudioContextConstructor = createMinimalAudioContextConstructor(createInvalidStateError2, createNotSupportedError2, createUnknownError, minimalBaseAudioContextConstructor, nativeAudioContextConstructor);
    createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(createNotSupportedError2, nativeOfflineAudioContextConstructor);
    startRendering = createStartRendering(audioBufferStore, cacheTestResult, getAudioNodeRenderer, getUnrenderedAudioWorkletNodes, renderNativeOfflineAudioContext, testAudioBufferCopyChannelMethodsOutOfBoundsSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds);
    minimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(cacheTestResult, createInvalidStateError2, createNativeOfflineAudioContext, minimalBaseAudioContextConstructor, startRendering);
    offlineAudioContextConstructor = createOfflineAudioContextConstructor(baseAudioContextConstructor, cacheTestResult, createInvalidStateError2, createNativeOfflineAudioContext, startRendering);
    isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);
    isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode2);
    isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);
    isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/web-audio-media-recorder.js
var ERROR_MESSAGE, createPromisedAudioNodesEncoderIdAndPort, createWebAudioMediaRecorderFactory;
var init_web_audio_media_recorder = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/web-audio-media-recorder.js"() {
    init_module4();
    init_module9();
    init_module11();
    ERROR_MESSAGE = "Missing AudioWorklet support. Maybe this is not running in a secure context.";
    createPromisedAudioNodesEncoderIdAndPort = async (audioBuffer, audioContext, channelCount, mediaStream, mimeType) => {
      const { encoderId, port } = await instantiate(mimeType, audioContext.sampleRate);
      if (audioWorkletNodeConstructor === void 0) {
        throw new Error(ERROR_MESSAGE);
      }
      const audioBufferSourceNode = new audioBufferSourceNodeConstructor(audioContext, { buffer: audioBuffer });
      const mediaStreamAudioSourceNode = new mediaStreamAudioSourceNodeConstructor(audioContext, { mediaStream });
      const recorderAudioWorkletNode = createRecorderAudioWorkletNode(audioWorkletNodeConstructor, audioContext, { channelCount });
      return { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode };
    };
    createWebAudioMediaRecorderFactory = (createBlobEvent2, createInvalidModificationError2, createInvalidStateError3, createNotSupportedError3) => {
      return (eventTarget, mediaStream, mimeType) => {
        var _a13;
        const sampleRate = (_a13 = mediaStream.getAudioTracks()[0]) === null || _a13 === void 0 ? void 0 : _a13.getSettings().sampleRate;
        const audioContext = new minimalAudioContextConstructor({ latencyHint: "playback", sampleRate });
        const length = Math.max(1024, Math.ceil(audioContext.baseLatency * audioContext.sampleRate));
        const audioBuffer = new audioBufferConstructor({ length, sampleRate: audioContext.sampleRate });
        const bufferedArrayBuffers = [];
        const promisedAudioWorkletModule = addRecorderAudioWorkletModule((url4) => {
          if (addAudioWorkletModule === void 0) {
            throw new Error(ERROR_MESSAGE);
          }
          return addAudioWorkletModule(audioContext, url4);
        });
        let abortRecording = null;
        let intervalId = null;
        let promisedAudioNodesAndEncoderId = null;
        let promisedPartialRecording = null;
        let isAudioContextRunning = true;
        const dispatchDataAvailableEvent = (arrayBuffers) => {
          eventTarget.dispatchEvent(createBlobEvent2("dataavailable", { data: new Blob(arrayBuffers, { type: mimeType }) }));
        };
        const requestNextPartialRecording = async (encoderId, timeslice) => {
          const arrayBuffers = await encode(encoderId, timeslice);
          if (promisedAudioNodesAndEncoderId === null) {
            bufferedArrayBuffers.push(...arrayBuffers);
          } else {
            dispatchDataAvailableEvent(arrayBuffers);
            promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);
          }
        };
        const resume = () => {
          isAudioContextRunning = true;
          return audioContext.resume();
        };
        const stop = () => {
          if (promisedAudioNodesAndEncoderId === null) {
            return;
          }
          if (abortRecording !== null) {
            mediaStream.removeEventListener("addtrack", abortRecording);
            mediaStream.removeEventListener("removetrack", abortRecording);
          }
          if (intervalId !== null) {
            clearTimeout(intervalId);
          }
          promisedAudioNodesAndEncoderId.then(async ({ constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode }) => {
            if (promisedPartialRecording !== null) {
              promisedPartialRecording.catch(() => {
              });
              promisedPartialRecording = null;
            }
            await recorderAudioWorkletNode.stop();
            mediaStreamAudioSourceNode.disconnect(recorderAudioWorkletNode);
            constantSourceNode.stop();
            const arrayBuffers = await encode(encoderId, null);
            if (promisedAudioNodesAndEncoderId === null) {
              await suspend();
            }
            dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);
            bufferedArrayBuffers.length = 0;
            eventTarget.dispatchEvent(new Event("stop"));
          });
          promisedAudioNodesAndEncoderId = null;
        };
        const suspend = () => {
          isAudioContextRunning = false;
          return audioContext.suspend();
        };
        suspend();
        return {
          get mimeType() {
            return mimeType;
          },
          get state() {
            return promisedAudioNodesAndEncoderId === null ? "inactive" : isAudioContextRunning ? "recording" : "paused";
          },
          pause() {
            if (promisedAudioNodesAndEncoderId === null) {
              throw createInvalidStateError3();
            }
            if (isAudioContextRunning) {
              suspend();
              eventTarget.dispatchEvent(new Event("pause"));
            }
          },
          resume() {
            if (promisedAudioNodesAndEncoderId === null) {
              throw createInvalidStateError3();
            }
            if (!isAudioContextRunning) {
              resume();
              eventTarget.dispatchEvent(new Event("resume"));
            }
          },
          start(timeslice) {
            var _a14;
            if (promisedAudioNodesAndEncoderId !== null) {
              throw createInvalidStateError3();
            }
            if (mediaStream.getVideoTracks().length > 0) {
              throw createNotSupportedError3();
            }
            eventTarget.dispatchEvent(new Event("start"));
            const audioTracks = mediaStream.getAudioTracks();
            const channelCount = audioTracks.length === 0 ? 2 : (_a14 = audioTracks[0].getSettings().channelCount) !== null && _a14 !== void 0 ? _a14 : 2;
            promisedAudioNodesAndEncoderId = Promise.all([
              resume(),
              promisedAudioWorkletModule.then(() => createPromisedAudioNodesEncoderIdAndPort(audioBuffer, audioContext, channelCount, mediaStream, mimeType))
            ]).then(async ([, { audioBufferSourceNode, encoderId, mediaStreamAudioSourceNode, port, recorderAudioWorkletNode }]) => {
              mediaStreamAudioSourceNode.connect(recorderAudioWorkletNode);
              await new Promise((resolve) => {
                audioBufferSourceNode.onended = resolve;
                audioBufferSourceNode.connect(recorderAudioWorkletNode);
                audioBufferSourceNode.start(audioContext.currentTime + length / audioContext.sampleRate);
              });
              audioBufferSourceNode.disconnect(recorderAudioWorkletNode);
              const constantSourceNode = new constantSourceNodeConstructor(audioContext, { offset: 0 });
              constantSourceNode.onended = () => constantSourceNode.disconnect();
              constantSourceNode.connect(audioContext.destination);
              constantSourceNode.start();
              await recorderAudioWorkletNode.record(port);
              if (timeslice !== void 0) {
                promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);
              }
              return { constantSourceNode, encoderId, mediaStreamAudioSourceNode, recorderAudioWorkletNode };
            });
            const tracks = mediaStream.getTracks();
            abortRecording = () => {
              stop();
              eventTarget.dispatchEvent(new ErrorEvent("error", { error: createInvalidModificationError2() }));
            };
            mediaStream.addEventListener("addtrack", abortRecording);
            mediaStream.addEventListener("removetrack", abortRecording);
            intervalId = setInterval(() => {
              const currentTracks = mediaStream.getTracks();
              if ((currentTracks.length !== tracks.length || currentTracks.some((track, index) => track !== tracks[index])) && abortRecording !== null) {
                abortRecording();
              }
            }, 1e3);
          },
          stop
        };
      };
    };
  }
});

// node_modules/multi-buffer-data-view/build/es2019/classes/multi-buffer-data-view.js
var MultiBufferDataView;
var init_multi_buffer_data_view = __esm({
  "node_modules/multi-buffer-data-view/build/es2019/classes/multi-buffer-data-view.js"() {
    MultiBufferDataView = class {
      constructor(buffers, byteOffset = 0, byteLength) {
        if (byteOffset < 0 || byteLength !== void 0 && byteLength < 0) {
          throw new RangeError();
        }
        const availableBytes = buffers.reduce((length, buffer) => length + buffer.byteLength, 0);
        if (byteOffset > availableBytes || byteLength !== void 0 && byteOffset + byteLength > availableBytes) {
          throw new RangeError();
        }
        const dataViews = [];
        const effectiveByteLength = byteLength === void 0 ? availableBytes - byteOffset : byteLength;
        const truncatedBuffers = [];
        let consumedByteLength = 0;
        let truncatedByteOffset = byteOffset;
        for (const buffer of buffers) {
          if (truncatedBuffers.length === 0) {
            if (buffer.byteLength > truncatedByteOffset) {
              consumedByteLength = buffer.byteLength - truncatedByteOffset;
              const byteLengthOfDataView = consumedByteLength > effectiveByteLength ? effectiveByteLength : consumedByteLength;
              dataViews.push(new DataView(buffer, truncatedByteOffset, byteLengthOfDataView));
              truncatedBuffers.push(buffer);
            } else {
              truncatedByteOffset -= buffer.byteLength;
            }
          } else if (consumedByteLength < effectiveByteLength) {
            consumedByteLength += buffer.byteLength;
            const byteLengthOfDataView = consumedByteLength > effectiveByteLength ? buffer.byteLength - consumedByteLength + effectiveByteLength : buffer.byteLength;
            dataViews.push(new DataView(buffer, 0, byteLengthOfDataView));
            truncatedBuffers.push(buffer);
          }
        }
        this._buffers = truncatedBuffers;
        this._byteLength = effectiveByteLength;
        this._byteOffset = truncatedByteOffset;
        this._dataViews = dataViews;
        this._internalBuffer = new DataView(new ArrayBuffer(8));
      }
      get buffers() {
        return this._buffers;
      }
      get byteLength() {
        return this._byteLength;
      }
      get byteOffset() {
        return this._byteOffset;
      }
      getFloat32(byteOffset, littleEndian) {
        this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));
        this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));
        this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));
        this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));
        return this._internalBuffer.getFloat32(0, littleEndian);
      }
      getFloat64(byteOffset, littleEndian) {
        this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));
        this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));
        this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));
        this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));
        this._internalBuffer.setUint8(4, this.getUint8(byteOffset + 4));
        this._internalBuffer.setUint8(5, this.getUint8(byteOffset + 5));
        this._internalBuffer.setUint8(6, this.getUint8(byteOffset + 6));
        this._internalBuffer.setUint8(7, this.getUint8(byteOffset + 7));
        return this._internalBuffer.getFloat64(0, littleEndian);
      }
      getInt16(byteOffset, littleEndian) {
        this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));
        this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));
        return this._internalBuffer.getInt16(0, littleEndian);
      }
      getInt32(byteOffset, littleEndian) {
        this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));
        this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));
        this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));
        this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));
        return this._internalBuffer.getInt32(0, littleEndian);
      }
      getInt8(byteOffset) {
        const [dataView, byteOffsetOfDataView] = this._findDataViewWithOffset(byteOffset);
        return dataView.getInt8(byteOffset - byteOffsetOfDataView);
      }
      getUint16(byteOffset, littleEndian) {
        this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));
        this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));
        return this._internalBuffer.getUint16(0, littleEndian);
      }
      getUint32(byteOffset, littleEndian) {
        this._internalBuffer.setUint8(0, this.getUint8(byteOffset + 0));
        this._internalBuffer.setUint8(1, this.getUint8(byteOffset + 1));
        this._internalBuffer.setUint8(2, this.getUint8(byteOffset + 2));
        this._internalBuffer.setUint8(3, this.getUint8(byteOffset + 3));
        return this._internalBuffer.getUint32(0, littleEndian);
      }
      getUint8(byteOffset) {
        const [dataView, byteOffsetOfDataView] = this._findDataViewWithOffset(byteOffset);
        return dataView.getUint8(byteOffset - byteOffsetOfDataView);
      }
      setFloat32(byteOffset, value, littleEndian) {
        this._internalBuffer.setFloat32(0, value, littleEndian);
        this.setUint8(byteOffset, this._internalBuffer.getUint8(0));
        this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));
        this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));
        this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));
      }
      setFloat64(byteOffset, value, littleEndian) {
        this._internalBuffer.setFloat64(0, value, littleEndian);
        this.setUint8(byteOffset, this._internalBuffer.getUint8(0));
        this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));
        this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));
        this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));
        this.setUint8(byteOffset + 4, this._internalBuffer.getUint8(4));
        this.setUint8(byteOffset + 5, this._internalBuffer.getUint8(5));
        this.setUint8(byteOffset + 6, this._internalBuffer.getUint8(6));
        this.setUint8(byteOffset + 7, this._internalBuffer.getUint8(7));
      }
      setInt16(byteOffset, value, littleEndian) {
        this._internalBuffer.setInt16(0, value, littleEndian);
        this.setUint8(byteOffset, this._internalBuffer.getUint8(0));
        this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));
      }
      setInt32(byteOffset, value, littleEndian) {
        this._internalBuffer.setInt32(0, value, littleEndian);
        this.setUint8(byteOffset, this._internalBuffer.getUint8(0));
        this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));
        this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));
        this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));
      }
      setInt8(byteOffset, value) {
        const [dataView, byteOffsetOfDataView] = this._findDataViewWithOffset(byteOffset);
        dataView.setInt8(byteOffset - byteOffsetOfDataView, value);
      }
      setUint16(byteOffset, value, littleEndian) {
        this._internalBuffer.setUint16(0, value, littleEndian);
        this.setUint8(byteOffset, this._internalBuffer.getUint8(0));
        this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));
      }
      setUint32(byteOffset, value, littleEndian) {
        this._internalBuffer.setUint32(0, value, littleEndian);
        this.setUint8(byteOffset, this._internalBuffer.getUint8(0));
        this.setUint8(byteOffset + 1, this._internalBuffer.getUint8(1));
        this.setUint8(byteOffset + 2, this._internalBuffer.getUint8(2));
        this.setUint8(byteOffset + 3, this._internalBuffer.getUint8(3));
      }
      setUint8(byteOffset, value) {
        const [dataView, byteOffsetOfDataView] = this._findDataViewWithOffset(byteOffset);
        dataView.setUint8(byteOffset - byteOffsetOfDataView, value);
      }
      _findDataViewWithOffset(byteOffset) {
        let byteOffsetOfDataView = 0;
        for (const dataView of this._dataViews) {
          const byteOffsetOfNextDataView = byteOffsetOfDataView + dataView.byteLength;
          if (byteOffset >= byteOffsetOfDataView && byteOffset < byteOffsetOfNextDataView) {
            return [dataView, byteOffsetOfDataView];
          }
          byteOffsetOfDataView = byteOffsetOfNextDataView;
        }
        throw new RangeError();
      }
    };
  }
});

// node_modules/multi-buffer-data-view/build/es2019/module.js
var init_module12 = __esm({
  "node_modules/multi-buffer-data-view/build/es2019/module.js"() {
    init_multi_buffer_data_view();
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/webm-pcm-media-recorder.js
var createWebmPcmMediaRecorderFactory;
var init_webm_pcm_media_recorder = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/webm-pcm-media-recorder.js"() {
    init_module4();
    init_module12();
    init_module6();
    createWebmPcmMediaRecorderFactory = (createBlobEvent2, createInvalidModificationError2, createNotSupportedError3, decodeWebMChunk2, readVariableSizeInteger2) => {
      return (eventTarget, nativeMediaRecorderConstructor2, mediaStream, mimeType) => {
        const audioTracks = mediaStream.getAudioTracks();
        const bufferedArrayBuffers = [];
        const channelCount = audioTracks.length === 0 ? void 0 : audioTracks[0].getSettings().channelCount;
        const nativeMediaRecorder = new nativeMediaRecorderConstructor2(mediaStream, { mimeType: "audio/webm;codecs=pcm" });
        const sampleRate = audioTracks.length === 0 ? void 0 : audioTracks[0].getSettings().sampleRate;
        let promisedPartialRecording = null;
        let stopRecording = () => {
        };
        const dispatchDataAvailableEvent = (arrayBuffers) => {
          eventTarget.dispatchEvent(createBlobEvent2("dataavailable", { data: new Blob(arrayBuffers, { type: mimeType }) }));
        };
        const requestNextPartialRecording = async (encoderId, timeslice) => {
          const arrayBuffers = await encode(encoderId, timeslice);
          if (nativeMediaRecorder.state === "inactive") {
            bufferedArrayBuffers.push(...arrayBuffers);
          } else {
            dispatchDataAvailableEvent(arrayBuffers);
            promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice);
          }
        };
        const stop = () => {
          if (nativeMediaRecorder.state === "inactive") {
            return;
          }
          if (promisedPartialRecording !== null) {
            promisedPartialRecording.catch(() => {
            });
            promisedPartialRecording = null;
          }
          stopRecording();
          stopRecording = () => {
          };
          nativeMediaRecorder.stop();
        };
        nativeMediaRecorder.addEventListener("error", () => {
          stop();
          eventTarget.dispatchEvent(new ErrorEvent("error", { error: createInvalidModificationError2() }));
        });
        nativeMediaRecorder.addEventListener("start", () => eventTarget.dispatchEvent(new Event("start")));
        return {
          get mimeType() {
            return mimeType;
          },
          get state() {
            return nativeMediaRecorder.state;
          },
          pause() {
            return nativeMediaRecorder.pause();
          },
          resume() {
            return nativeMediaRecorder.resume();
          },
          start(timeslice) {
            if (mediaStream.getVideoTracks().length > 0) {
              throw createNotSupportedError3();
            }
            if (nativeMediaRecorder.state === "inactive") {
              if (sampleRate === void 0) {
                throw new Error("The sampleRate is not defined.");
              }
              let isRecording = false;
              let isStopped = false;
              let pendingInvocations = 0;
              let promisedDataViewElementTypeEncoderIdAndPort = instantiate(mimeType, sampleRate);
              stopRecording = () => {
                isStopped = true;
              };
              const removeEventListener = on(nativeMediaRecorder, "dataavailable")(({ data }) => {
                pendingInvocations += 1;
                promisedDataViewElementTypeEncoderIdAndPort = promisedDataViewElementTypeEncoderIdAndPort.then(async ({ dataView = null, elementType = null, encoderId, port }) => {
                  const arrayBuffer = await data.arrayBuffer();
                  pendingInvocations -= 1;
                  const currentDataView = dataView === null ? new MultiBufferDataView([arrayBuffer]) : new MultiBufferDataView([...dataView.buffers, arrayBuffer], dataView.byteOffset);
                  if (!isRecording && nativeMediaRecorder.state === "recording" && !isStopped) {
                    const lengthAndValue = readVariableSizeInteger2(currentDataView, 0);
                    if (lengthAndValue === null) {
                      return { dataView: currentDataView, elementType, encoderId, port };
                    }
                    const { value } = lengthAndValue;
                    if (value !== 172351395) {
                      return { dataView, elementType, encoderId, port };
                    }
                    isRecording = true;
                  }
                  const { currentElementType, offset, contents } = decodeWebMChunk2(currentDataView, elementType, channelCount);
                  const remainingDataView = offset < currentDataView.byteLength ? new MultiBufferDataView(currentDataView.buffers, currentDataView.byteOffset + offset) : null;
                  contents.forEach((content) => port.postMessage(content, content.map(({ buffer }) => buffer)));
                  if (pendingInvocations === 0 && (nativeMediaRecorder.state === "inactive" || isStopped)) {
                    encode(encoderId, null).then((arrayBuffers) => {
                      dispatchDataAvailableEvent([...bufferedArrayBuffers, ...arrayBuffers]);
                      bufferedArrayBuffers.length = 0;
                      eventTarget.dispatchEvent(new Event("stop"));
                    });
                    port.postMessage([]);
                    port.close();
                    removeEventListener();
                  }
                  return { dataView: remainingDataView, elementType: currentElementType, encoderId, port };
                });
              });
              if (timeslice !== void 0) {
                promisedDataViewElementTypeEncoderIdAndPort.then(({ encoderId }) => promisedPartialRecording = requestNextPartialRecording(encoderId, timeslice));
              }
            }
            nativeMediaRecorder.start(100);
          },
          stop
        };
      };
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/factories/window.js
var createWindow3;
var init_window5 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/factories/window.js"() {
    createWindow3 = () => typeof window === "undefined" ? null : window;
  }
});

// node_modules/extendable-media-recorder/build/es2019/functions/read-variable-size-integer-length.js
var readVariableSizeIntegerLength;
var init_read_variable_size_integer_length = __esm({
  "node_modules/extendable-media-recorder/build/es2019/functions/read-variable-size-integer-length.js"() {
    readVariableSizeIntegerLength = (dataView, offset) => {
      if (offset >= dataView.byteLength) {
        return null;
      }
      const byte = dataView.getUint8(offset);
      if (byte > 127) {
        return 1;
      }
      if (byte > 63) {
        return 2;
      }
      if (byte > 31) {
        return 3;
      }
      if (byte > 15) {
        return 4;
      }
      if (byte > 7) {
        return 5;
      }
      if (byte > 3) {
        return 6;
      }
      if (byte > 1) {
        return 7;
      }
      if (byte > 0) {
        return 8;
      }
      const length = readVariableSizeIntegerLength(dataView, offset + 1);
      return length === null ? null : length + 8;
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/functions/wrap-event-listener.js
var wrapEventListener2;
var init_wrap_event_listener2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/functions/wrap-event-listener.js"() {
    wrapEventListener2 = (target, eventListener) => {
      return (event) => {
        const descriptor = { value: target };
        Object.defineProperties(event, {
          currentTarget: descriptor,
          target: descriptor
        });
        if (typeof eventListener === "function") {
          return eventListener.call(target, event);
        }
        return eventListener.handleEvent.call(target, event);
      };
    };
  }
});

// node_modules/extendable-media-recorder/build/es2019/interfaces/audio-nodes-and-encoder-id.js
var init_audio_nodes_and_encoder_id = __esm({
  "node_modules/extendable-media-recorder/build/es2019/interfaces/audio-nodes-and-encoder-id.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/interfaces/blob-event.js
var init_blob_event = __esm({
  "node_modules/extendable-media-recorder/build/es2019/interfaces/blob-event.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/interfaces/blob-event-init.js
var init_blob_event_init = __esm({
  "node_modules/extendable-media-recorder/build/es2019/interfaces/blob-event-init.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/interfaces/event-target.js
var init_event_target2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/interfaces/event-target.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/interfaces/media-recorder.js
var init_media_recorder = __esm({
  "node_modules/extendable-media-recorder/build/es2019/interfaces/media-recorder.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/interfaces/media-recorder-constructor.js
var init_media_recorder_constructor2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/interfaces/media-recorder-constructor.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/interfaces/media-recorder-event-map.js
var init_media_recorder_event_map = __esm({
  "node_modules/extendable-media-recorder/build/es2019/interfaces/media-recorder-event-map.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/interfaces/media-recorder-options.js
var init_media_recorder_options = __esm({
  "node_modules/extendable-media-recorder/build/es2019/interfaces/media-recorder-options.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/interfaces/index.js
var init_interfaces9 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/interfaces/index.js"() {
    init_audio_nodes_and_encoder_id();
    init_blob_event();
    init_blob_event_init();
    init_event_target2();
    init_media_recorder();
    init_media_recorder_constructor2();
    init_media_recorder_event_map();
    init_media_recorder_options();
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/blob-event-constructor.js
var init_blob_event_constructor = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/blob-event-constructor.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/blob-event-handler.js
var init_blob_event_handler = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/blob-event-handler.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/blob-event-factory.js
var init_blob_event_factory2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/blob-event-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/blob-event-factory-factory.js
var init_blob_event_factory_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/blob-event-factory-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/decode-web-m-chunk-factory.js
var init_decode_web_m_chunk_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/decode-web-m-chunk-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/decode-web-m-chunk-function.js
var init_decode_web_m_chunk_function = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/decode-web-m-chunk-function.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/element-type.js
var init_element_type = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/element-type.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/error-event-handler.js
var init_error_event_handler2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/error-event-handler.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/event-handler.js
var init_event_handler3 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/event-handler.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/event-target-constructor.js
var init_event_target_constructor4 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/event-target-constructor.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/event-target-constructor-factory.js
var init_event_target_constructor_factory2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/event-target-constructor-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/event-target-factory.js
var init_event_target_factory2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/event-target-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/event-target-factory-factory.js
var init_event_target_factory_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/event-target-factory-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/invalid-modification-error-factory.js
var init_invalid_modification_error_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/invalid-modification-error-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/invalid-state-error-factory.js
var init_invalid_state_error_factory2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/invalid-state-error-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/is-supported-promise-factory.js
var init_is_supported_promise_factory2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/is-supported-promise-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/media-recorder-constructor-factory.js
var init_media_recorder_constructor_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/media-recorder-constructor-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/native-blob-event-factory.js
var init_native_blob_event_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/native-blob-event-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/native-event-target.js
var init_native_event_target2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/native-event-target.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/native-media-recorder-constructor-factory.js
var init_native_media_recorder_constructor_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/native-media-recorder-constructor-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/native-media-recorder-factory.js
var init_native_media_recorder_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/native-media-recorder-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/native-media-recorder-factory-factory.js
var init_native_media_recorder_factory_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/native-media-recorder-factory-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/not-supported-error-factory.js
var init_not_supported_error_factory2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/not-supported-error-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/promised-data-view-element-type-encoder-id-and-port.js
var init_promised_data_view_element_type_encoder_id_and_port = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/promised-data-view-element-type-encoder-id-and-port.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/read-element-content-factory.js
var init_read_element_content_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/read-element-content-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/read-element-content-function.js
var init_read_element_content_function = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/read-element-content-function.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/read-element-type-factory.js
var init_read_element_type_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/read-element-type-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/read-element-type-function.js
var init_read_element_type_function = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/read-element-type-function.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/read-variable-size-integer-factory.js
var init_read_variable_size_integer_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/read-variable-size-integer-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/read-variable-size-integer-function.js
var init_read_variable_size_integer_function = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/read-variable-size-integer-function.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/read-variable-size-integer-length-function.js
var init_read_variable_size_integer_length_function = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/read-variable-size-integer-length-function.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/recording-state.js
var init_recording_state = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/recording-state.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/web-audio-media-recorder-factory.js
var init_web_audio_media_recorder_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/web-audio-media-recorder-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/web-audio-media-recorder-factory-factory.js
var init_web_audio_media_recorder_factory_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/web-audio-media-recorder-factory-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/webm-pcm-media-recorder-factory.js
var init_webm_pcm_media_recorder_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/webm-pcm-media-recorder-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/webm-pcm-media-recorder-factory-factory.js
var init_webm_pcm_media_recorder_factory_factory = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/webm-pcm-media-recorder-factory-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/window.js
var init_window6 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/window.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/window-factory.js
var init_window_factory3 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/window-factory.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/wrap-event-listener-function.js
var init_wrap_event_listener_function2 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/wrap-event-listener-function.js"() {
  }
});

// node_modules/extendable-media-recorder/build/es2019/types/index.js
var init_types11 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/types/index.js"() {
    init_blob_event_constructor();
    init_blob_event_handler();
    init_blob_event_factory2();
    init_blob_event_factory_factory();
    init_decode_web_m_chunk_factory();
    init_decode_web_m_chunk_function();
    init_element_type();
    init_error_event_handler2();
    init_event_handler3();
    init_event_target_constructor4();
    init_event_target_constructor_factory2();
    init_event_target_factory2();
    init_event_target_factory_factory();
    init_invalid_modification_error_factory();
    init_invalid_state_error_factory2();
    init_is_supported_promise_factory2();
    init_media_recorder_constructor_factory();
    init_native_blob_event_factory();
    init_native_event_target2();
    init_native_media_recorder_constructor_factory();
    init_native_media_recorder_factory();
    init_native_media_recorder_factory_factory();
    init_not_supported_error_factory2();
    init_promised_data_view_element_type_encoder_id_and_port();
    init_read_element_content_factory();
    init_read_element_content_function();
    init_read_element_type_factory();
    init_read_element_type_function();
    init_read_variable_size_integer_factory();
    init_read_variable_size_integer_function();
    init_read_variable_size_integer_length_function();
    init_recording_state();
    init_web_audio_media_recorder_factory();
    init_web_audio_media_recorder_factory_factory();
    init_webm_pcm_media_recorder_factory();
    init_webm_pcm_media_recorder_factory_factory();
    init_window6();
    init_window_factory3();
    init_wrap_event_listener_function2();
  }
});

// node_modules/extendable-media-recorder/build/es2019/module.js
var module_exports = {};
__export(module_exports, {
  MediaRecorder: () => mediaRecorderConstructor,
  isSupported: () => isSupported2,
  register: () => register2
});
var encoderRegexes, window4, nativeBlobEventConstructor, createBlobEvent, createWebAudioMediaRecorder, readVariableSizeInteger, readElementContent, readElementType, decodeWebMChunk, createWebmPcmMediaRecorder, createEventTarget, nativeMediaRecorderConstructor, createNativeMediaRecorder, mediaRecorderConstructor, isSupported2, register2;
var init_module13 = __esm({
  "node_modules/extendable-media-recorder/build/es2019/module.js"() {
    init_module4();
    init_blob_event_factory();
    init_decode_web_m_chunk();
    init_event_target_constructor();
    init_event_target_factory();
    init_invalid_modification_error();
    init_invalid_state_error();
    init_is_supported_promise();
    init_media_recorder_constructor();
    init_native_blob_event_constructor();
    init_native_media_recorder();
    init_native_media_recorder_constructor();
    init_not_supported_error();
    init_read_element_content();
    init_read_element_type();
    init_read_variable_size_integer();
    init_web_audio_media_recorder();
    init_webm_pcm_media_recorder();
    init_window5();
    init_read_variable_size_integer_length();
    init_wrap_event_listener2();
    init_interfaces9();
    init_types11();
    encoderRegexes = [];
    window4 = createWindow3();
    nativeBlobEventConstructor = createNativeBlobEventConstructor(window4);
    createBlobEvent = createBlobEventFactory(nativeBlobEventConstructor);
    createWebAudioMediaRecorder = createWebAudioMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createInvalidStateError, createNotSupportedError);
    readVariableSizeInteger = createReadVariableSizeInteger(readVariableSizeIntegerLength);
    readElementContent = createReadElementContent(readVariableSizeInteger);
    readElementType = createReadElementType(readVariableSizeInteger);
    decodeWebMChunk = createDecodeWebMChunk(readElementContent, readElementType);
    createWebmPcmMediaRecorder = createWebmPcmMediaRecorderFactory(createBlobEvent, createInvalidModificationError, createNotSupportedError, decodeWebMChunk, readVariableSizeInteger);
    createEventTarget = createEventTargetFactory(window4);
    nativeMediaRecorderConstructor = createNativeMediaRecorderConstructor(window4);
    createNativeMediaRecorder = createNativeMediaRecorderFactory(createInvalidModificationError, createNotSupportedError);
    mediaRecorderConstructor = createMediaRecorderConstructor(createNativeMediaRecorder, createNotSupportedError, createWebAudioMediaRecorder, createWebmPcmMediaRecorder, encoderRegexes, createEventTargetConstructor(createEventTarget, wrapEventListener2), nativeMediaRecorderConstructor);
    isSupported2 = () => createIsSupportedPromise(window4);
    register2 = async (port) => {
      encoderRegexes.push(await register(port));
    };
  }
});

// node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/interfaces/extendable-media-recorder-wav-encoder-broker-definition.js
var init_extendable_media_recorder_wav_encoder_broker_definition = __esm({
  "node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/interfaces/extendable-media-recorder-wav-encoder-broker-definition.js"() {
  }
});

// node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/interfaces/index.js
var init_interfaces10 = __esm({
  "node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/interfaces/index.js"() {
    init_extendable_media_recorder_wav_encoder_broker_definition();
  }
});

// node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/types/extendable-media-recorder-wav-encoder-broker-loader.js
var init_extendable_media_recorder_wav_encoder_broker_loader = __esm({
  "node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/types/extendable-media-recorder-wav-encoder-broker-loader.js"() {
  }
});

// node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/types/extendable-media-recorder-wav-encoder-broker-wrapper.js
var init_extendable_media_recorder_wav_encoder_broker_wrapper = __esm({
  "node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/types/extendable-media-recorder-wav-encoder-broker-wrapper.js"() {
  }
});

// node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/types/typed-array.js
var init_typed_array2 = __esm({
  "node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/types/typed-array.js"() {
  }
});

// node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/types/index.js
var init_types12 = __esm({
  "node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/types/index.js"() {
    init_extendable_media_recorder_wav_encoder_broker_loader();
    init_extendable_media_recorder_wav_encoder_broker_wrapper();
    init_typed_array2();
  }
});

// node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/module.js
var wrap2, load2;
var init_module14 = __esm({
  "node_modules/extendable-media-recorder-wav-encoder-broker/build/es2019/module.js"() {
    init_module2();
    init_interfaces10();
    init_types12();
    wrap2 = createBroker({
      characterize: ({ call }) => {
        return () => call("characterize");
      },
      encode: ({ call }) => {
        return (recordingId, timeslice) => {
          return call("encode", { recordingId, timeslice });
        };
      },
      record: ({ call }) => {
        return async (recordingId, sampleRate, typedArrays) => {
          await call("record", { recordingId, sampleRate, typedArrays }, typedArrays.map(({ buffer }) => buffer).filter((buffer) => buffer instanceof ArrayBuffer));
        };
      }
    });
    load2 = (url4) => {
      const worker3 = new Worker(url4);
      return wrap2(worker3);
    };
  }
});

// node_modules/extendable-media-recorder-wav-encoder/build/es2019/worker/worker.js
var worker2;
var init_worker2 = __esm({
  "node_modules/extendable-media-recorder-wav-encoder/build/es2019/worker/worker.js"() {
    worker2 = `(()=>{var e={455(e,t){!function(e){"use strict";var t=function(e){return function(t){var r=e(t);return t.add(r),r}},r=function(e){return function(t,r){return e.set(t,r),r}},n=void 0===Number.MAX_SAFE_INTEGER?9007199254740991:Number.MAX_SAFE_INTEGER,s=536870912,a=2*s,o=function(e,t){return function(r){var o=t.get(r),i=void 0===o?r.size:o<a?o+1:0;if(!r.has(i))return e(r,i);if(r.size<s){for(;r.has(i);)i=Math.floor(Math.random()*a);return e(r,i)}if(r.size>n)throw new Error("Congratulations, you created a collection of unique numbers which uses all available integers!");for(;r.has(i);)i=Math.floor(Math.random()*n);return e(r,i)}},i=new WeakMap,c=r(i),l=o(c,i),u=t(l);e.addUniqueNumber=u,e.generateUniqueNumber=l}(t)}},t={};function r(n){var s=t[n];if(void 0!==s)return s.exports;var a=t[n]={exports:{}};return e[n].call(a.exports,a,a.exports,r),a.exports}(()=>{"use strict";const e=-32603,t=-32602,n=-32601,s=(e,t)=>Object.assign(new Error(e),{status:t}),a=t=>s('The handler of the method called "'.concat(t,'" returned an unexpected result.'),e),o=(t,r)=>async({data:{id:o,method:i,params:c}})=>{const l=r[i];try{if(void 0===l)throw(e=>s('The requested method called "'.concat(e,'" is not supported.'),n))(i);const r=void 0===c?l():l(c);if(void 0===r)throw(t=>s('The handler of the method called "'.concat(t,'" returned no required result.'),e))(i);const u=r instanceof Promise?await r:r;if(null===o){if(void 0!==u.result)throw a(i)}else{if(void 0===u.result)throw a(i);const{result:e,transferables:r=[]}=u;t.postMessage({id:o,result:e},r)}}catch(e){const{message:r,status:n=-32603}=e;t.postMessage({error:{code:n,message:r},id:o})}};var i=r(455);const c=new Map,l=(e,r,n)=>({...r,connect:({port:t})=>{t.start();const n=e(t,r),s=(0,i.generateUniqueNumber)(c);return c.set(s,()=>{n(),t.close(),c.delete(s)}),{result:s}},disconnect:({portId:e})=>{const r=c.get(e);if(void 0===r)throw(e=>s('The specified parameter called "portId" with the given value "'.concat(e,'" does not identify a port connected to this worker.'),t))(e);return r(),{result:null}},isSupported:async()=>{if(await new Promise(e=>{const t=new ArrayBuffer(0),{port1:r,port2:n}=new MessageChannel;r.onmessage=({data:t})=>e(null!==t),n.postMessage(t,[t])})){const e=n();return{result:e instanceof Promise?await e:e}}return{result:!1}}}),u=(e,t,r=()=>!0)=>{const n=l(u,t,r),s=o(e,n);return e.addEventListener("message",s),()=>e.removeEventListener("message",s)},d=e=>e.reduce((e,t)=>e+t.length,0),h=(e,t)=>{const r=[];let n=0;e:for(;n<t;){const t=e.length;for(let s=0;s<t;s+=1){const t=e[s];void 0===r[s]&&(r[s]=[]);const a=t.shift();if(void 0===a)break e;r[s].push(a),0===s&&(n+=a.length)}}if(n>t){const s=n-t;r.forEach((t,r)=>{const n=t.pop(),a=n.length-s;t.push(n.subarray(0,a)),e[r].unshift(n.subarray(a))})}return r},f=new Map,m=(e=>(t,r,n)=>{const s=e.get(t);if(void 0===s){const s={channelDataArrays:n.map(e=>[e]),isComplete:!0,sampleRate:r};return e.set(t,s),s}return s.channelDataArrays.forEach((e,t)=>e.push(n[t])),s})(f),p=((e,t)=>(r,n,s,a)=>{const o=s>>3,i="subsequent"===n?0:44,c=r.length,l=e(r[0]),u=new ArrayBuffer(l*c*o+i),d=new DataView(u);return"subsequent"!==n&&t(d,s,c,"complete"===n?l:Number.POSITIVE_INFINITY,a),r.forEach((e,t)=>{let r=i+t*o;e.forEach(e=>{const t=e.length;for(let n=0;n<t;n+=1){const t=e[n];d.setInt16(r,t<0?32768*Math.max(-1,t):32767*Math.min(1,t),!0),r+=c*o}})}),[u]})(d,(e,t,r,n,s)=>{const a=t>>3,o=Math.min(n*r*a,4294967251);e.setUint32(0,1380533830),e.setUint32(4,o+36,!0),e.setUint32(8,1463899717),e.setUint32(12,1718449184),e.setUint32(16,16,!0),e.setUint16(20,1,!0),e.setUint16(22,r,!0),e.setUint32(24,s,!0),e.setUint32(28,s*r*a,!0),e.setUint16(32,r*a,!0),e.setUint16(34,t,!0),e.setUint32(36,1684108385),e.setUint32(40,o,!0)}),v=new Map;u(self,{characterize:()=>({result:/^audio\\/wav$/}),encode:({recordingId:e,timeslice:t})=>{const r=v.get(e);void 0!==r&&(v.delete(e),r.reject(new Error("Another request was made to initiate an encoding.")));const n=f.get(e);if(null!==t){if(void 0===n||d(n.channelDataArrays[0])*(1e3/n.sampleRate)<t)return new Promise((r,n)=>{v.set(e,{reject:n,resolve:r,timeslice:t})});const r=h(n.channelDataArrays,Math.ceil(t*(n.sampleRate/1e3))),s=p(r,n.isComplete?"initial":"subsequent",16,n.sampleRate);return n.isComplete=!1,{result:s,transferables:s}}if(void 0!==n){const t=p(n.channelDataArrays,n.isComplete?"complete":"subsequent",16,n.sampleRate);return f.delete(e),{result:t,transferables:t}}return{result:[],transferables:[]}},record:({recordingId:e,sampleRate:t,typedArrays:r})=>{const n=m(e,t,r),s=v.get(e);if(void 0!==s&&d(n.channelDataArrays[0])*(1e3/t)>=s.timeslice){const r=h(n.channelDataArrays,Math.ceil(s.timeslice*(t/1e3))),a=p(r,n.isComplete?"initial":"subsequent",16,t);n.isComplete=!1,v.delete(e),s.resolve({result:a,transferables:a})}return{result:null}}})})()})();`;
  }
});

// node_modules/extendable-media-recorder-wav-encoder/build/es2019/module.js
var module_exports2 = {};
__export(module_exports2, {
  characterize: () => characterize,
  connect: () => connect2,
  disconnect: () => disconnect2,
  encode: () => encode2,
  isSupported: () => isSupported3,
  record: () => record2
});
var blob2, url3, extendableMediaRecorderWavEncoder, characterize, connect2, disconnect2, encode2, isSupported3, record2;
var init_module15 = __esm({
  "node_modules/extendable-media-recorder-wav-encoder/build/es2019/module.js"() {
    init_module14();
    init_worker2();
    blob2 = new Blob([worker2], { type: "application/javascript; charset=utf-8" });
    url3 = URL.createObjectURL(blob2);
    extendableMediaRecorderWavEncoder = load2(url3);
    characterize = extendableMediaRecorderWavEncoder.characterize;
    connect2 = extendableMediaRecorderWavEncoder.connect;
    disconnect2 = extendableMediaRecorderWavEncoder.disconnect;
    encode2 = extendableMediaRecorderWavEncoder.encode;
    isSupported3 = extendableMediaRecorderWavEncoder.isSupported;
    record2 = extendableMediaRecorderWavEncoder.record;
    URL.revokeObjectURL(url3);
  }
});

// node_modules/react-media-recorder/lib/index.js
var require_lib = __commonJS({
  "node_modules/react-media-recorder/lib/index.js"(exports) {
    "use strict";
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t2[0] & 1) throw t2[1];
        return t2[1];
      }, trys: [], ops: [] }, f, y, t2, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n2) {
        return function(v) {
          return step([n2, v]);
        };
      }
      function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
          if (f = 1, y && (t2 = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t2 = y["return"]) && t2.call(y), 0) : y.next) && !(t2 = t2.call(y, op[1])).done) return t2;
          if (y = 0, t2) op = [op[0] & 2, t2.value];
          switch (op[0]) {
            case 0:
            case 1:
              t2 = op;
              break;
            case 4:
              _.label++;
              return { value: op[1], done: false };
            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;
            case 7:
              op = _.ops.pop();
              _.trys.pop();
              continue;
            default:
              if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }
              if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
                _.label = op[1];
                break;
              }
              if (op[0] === 6 && _.label < t2[1]) {
                _.label = t2[1];
                t2 = op;
                break;
              }
              if (t2 && _.label < t2[2]) {
                _.label = t2[2];
                _.ops.push(op);
                break;
              }
              if (t2[2]) _.ops.pop();
              _.trys.pop();
              continue;
          }
          op = body.call(thisArg, _);
        } catch (e2) {
          op = [6, e2];
          y = 0;
        } finally {
          f = t2 = 0;
        }
        if (op[0] & 5) throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ReactMediaRecorder = exports.useReactMediaRecorder = exports.RecorderErrors = void 0;
    var extendable_media_recorder_1 = (init_module13(), __toCommonJS(module_exports));
    var react_1 = require_react();
    var extendable_media_recorder_wav_encoder_1 = (init_module15(), __toCommonJS(module_exports2));
    var RecorderErrors;
    (function(RecorderErrors2) {
      RecorderErrors2["AbortError"] = "media_aborted";
      RecorderErrors2["NotAllowedError"] = "permission_denied";
      RecorderErrors2["NotFoundError"] = "no_specified_media_found";
      RecorderErrors2["NotReadableError"] = "media_in_use";
      RecorderErrors2["OverconstrainedError"] = "invalid_media_constraints";
      RecorderErrors2["TypeError"] = "no_constraints";
      RecorderErrors2["NONE"] = "";
      RecorderErrors2["NO_RECORDER"] = "recorder_error";
    })(RecorderErrors = exports.RecorderErrors || (exports.RecorderErrors = {}));
    function useReactMediaRecorder2(_a13) {
      var _this = this;
      var _b = _a13.audio, audio = _b === void 0 ? true : _b, _c = _a13.video, video = _c === void 0 ? false : _c, _d = _a13.selfBrowserSurface, selfBrowserSurface = _d === void 0 ? void 0 : _d, _e = _a13.preferCurrentTab, preferCurrentTab = _e === void 0 ? false : _e, _f = _a13.onStop, onStop = _f === void 0 ? function() {
        return null;
      } : _f, _g = _a13.onStart, onStart = _g === void 0 ? function() {
        return null;
      } : _g, blobPropertyBag = _a13.blobPropertyBag, _h = _a13.screen, screen = _h === void 0 ? false : _h, _j = _a13.mediaRecorderOptions, mediaRecorderOptions = _j === void 0 ? void 0 : _j, _k = _a13.customMediaStream, customMediaStream = _k === void 0 ? null : _k, _l = _a13.stopStreamsOnStop, stopStreamsOnStop = _l === void 0 ? true : _l, _m = _a13.askPermissionOnMount, askPermissionOnMount = _m === void 0 ? false : _m;
      var mediaRecorder = (0, react_1.useRef)(null);
      var mediaChunks = (0, react_1.useRef)([]);
      var mediaStream = (0, react_1.useRef)(null);
      var _o = (0, react_1.useState)("idle"), status = _o[0], setStatus = _o[1];
      var _p = (0, react_1.useState)(false), isAudioMuted = _p[0], setIsAudioMuted = _p[1];
      var _q = (0, react_1.useState)(void 0), mediaBlobUrl = _q[0], setMediaBlobUrl = _q[1];
      var _r = (0, react_1.useState)("NONE"), error = _r[0], setError = _r[1];
      var _s = (0, react_1.useState)(false), init = _s[0], setInit = _s[1];
      (0, react_1.useEffect)(function() {
        if (init) {
          return;
        }
        var setup = function() {
          return __awaiter(_this, void 0, void 0, function() {
            var _a14, e_1;
            return __generator(this, function(_b2) {
              switch (_b2.label) {
                case 0:
                  _b2.trys.push([0, 3, , 4]);
                  _a14 = extendable_media_recorder_1.register;
                  return [4, (0, extendable_media_recorder_wav_encoder_1.connect)()];
                case 1:
                  return [4, _a14.apply(void 0, [_b2.sent()])];
                case 2:
                  _b2.sent();
                  return [3, 4];
                case 3:
                  e_1 = _b2.sent();
                  return [3, 4];
                case 4:
                  return [2];
              }
            });
          });
        };
        setup();
        setInit(true);
      }, []);
      var getMediaStream = (0, react_1.useCallback)(function() {
        return __awaiter(_this, void 0, void 0, function() {
          var requiredMedia, stream_1, audioStream, stream, error_1;
          return __generator(this, function(_a14) {
            switch (_a14.label) {
              case 0:
                setStatus("acquiring_media");
                requiredMedia = { audio: typeof audio === "boolean" ? !!audio : audio, video: typeof video === "boolean" ? !!video : video };
                _a14.label = 1;
              case 1:
                _a14.trys.push([1, 9, , 10]);
                if (!customMediaStream) return [3, 2];
                mediaStream.current = customMediaStream;
                return [3, 8];
              case 2:
                if (!screen) return [3, 6];
                return [4, window.navigator.mediaDevices.getDisplayMedia({ video: video || true, selfBrowserSurface, preferCurrentTab })];
              case 3:
                stream_1 = _a14.sent();
                stream_1.getVideoTracks()[0].addEventListener("ended", function() {
                  stopRecording();
                });
                if (!audio) return [3, 5];
                return [4, window.navigator.mediaDevices.getUserMedia({ audio })];
              case 4:
                audioStream = _a14.sent();
                audioStream.getAudioTracks().forEach(function(audioTrack) {
                  return stream_1.addTrack(audioTrack);
                });
                _a14.label = 5;
              case 5:
                mediaStream.current = stream_1;
                return [3, 8];
              case 6:
                return [4, window.navigator.mediaDevices.getUserMedia(requiredMedia)];
              case 7:
                stream = _a14.sent();
                mediaStream.current = stream;
                _a14.label = 8;
              case 8:
                setStatus("idle");
                return [3, 10];
              case 9:
                error_1 = _a14.sent();
                setError(error_1.name);
                setStatus("idle");
                return [3, 10];
              case 10:
                return [2];
            }
          });
        });
      }, [audio, video, screen]);
      (0, react_1.useEffect)(function() {
        if (!window.MediaRecorder) {
          throw new Error("Unsupported Browser");
        }
        if (screen) {
          if (!window.navigator.mediaDevices.getDisplayMedia) {
            throw new Error("This browser doesn't support screen capturing");
          }
        }
        var checkConstraints = function(mediaType) {
          var supportedMediaConstraints = navigator.mediaDevices.getSupportedConstraints();
          var unSupportedConstraints = Object.keys(mediaType).filter(function(constraint) {
            return !supportedMediaConstraints[constraint];
          });
          if (unSupportedConstraints.length > 0) {
            console.error("The constraints " + unSupportedConstraints.join(",") + " doesn't support on this browser. Please check your ReactMediaRecorder component.");
          }
        };
        if (typeof audio === "object") {
          checkConstraints(audio);
        }
        if (typeof video === "object") {
          checkConstraints(video);
        }
        if (mediaRecorderOptions && mediaRecorderOptions.mimeType) {
          if (!MediaRecorder.isTypeSupported(mediaRecorderOptions.mimeType)) {
            console.error("The specified MIME type you supplied for MediaRecorder doesn't support this browser");
          }
        }
        if (!mediaStream.current && askPermissionOnMount) {
          getMediaStream();
        }
        return function() {
          if (mediaStream.current) {
            var tracks = mediaStream.current.getTracks();
            tracks.forEach(function(track) {
              return track.clone().stop();
            });
          }
        };
      }, [audio, screen, video, getMediaStream, mediaRecorderOptions, askPermissionOnMount]);
      var startRecording = function() {
        return __awaiter(_this, void 0, void 0, function() {
          var isStreamEnded;
          return __generator(this, function(_a14) {
            switch (_a14.label) {
              case 0:
                setError("NONE");
                if (!!mediaStream.current) return [3, 2];
                return [4, getMediaStream()];
              case 1:
                _a14.sent();
                _a14.label = 2;
              case 2:
                if (!mediaStream.current) return [3, 5];
                isStreamEnded = mediaStream.current.getTracks().some(function(track) {
                  return track.readyState === "ended";
                });
                if (!isStreamEnded) return [3, 4];
                return [4, getMediaStream()];
              case 3:
                _a14.sent();
                _a14.label = 4;
              case 4:
                if (!mediaStream.current.active) {
                  return [2];
                }
                mediaRecorder.current = new extendable_media_recorder_1.MediaRecorder(mediaStream.current, mediaRecorderOptions || void 0);
                mediaRecorder.current.ondataavailable = onRecordingActive;
                mediaRecorder.current.onstop = onRecordingStop;
                mediaRecorder.current.onstart = onRecordingStart;
                mediaRecorder.current.onerror = function() {
                  setError("NO_RECORDER");
                  setStatus("idle");
                };
                mediaRecorder.current.start();
                setStatus("recording");
                _a14.label = 5;
              case 5:
                return [2];
            }
          });
        });
      };
      var onRecordingActive = function(_a14) {
        var data = _a14.data;
        mediaChunks.current.push(data);
      };
      var onRecordingStart = function() {
        onStart();
      };
      var onRecordingStop = function() {
        var chunk = mediaChunks.current[0];
        var blobProperty = Object.assign({ type: chunk.type }, blobPropertyBag || (video ? { type: "video/mp4" } : { type: "audio/wav" }));
        var blob3 = new Blob(mediaChunks.current, blobProperty);
        var url4 = URL.createObjectURL(blob3);
        setStatus("stopped");
        setMediaBlobUrl(url4);
        onStop(url4, blob3);
      };
      var muteAudio = function(mute) {
        setIsAudioMuted(mute);
        if (mediaStream.current) {
          mediaStream.current.getAudioTracks().forEach(function(audioTrack) {
            return audioTrack.enabled = !mute;
          });
        }
      };
      var pauseRecording = function() {
        if (mediaRecorder.current && mediaRecorder.current.state === "recording") {
          setStatus("paused");
          mediaRecorder.current.pause();
        }
      };
      var resumeRecording = function() {
        if (mediaRecorder.current && mediaRecorder.current.state === "paused") {
          setStatus("recording");
          mediaRecorder.current.resume();
        }
      };
      var stopRecording = function() {
        if (mediaRecorder.current) {
          if (mediaRecorder.current.state !== "inactive") {
            setStatus("stopping");
            mediaRecorder.current.stop();
            if (stopStreamsOnStop) {
              mediaStream.current && mediaStream.current.getTracks().forEach(function(track) {
                return track.stop();
              });
            }
            mediaChunks.current = [];
          }
        }
      };
      return { error: RecorderErrors[error], muteAudio: function() {
        return muteAudio(true);
      }, unMuteAudio: function() {
        return muteAudio(false);
      }, startRecording, pauseRecording, resumeRecording, stopRecording, mediaBlobUrl, status, isAudioMuted, previewStream: mediaStream.current ? new MediaStream(mediaStream.current.getVideoTracks()) : null, previewAudioStream: mediaStream.current ? new MediaStream(mediaStream.current.getAudioTracks()) : null, clearBlobUrl: function() {
        if (mediaBlobUrl) {
          URL.revokeObjectURL(mediaBlobUrl);
        }
        setMediaBlobUrl(void 0);
        setStatus("idle");
      } };
    }
    exports.useReactMediaRecorder = useReactMediaRecorder2;
    var ReactMediaRecorder = function(props) {
      return props.render(useReactMediaRecorder2(props));
    };
    exports.ReactMediaRecorder = ReactMediaRecorder;
  }
});

// node_modules/react-media-recorder/index.js
var require_react_media_recorder = __commonJS({
  "node_modules/react-media-recorder/index.js"(exports, module) {
    module.exports = require_lib();
  }
});

// node_modules/fast-equals/dist/es/index.mjs
var { getOwnPropertyNames, getOwnPropertySymbols } = Object;
var { hasOwnProperty } = Object.prototype;
function combineComparators(comparatorA, comparatorB) {
  return function isEqual(a, b, state) {
    return comparatorA(a, b, state) && comparatorB(a, b, state);
  };
}
function createIsCircular(areItemsEqual) {
  return function isCircular(a, b, state) {
    if (!a || !b || typeof a !== "object" || typeof b !== "object") {
      return areItemsEqual(a, b, state);
    }
    const { cache: cache3 } = state;
    const cachedA = cache3.get(a);
    const cachedB = cache3.get(b);
    if (cachedA && cachedB) {
      return cachedA === b && cachedB === a;
    }
    cache3.set(a, b);
    cache3.set(b, a);
    const result = areItemsEqual(a, b, state);
    cache3.delete(a);
    cache3.delete(b);
    return result;
  };
}
function getShortTag(value) {
  return value != null ? value[Symbol.toStringTag] : void 0;
}
function getStrictProperties(object3) {
  return getOwnPropertyNames(object3).concat(getOwnPropertySymbols(object3));
}
var hasOwn = (
  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
  Object.hasOwn || ((object3, property) => hasOwnProperty.call(object3, property))
);
function sameValueZeroEqual(a, b) {
  return a === b || !a && !b && a !== a && b !== b;
}
var PREACT_VNODE = "__v";
var PREACT_OWNER = "__o";
var REACT_OWNER = "_owner";
var { getOwnPropertyDescriptor, keys } = Object;
function areArrayBuffersEqual(a, b) {
  return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a), new Uint8Array(b));
}
function areArraysEqual(a, b, state) {
  let index = a.length;
  if (b.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!state.equals(a[index], b[index], index, index, a, b, state)) {
      return false;
    }
  }
  return true;
}
function areDataViewsEqual(a, b) {
  return a.byteLength === b.byteLength && areTypedArraysEqual(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength));
}
function areDatesEqual(a, b) {
  return sameValueZeroEqual(a.getTime(), b.getTime());
}
function areErrorsEqual(a, b) {
  return a.name === b.name && a.message === b.message && a.cause === b.cause && a.stack === b.stack;
}
function areFunctionsEqual(a, b) {
  return a === b;
}
function areMapsEqual(a, b, state) {
  const size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  const matchedIndices = new Array(size);
  const aIterable = a.entries();
  let aResult;
  let bResult;
  let index = 0;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    const bIterable = b.entries();
    let hasMatch = false;
    let matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (matchedIndices[matchIndex]) {
        matchIndex++;
        continue;
      }
      const aEntry = aResult.value;
      const bEntry = bResult.value;
      if (state.equals(aEntry[0], bEntry[0], index, matchIndex, a, b, state) && state.equals(aEntry[1], bEntry[1], aEntry[0], bEntry[0], a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
    index++;
  }
  return true;
}
var areNumbersEqual = sameValueZeroEqual;
function areObjectsEqual(a, b, state) {
  const properties = keys(a);
  let index = properties.length;
  if (keys(b).length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!isPropertyEqual(a, b, state, properties[index])) {
      return false;
    }
  }
  return true;
}
function areObjectsEqualStrict(a, b, state) {
  const properties = getStrictProperties(a);
  let index = properties.length;
  if (getStrictProperties(b).length !== index) {
    return false;
  }
  let property;
  let descriptorA;
  let descriptorB;
  while (index-- > 0) {
    property = properties[index];
    if (!isPropertyEqual(a, b, state, property)) {
      return false;
    }
    descriptorA = getOwnPropertyDescriptor(a, property);
    descriptorB = getOwnPropertyDescriptor(b, property);
    if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {
      return false;
    }
  }
  return true;
}
function arePrimitiveWrappersEqual(a, b) {
  return sameValueZeroEqual(a.valueOf(), b.valueOf());
}
function areRegExpsEqual(a, b) {
  return a.source === b.source && a.flags === b.flags;
}
function areSetsEqual(a, b, state) {
  const size = a.size;
  if (size !== b.size) {
    return false;
  }
  if (!size) {
    return true;
  }
  const matchedIndices = new Array(size);
  const aIterable = a.values();
  let aResult;
  let bResult;
  while (aResult = aIterable.next()) {
    if (aResult.done) {
      break;
    }
    const bIterable = b.values();
    let hasMatch = false;
    let matchIndex = 0;
    while (bResult = bIterable.next()) {
      if (bResult.done) {
        break;
      }
      if (!matchedIndices[matchIndex] && state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state)) {
        hasMatch = matchedIndices[matchIndex] = true;
        break;
      }
      matchIndex++;
    }
    if (!hasMatch) {
      return false;
    }
  }
  return true;
}
function areTypedArraysEqual(a, b) {
  let index = a.byteLength;
  if (b.byteLength !== index || a.byteOffset !== b.byteOffset) {
    return false;
  }
  while (index-- > 0) {
    if (a[index] !== b[index]) {
      return false;
    }
  }
  return true;
}
function areUrlsEqual(a, b) {
  return a.hostname === b.hostname && a.pathname === b.pathname && a.protocol === b.protocol && a.port === b.port && a.hash === b.hash && a.username === b.username && a.password === b.password;
}
function isPropertyEqual(a, b, state, property) {
  if ((property === REACT_OWNER || property === PREACT_OWNER || property === PREACT_VNODE) && (a.$$typeof || b.$$typeof)) {
    return true;
  }
  return hasOwn(b, property) && state.equals(a[property], b[property], property, property, a, b, state);
}
var ARRAY_BUFFER_TAG = "[object ArrayBuffer]";
var ARGUMENTS_TAG = "[object Arguments]";
var BOOLEAN_TAG = "[object Boolean]";
var DATA_VIEW_TAG = "[object DataView]";
var DATE_TAG = "[object Date]";
var ERROR_TAG = "[object Error]";
var MAP_TAG = "[object Map]";
var NUMBER_TAG = "[object Number]";
var OBJECT_TAG = "[object Object]";
var REG_EXP_TAG = "[object RegExp]";
var SET_TAG = "[object Set]";
var STRING_TAG = "[object String]";
var TYPED_ARRAY_TAGS = {
  "[object Int8Array]": true,
  "[object Uint8Array]": true,
  "[object Uint8ClampedArray]": true,
  "[object Int16Array]": true,
  "[object Uint16Array]": true,
  "[object Int32Array]": true,
  "[object Uint32Array]": true,
  "[object Float16Array]": true,
  "[object Float32Array]": true,
  "[object Float64Array]": true,
  "[object BigInt64Array]": true,
  "[object BigUint64Array]": true
};
var URL_TAG = "[object URL]";
var toString = Object.prototype.toString;
function createEqualityComparator({ areArrayBuffersEqual: areArrayBuffersEqual2, areArraysEqual: areArraysEqual2, areDataViewsEqual: areDataViewsEqual2, areDatesEqual: areDatesEqual2, areErrorsEqual: areErrorsEqual2, areFunctionsEqual: areFunctionsEqual2, areMapsEqual: areMapsEqual2, areNumbersEqual: areNumbersEqual2, areObjectsEqual: areObjectsEqual2, arePrimitiveWrappersEqual: arePrimitiveWrappersEqual2, areRegExpsEqual: areRegExpsEqual2, areSetsEqual: areSetsEqual2, areTypedArraysEqual: areTypedArraysEqual2, areUrlsEqual: areUrlsEqual2, unknownTagComparators }) {
  return function comparator(a, b, state) {
    if (a === b) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    const type = typeof a;
    if (type !== typeof b) {
      return false;
    }
    if (type !== "object") {
      if (type === "number") {
        return areNumbersEqual2(a, b, state);
      }
      if (type === "function") {
        return areFunctionsEqual2(a, b, state);
      }
      return false;
    }
    const constructor = a.constructor;
    if (constructor !== b.constructor) {
      return false;
    }
    if (constructor === Object) {
      return areObjectsEqual2(a, b, state);
    }
    if (Array.isArray(a)) {
      return areArraysEqual2(a, b, state);
    }
    if (constructor === Date) {
      return areDatesEqual2(a, b, state);
    }
    if (constructor === RegExp) {
      return areRegExpsEqual2(a, b, state);
    }
    if (constructor === Map) {
      return areMapsEqual2(a, b, state);
    }
    if (constructor === Set) {
      return areSetsEqual2(a, b, state);
    }
    const tag = toString.call(a);
    if (tag === DATE_TAG) {
      return areDatesEqual2(a, b, state);
    }
    if (tag === REG_EXP_TAG) {
      return areRegExpsEqual2(a, b, state);
    }
    if (tag === MAP_TAG) {
      return areMapsEqual2(a, b, state);
    }
    if (tag === SET_TAG) {
      return areSetsEqual2(a, b, state);
    }
    if (tag === OBJECT_TAG) {
      return typeof a.then !== "function" && typeof b.then !== "function" && areObjectsEqual2(a, b, state);
    }
    if (tag === URL_TAG) {
      return areUrlsEqual2(a, b, state);
    }
    if (tag === ERROR_TAG) {
      return areErrorsEqual2(a, b, state);
    }
    if (tag === ARGUMENTS_TAG) {
      return areObjectsEqual2(a, b, state);
    }
    if (TYPED_ARRAY_TAGS[tag]) {
      return areTypedArraysEqual2(a, b, state);
    }
    if (tag === ARRAY_BUFFER_TAG) {
      return areArrayBuffersEqual2(a, b, state);
    }
    if (tag === DATA_VIEW_TAG) {
      return areDataViewsEqual2(a, b, state);
    }
    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {
      return arePrimitiveWrappersEqual2(a, b, state);
    }
    if (unknownTagComparators) {
      let unknownTagComparator = unknownTagComparators[tag];
      if (!unknownTagComparator) {
        const shortTag = getShortTag(a);
        if (shortTag) {
          unknownTagComparator = unknownTagComparators[shortTag];
        }
      }
      if (unknownTagComparator) {
        return unknownTagComparator(a, b, state);
      }
    }
    return false;
  };
}
function createEqualityComparatorConfig({ circular, createCustomConfig, strict }) {
  let config2 = {
    areArrayBuffersEqual,
    areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,
    areDataViewsEqual,
    areDatesEqual,
    areErrorsEqual,
    areFunctionsEqual,
    areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,
    areNumbersEqual,
    areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,
    arePrimitiveWrappersEqual,
    areRegExpsEqual,
    areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,
    areTypedArraysEqual: strict ? combineComparators(areTypedArraysEqual, areObjectsEqualStrict) : areTypedArraysEqual,
    areUrlsEqual,
    unknownTagComparators: void 0
  };
  if (createCustomConfig) {
    config2 = Object.assign({}, config2, createCustomConfig(config2));
  }
  if (circular) {
    const areArraysEqual2 = createIsCircular(config2.areArraysEqual);
    const areMapsEqual2 = createIsCircular(config2.areMapsEqual);
    const areObjectsEqual2 = createIsCircular(config2.areObjectsEqual);
    const areSetsEqual2 = createIsCircular(config2.areSetsEqual);
    config2 = Object.assign({}, config2, {
      areArraysEqual: areArraysEqual2,
      areMapsEqual: areMapsEqual2,
      areObjectsEqual: areObjectsEqual2,
      areSetsEqual: areSetsEqual2
    });
  }
  return config2;
}
function createInternalEqualityComparator(compare) {
  return function(a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {
    return compare(a, b, state);
  };
}
function createIsEqual({ circular, comparator, createState, equals, strict }) {
  if (createState) {
    return function isEqual(a, b) {
      const { cache: cache3 = circular ? /* @__PURE__ */ new WeakMap() : void 0, meta } = createState();
      return comparator(a, b, {
        cache: cache3,
        equals,
        meta,
        strict
      });
    };
  }
  if (circular) {
    return function isEqual(a, b) {
      return comparator(a, b, {
        cache: /* @__PURE__ */ new WeakMap(),
        equals,
        meta: void 0,
        strict
      });
    };
  }
  const state = {
    cache: void 0,
    equals,
    meta: void 0,
    strict
  };
  return function isEqual(a, b) {
    return comparator(a, b, state);
  };
}
var deepEqual = createCustomEqual();
var strictDeepEqual = createCustomEqual({ strict: true });
var circularDeepEqual = createCustomEqual({ circular: true });
var strictCircularDeepEqual = createCustomEqual({
  circular: true,
  strict: true
});
var shallowEqual = createCustomEqual({
  createInternalComparator: () => sameValueZeroEqual
});
var strictShallowEqual = createCustomEqual({
  strict: true,
  createInternalComparator: () => sameValueZeroEqual
});
var circularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: () => sameValueZeroEqual
});
var strictCircularShallowEqual = createCustomEqual({
  circular: true,
  createInternalComparator: () => sameValueZeroEqual,
  strict: true
});
function createCustomEqual(options = {}) {
  const { circular = false, createInternalComparator: createCustomInternalComparator, createState, strict = false } = options;
  const config2 = createEqualityComparatorConfig(options);
  const comparator = createEqualityComparator(config2);
  const equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);
  return createIsEqual({ circular, comparator, createState, equals, strict });
}

// node_modules/@tambo-ai/react/esm/hooks/use-component-state.js
var import_react9 = __toESM(require_react());

// node_modules/use-debounce/dist/index.module.js
var import_react = __toESM(require_react());
function c(e2, u2, c2, i) {
  var l = this, a = (0, import_react.useRef)(null), o = (0, import_react.useRef)(0), f = (0, import_react.useRef)(0), v = (0, import_react.useRef)(null), d = (0, import_react.useRef)([]), m = (0, import_react.useRef)(), s = (0, import_react.useRef)(), g = (0, import_react.useRef)(e2), h = (0, import_react.useRef)(true), x = (0, import_react.useRef)(), E = (0, import_react.useRef)();
  g.current = e2;
  var b = "undefined" != typeof window, p = !u2 && 0 !== u2 && b;
  if ("function" != typeof e2) throw new TypeError("Expected a function");
  u2 = +u2 || 0;
  var y = !!(c2 = c2 || {}).leading, w = !("trailing" in c2) || !!c2.trailing, O = !!c2.flushOnExit && w, F = "maxWait" in c2, L = "debounceOnServer" in c2 && !!c2.debounceOnServer, A = F ? Math.max(+c2.maxWait || 0, u2) : null, D = (0, import_react.useMemo)(function() {
    var r2 = function(r3) {
      var n3 = d.current, t3 = m.current;
      return d.current = m.current = null, o.current = r3, f.current = f.current || r3, s.current = g.current.apply(t3, n3);
    }, n2 = function(r3, n3) {
      p && cancelAnimationFrame(v.current), v.current = p ? requestAnimationFrame(r3) : setTimeout(r3, n3);
    }, t2 = function(r3) {
      if (!h.current) return false;
      var n3 = r3 - a.current;
      return !a.current || n3 >= u2 || n3 < 0 || F && r3 - o.current >= A;
    }, e3 = function(n3) {
      return v.current = null, w && d.current ? r2(n3) : (d.current = m.current = null, s.current);
    }, c3 = function r3() {
      var c4 = Date.now();
      if (y && f.current === o.current && D2(), t2(c4)) return e3(c4);
      if (h.current) {
        var i2 = u2 - (c4 - a.current), l2 = F ? Math.min(i2, A - (c4 - o.current)) : i2;
        n2(r3, l2);
      }
    }, D2 = function() {
      i && i({});
    }, S = function() {
      if (b || L) {
        var e4, i2 = Date.now(), f2 = t2(i2);
        if (d.current = [].slice.call(arguments), m.current = l, a.current = i2, O && !x.current && (x.current = function() {
          var r3;
          "hidden" === (null == (r3 = global.document) ? void 0 : r3.visibilityState) && E.current.flush();
        }, null == (e4 = global.document) || null == e4.addEventListener || e4.addEventListener("visibilitychange", x.current)), f2) {
          if (!v.current && h.current) return o.current = a.current, n2(c3, u2), y ? r2(a.current) : s.current;
          if (F) return n2(c3, u2), r2(a.current);
        }
        return v.current || n2(c3, u2), s.current;
      }
    };
    return S.cancel = function() {
      var r3 = v.current;
      r3 && (p ? cancelAnimationFrame(v.current) : clearTimeout(v.current)), o.current = 0, d.current = a.current = m.current = v.current = null, r3 && i && i({});
    }, S.isPending = function() {
      return !!v.current;
    }, S.flush = function() {
      return v.current ? e3(Date.now()) : s.current;
    }, S;
  }, [y, F, u2, A, w, O, p, b, L, i]);
  return E.current = D, (0, import_react.useEffect)(function() {
    return h.current = true, function() {
      var r2;
      O && E.current.flush(), x.current && (null == (r2 = global.document) || null == r2.removeEventListener || r2.removeEventListener("visibilitychange", x.current), x.current = null), h.current = false;
    };
  }, [O]), D;
}

// node_modules/@tambo-ai/react/esm/providers/tambo-interactable-provider.js
var import_react7 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/context-helpers/current-interactables-context-helper.js
var createInteractablesContextHelper = (components) => {
  return () => {
    if (!Array.isArray(components) || components.length === 0) {
      return null;
    }
    return {
      components: components.map((component) => {
        if (typeof component !== "object" || component === null) {
          return {
            id: "unknown",
            componentName: "unknown",
            description: "invalid component",
            props: void 0,
            propsSchema: "Not specified",
            state: void 0,
            isSelectedForInteraction: false,
            stateSchema: "Not specified"
          };
        }
        const comp = component;
        return {
          id: String(comp.id ?? "unknown"),
          componentName: String(comp.name ?? "unknown"),
          description: String(comp.description ?? ""),
          props: comp.props,
          propsSchema: comp.propsSchema ? "Available - use component-specific update tools" : "Not specified",
          state: comp.state,
          isSelectedForInteraction: comp.isSelectedForInteraction ?? false,
          stateSchema: comp.stateSchema ? "Available - use component-specific update tools" : "Not specified"
        };
      })
    };
  };
};

// node_modules/zod/v4/classic/external.js
var external_exports2 = {};
__export(external_exports2, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodFile: () => ZodFile,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  _ZodString: () => _ZodString,
  _default: () => _default,
  any: () => any,
  array: () => array,
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  catch: () => _catch,
  check: () => check,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  clone: () => clone,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports,
  cuid: () => cuid,
  cuid2: () => cuid2,
  custom: () => custom,
  date: () => date2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  endsWith: () => _endsWith,
  enum: () => _enum,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null2,
  nullable: () => nullable,
  nullish: () => nullish,
  number: () => number,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid,
  undefined: () => _undefined2,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  uuid: () => uuid,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid
});

// node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date,
  datetime: () => datetime,
  duration: () => duration,
  time: () => time
});
var ZodISODateTime = $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/zod/v4/classic/errors.js
var initializer = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue) => inst.issues.push(issue)
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => inst.issues.push(...issues2)
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer);
var ZodRealError = $constructor("ZodError", initializer, {
  Parent: Error
});

// node_modules/zod/v4/classic/parse.js
var parse2 = _parse(ZodRealError);
var parseAsync2 = _parseAsync(ZodRealError);
var safeParse2 = _safeParse(ZodRealError);
var safeParseAsync2 = _safeParseAsync(ZodRealError);

// node_modules/zod/v4/classic/schemas.js
var ZodType = $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  inst.def = def;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      var _a13;
      return (_a13 = globalRegistry.get(inst)) == null ? void 0 : _a13.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  return inst;
});
var _ZodString = $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
});
var ZodString = $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime(params));
  inst.date = (params) => inst.check(date(params));
  inst.time = (params) => inst.check(time(params));
  inst.duration = (params) => inst.check(duration(params));
});
function string(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
var ZodEmoji = $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji(params) {
  return _emoji(ZodEmoji, params);
}
var ZodNanoID = $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid2(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv4(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodIPv6 = $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv6(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv4(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv6(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e164(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
var ZodNumber = $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
});
function boolean(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
});
function _undefined2(params) {
  return _undefined(ZodUndefined, params);
}
var ZodNull = $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
});
function _null2(params) {
  return _null(ZodNull, params);
}
var ZodAny = $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c2 = inst._zod.bag;
  inst.minDate = c2.minimum ? new Date(c2.minimum) : null;
  inst.maxDate = c2.maximum ? new Date(c2.maximum) : null;
});
function date2(params) {
  return _date(ZodDate, params);
}
var ZodArray = $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return literal(Object.keys(shape));
}
var ZodObject = $constructor("ZodObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
  inst.keyof = () => _enum(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    get shape() {
      util_exports.assignProp(this, "shape", { ...shape });
      return this.shape;
    },
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion = $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord = $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType: union([keyType, never()]),
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap = $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet = $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum = $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys2 = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys2.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys2.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.addIssue = (issue) => {
      if (typeof issue === "string") {
        payload.issues.push(util_exports.issue(issue, payload.value, def));
      } else {
        const _issue = issue;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        _issue.continue ?? (_issue.continue = true);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodPrefault = $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : defaultValue;
    }
  });
}
var ZodNonOptional = $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodReadonly = $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy = $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodCustom = $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  const ch = check((payload) => {
    payload.addIssue = (issue) => {
      if (typeof issue === "string") {
        payload.issues.push(util_exports.issue(issue, payload.value, ch._zod.def));
      } else {
        const _issue = issue;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Pipe: ZodPipe,
  Boolean: ZodBoolean,
  String: ZodString,
  Transform: ZodTransform
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string(params), number(), boolean(), _null2(), array(jsonSchema), record(string(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}

// node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint2,
  boolean: () => boolean2,
  date: () => date3,
  number: () => number2,
  string: () => string2
});
function string2(params) {
  return _coercedString(ZodString, params);
}
function number2(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean2(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint2(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date3(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/zod/v4/classic/external.js
config(en_default());

// node_modules/@tambo-ai/react/esm/schema/json-schema.js
var jsonSchemaType = external_exports2.union([
  external_exports2.literal("object"),
  external_exports2.literal("array"),
  external_exports2.literal("string"),
  external_exports2.literal("number"),
  external_exports2.literal("integer"),
  external_exports2.literal("boolean"),
  external_exports2.literal("null"),
  external_exports2.array(external_exports2.union([
    external_exports2.literal("object"),
    external_exports2.literal("array"),
    external_exports2.literal("string"),
    external_exports2.literal("number"),
    external_exports2.literal("integer"),
    external_exports2.literal("boolean"),
    external_exports2.literal("null")
  ]))
]);
var jsonSchemaTopLevel = external_exports2.looseObject({
  type: jsonSchemaType.optional(),
  properties: external_exports2.record(external_exports2.string(), external_exports2.unknown()).optional(),
  items: external_exports2.union([external_exports2.array(external_exports2.unknown()), external_exports2.unknown()]).optional(),
  required: external_exports2.array(external_exports2.string()).optional(),
  additionalProperties: external_exports2.union([external_exports2.boolean(), external_exports2.unknown()]).optional(),
  enum: external_exports2.array(external_exports2.unknown()).optional(),
  const: external_exports2.unknown().optional(),
  $ref: external_exports2.string().optional(),
  $id: external_exports2.string().optional(),
  $schema: external_exports2.string().optional(),
  title: external_exports2.string().optional(),
  description: external_exports2.string().optional()
}).refine((value) => {
  return value.type !== void 0 || value.properties !== void 0 || value.items !== void 0 || value.enum !== void 0 || value.const !== void 0 || value.$ref !== void 0;
});
function looksLikeJSONSchema(obj) {
  if (obj === null || typeof obj !== "object") {
    return false;
  }
  return jsonSchemaTopLevel.safeParse(obj).success;
}
function makeJsonSchemaPartial(schema) {
  const { required: _required, ...rest } = schema;
  return rest;
}

// node_modules/@tambo-ai/react/esm/schema/standard-schema.js
function isStandardSchema(obj) {
  if (typeof obj !== "object" || obj === null) {
    return false;
  }
  if (!("~standard" in obj)) {
    return false;
  }
  const standard = obj["~standard"];
  if (typeof standard !== "object" || standard === null) {
    return false;
  }
  return "version" in standard && standard.version === 1 && "vendor" in standard && typeof standard.vendor === "string" && "validate" in standard && typeof standard.validate === "function";
}

// node_modules/@tambo-ai/react/esm/schema/schema.js
loadVendor("zod", (schema) => {
  if (schema && typeof schema === "object" && "_zod" in schema) {
    return toJSONSchema(schema);
  }
  return zodToJsonSchema(schema);
});
function schemaToJsonSchema(schema) {
  if (!isStandardSchema(schema)) {
    return schema;
  }
  return toJsonSchema.sync(schema);
}
function createParametersFromSchema(schema) {
  const properties = schema.properties ?? {};
  return Object.entries(properties).map(([key, propSchema]) => ({
    name: key,
    type: propSchema && typeof propSchema === "object" && "type" in propSchema ? propSchema.type : "object",
    description: propSchema && typeof propSchema === "object" && "description" in propSchema ? propSchema.description ?? "" : "",
    isRequired: Array.isArray(schema.required) ? schema.required.includes(key) : false,
    schema: typeof propSchema === "object" && propSchema !== null ? propSchema : {}
  }));
}
function getParametersFromToolSchema(tool) {
  const schema = tool.inputSchema;
  let jsonSchema;
  if (looksLikeJSONSchema(schema)) {
    jsonSchema = schema;
  } else if (isStandardSchema(schema)) {
    jsonSchema = schemaToJsonSchema(schema);
  } else {
    console.warn("Unknown inputSchema type, returning empty parameters");
    return [];
  }
  return createParametersFromSchema(jsonSchema);
}

// node_modules/@tambo-ai/react/esm/schema/validate.js
function isRecordJsonSchema(schema) {
  return schema.type === "object" && typeof schema.additionalProperties === "object" && schema.additionalProperties !== null;
}
function assertNoRecordInJsonSchema(schema, path2, contextName) {
  if (isRecordJsonSchema(schema)) {
    const joined = path2.length ? path2.join(".") : "(root)";
    throw new Error(`Record types (objects with dynamic keys) are not supported in ${contextName}. Found at path "${joined}". Replace it with an object using explicit keys.`);
  }
  if (schema.properties) {
    for (const [key, propSchema] of Object.entries(schema.properties)) {
      if (typeof propSchema === "object" && propSchema !== null) {
        assertNoRecordInJsonSchema(propSchema, [...path2, key], contextName);
      }
    }
  }
  if (typeof schema.additionalProperties === "object" && schema.additionalProperties !== null) {
    assertNoRecordInJsonSchema(schema.additionalProperties, [...path2, "[*]"], contextName);
  }
  if (schema.items) {
    if (Array.isArray(schema.items)) {
      schema.items.forEach((itemSchema, index) => {
        if (typeof itemSchema === "object" && itemSchema !== null) {
          assertNoRecordInJsonSchema(itemSchema, [...path2, `${index}`], contextName);
        }
      });
    } else if (typeof schema.items === "object") {
      assertNoRecordInJsonSchema(schema.items, [...path2, "[]"], contextName);
    }
  }
  const prefixItems = schema.prefixItems;
  if (Array.isArray(prefixItems)) {
    prefixItems.forEach((itemSchema, index) => {
      if (typeof itemSchema === "object" && itemSchema !== null) {
        assertNoRecordInJsonSchema(itemSchema, [...path2, `${index}`], contextName);
      }
    });
  }
  if (schema.allOf) {
    schema.allOf.forEach((subSchema, index) => {
      if (typeof subSchema === "object" && subSchema !== null) {
        assertNoRecordInJsonSchema(subSchema, [...path2, `&${index}`], contextName);
      }
    });
  }
  if (schema.anyOf) {
    schema.anyOf.forEach((subSchema, index) => {
      if (typeof subSchema === "object" && subSchema !== null) {
        assertNoRecordInJsonSchema(subSchema, [...path2, `|${index}`], contextName);
      }
    });
  }
  if (schema.oneOf) {
    schema.oneOf.forEach((subSchema, index) => {
      if (typeof subSchema === "object" && subSchema !== null) {
        assertNoRecordInJsonSchema(subSchema, [...path2, `|${index}`], contextName);
      }
    });
  }
  if (typeof schema.not === "object" && schema.not !== null) {
    assertNoRecordInJsonSchema(schema.not, [...path2, "!"], contextName);
  }
  if (typeof schema.if === "object" && schema.if !== null) {
    assertNoRecordInJsonSchema(schema.if, [...path2, "if"], contextName);
  }
  if (typeof schema.then === "object" && schema.then !== null) {
    assertNoRecordInJsonSchema(schema.then, [...path2, "then"], contextName);
  }
  if (typeof schema.else === "object" && schema.else !== null) {
    assertNoRecordInJsonSchema(schema.else, [...path2, "else"], contextName);
  }
}
function assertNoRecordSchema(schema, contextName = "schema") {
  if (!schema) {
    return;
  }
  let jsonSchema;
  try {
    if (isStandardSchema(schema)) {
      const converted = schemaToJsonSchema(schema);
      if (!converted || Object.keys(converted).length === 0) {
        return;
      }
      jsonSchema = converted;
    } else if (typeof schema === "object" && schema !== null && "type" in schema) {
      jsonSchema = schema;
    } else {
      return;
    }
  } catch {
    return;
  }
  assertNoRecordInJsonSchema(jsonSchema, [], contextName);
}

// node_modules/@tambo-ai/react/esm/util/validate-component-name.js
function assertValidName(name, contextName) {
  if (!/^[a-zA-Z0-9_-]+$/.test(name)) {
    throw new Error(`${contextName} "${name}" must only contain letters, numbers, underscores, and hyphens.`);
  }
}

// node_modules/@tambo-ai/react/esm/providers/tambo-component-provider.js
var import_react5 = __toESM(require_react());

// node_modules/@tambo-ai/typescript-sdk/internal/tslib.mjs
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

// node_modules/@tambo-ai/typescript-sdk/internal/utils/uuid.mjs
var uuid4 = function() {
  const { crypto: crypto3 } = globalThis;
  if (crypto3 == null ? void 0 : crypto3.randomUUID) {
    uuid4 = crypto3.randomUUID.bind(crypto3);
    return crypto3.randomUUID();
  }
  const u8 = new Uint8Array(1);
  const randomByte = crypto3 ? () => crypto3.getRandomValues(u8)[0] : () => Math.random() * 255 & 255;
  return "10000000-1000-4000-8000-100000000000".replace(/[018]/g, (c2) => (+c2 ^ randomByte() & 15 >> +c2 / 4).toString(16));
};

// node_modules/@tambo-ai/typescript-sdk/internal/errors.mjs
function isAbortError(err) {
  return typeof err === "object" && err !== null && // Spec-compliant fetch implementations
  ("name" in err && err.name === "AbortError" || // Expo fetch
  "message" in err && String(err.message).includes("FetchRequestCanceledException"));
}
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  if (typeof err === "object" && err !== null) {
    try {
      if (Object.prototype.toString.call(err) === "[object Error]") {
        const error = new Error(err.message, err.cause ? { cause: err.cause } : {});
        if (err.stack)
          error.stack = err.stack;
        if (err.cause && !error.cause)
          error.cause = err.cause;
        if (err.name)
          error.name = err.name;
        return error;
      }
    } catch {
    }
    try {
      return new Error(JSON.stringify(err));
    } catch {
    }
  }
  return new Error(err);
};

// node_modules/@tambo-ai/typescript-sdk/core/error.mjs
var TamboAIError = class extends Error {
};
var APIError = class _APIError extends TamboAIError {
  constructor(status, error, message, headers) {
    super(`${_APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.error = error;
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status || !headers) {
      return new APIConnectionError({ message, cause: castToError(errorResponse) });
    }
    const error = errorResponse;
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new _APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message ?? "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
};
var AuthenticationError = class extends APIError {
};
var PermissionDeniedError = class extends APIError {
};
var NotFoundError = class extends APIError {
};
var ConflictError = class extends APIError {
};
var UnprocessableEntityError = class extends APIError {
};
var RateLimitError = class extends APIError {
};
var InternalServerError = class extends APIError {
};

// node_modules/@tambo-ai/typescript-sdk/internal/utils/values.mjs
var startsWithSchemeRegexp = /^[a-z][a-z0-9+.-]*:/i;
var isAbsoluteURL = (url4) => {
  return startsWithSchemeRegexp.test(url4);
};
var isArray = (val) => (isArray = Array.isArray, isArray(val));
var isReadonlyArray = isArray;
function maybeObj(x) {
  if (typeof x !== "object") {
    return {};
  }
  return x ?? {};
}
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn2(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var validatePositiveInteger = (name, n2) => {
  if (typeof n2 !== "number" || !Number.isInteger(n2)) {
    throw new TamboAIError(`${name} must be an integer`);
  }
  if (n2 < 0) {
    throw new TamboAIError(`${name} must be a positive integer`);
  }
  return n2;
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};

// node_modules/@tambo-ai/typescript-sdk/internal/utils/sleep.mjs
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// node_modules/@tambo-ai/typescript-sdk/version.mjs
var VERSION = "0.84.0";

// node_modules/@tambo-ai/typescript-sdk/internal/detect-platform.mjs
function getDetectedPlatform() {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return "deno";
  }
  if (typeof EdgeRuntime !== "undefined") {
    return "edge";
  }
  if (Object.prototype.toString.call(typeof globalThis.process !== "undefined" ? globalThis.process : 0) === "[object process]") {
    return "node";
  }
  return "unknown";
}
var getPlatformProperties = () => {
  var _a13;
  const detectedPlatform = getDetectedPlatform();
  if (detectedPlatform === "deno") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": typeof Deno.version === "string" ? Deno.version : ((_a13 = Deno.version) == null ? void 0 : _a13.deno) ?? "unknown"
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": globalThis.process.version
    };
  }
  if (detectedPlatform === "node") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(globalThis.process.platform ?? "unknown"),
      "X-Stainless-Arch": normalizeArch(globalThis.process.arch ?? "unknown"),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": globalThis.process.version ?? "unknown"
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch2 = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch2}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders ?? (_platformHeaders = getPlatformProperties());
};

// node_modules/@tambo-ai/typescript-sdk/internal/shims.mjs
function getDefaultFetch() {
  if (typeof fetch !== "undefined") {
    return fetch;
  }
  throw new Error("`fetch` is not defined as a global; Either pass `fetch` to the client, `new TamboAI({ fetch })` or polyfill the global, `globalThis.fetch = fetch`");
}
function makeReadableStream(...args) {
  const ReadableStream = globalThis.ReadableStream;
  if (typeof ReadableStream === "undefined") {
    throw new Error("`ReadableStream` is not defined as a global; You will need to polyfill it, `globalThis.ReadableStream = ReadableStream`");
  }
  return new ReadableStream(...args);
}
function ReadableStreamFrom(iterable) {
  let iter = Symbol.asyncIterator in iterable ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();
  return makeReadableStream({
    start() {
    },
    async pull(controller) {
      const { done, value } = await iter.next();
      if (done) {
        controller.close();
      } else {
        controller.enqueue(value);
      }
    },
    async cancel() {
      var _a13;
      await ((_a13 = iter.return) == null ? void 0 : _a13.call(iter));
    }
  });
}
function ReadableStreamToAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e2) {
        reader.releaseLock();
        throw e2;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}
async function CancelReadableStream(stream) {
  var _a13, _b;
  if (stream === null || typeof stream !== "object")
    return;
  if (stream[Symbol.asyncIterator]) {
    await ((_b = (_a13 = stream[Symbol.asyncIterator]()).return) == null ? void 0 : _b.call(_a13));
    return;
  }
  const reader = stream.getReader();
  const cancelPromise = reader.cancel();
  reader.releaseLock();
  await cancelPromise;
}

// node_modules/@tambo-ai/typescript-sdk/internal/request-options.mjs
var FallbackEncoder = ({ headers, body }) => {
  return {
    bodyHeaders: {
      "content-type": "application/json"
    },
    body: JSON.stringify(body)
  };
};

// node_modules/@tambo-ai/typescript-sdk/internal/utils/bytes.mjs
function concatBytes(buffers) {
  let length = 0;
  for (const buffer of buffers) {
    length += buffer.length;
  }
  const output = new Uint8Array(length);
  let index = 0;
  for (const buffer of buffers) {
    output.set(buffer, index);
    index += buffer.length;
  }
  return output;
}
var encodeUTF8_;
function encodeUTF8(str) {
  let encoder;
  return (encodeUTF8_ ?? (encoder = new globalThis.TextEncoder(), encodeUTF8_ = encoder.encode.bind(encoder)))(str);
}
var decodeUTF8_;
function decodeUTF8(bytes) {
  let decoder;
  return (decodeUTF8_ ?? (decoder = new globalThis.TextDecoder(), decodeUTF8_ = decoder.decode.bind(decoder)))(bytes);
}

// node_modules/@tambo-ai/typescript-sdk/internal/decoders/line.mjs
var _LineDecoder_buffer;
var _LineDecoder_carriageReturnIndex;
var LineDecoder = class {
  constructor() {
    _LineDecoder_buffer.set(this, void 0);
    _LineDecoder_carriageReturnIndex.set(this, void 0);
    __classPrivateFieldSet(this, _LineDecoder_buffer, new Uint8Array(), "f");
    __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
  }
  decode(chunk) {
    if (chunk == null) {
      return [];
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    __classPrivateFieldSet(this, _LineDecoder_buffer, concatBytes([__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), binaryChunk]), "f");
    const lines = [];
    let patternIndex;
    while ((patternIndex = findNewlineIndex(__classPrivateFieldGet(this, _LineDecoder_buffer, "f"), __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f"))) != null) {
      if (patternIndex.carriage && __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") == null) {
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, patternIndex.index, "f");
        continue;
      }
      if (__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") != null && (patternIndex.index !== __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") + 1 || patternIndex.carriage)) {
        lines.push(decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") - 1)));
        __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(__classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f")), "f");
        __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
        continue;
      }
      const endIndex = __classPrivateFieldGet(this, _LineDecoder_carriageReturnIndex, "f") !== null ? patternIndex.preceding - 1 : patternIndex.preceding;
      const line = decodeUTF8(__classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(0, endIndex));
      lines.push(line);
      __classPrivateFieldSet(this, _LineDecoder_buffer, __classPrivateFieldGet(this, _LineDecoder_buffer, "f").subarray(patternIndex.index), "f");
      __classPrivateFieldSet(this, _LineDecoder_carriageReturnIndex, null, "f");
    }
    return lines;
  }
  flush() {
    if (!__classPrivateFieldGet(this, _LineDecoder_buffer, "f").length) {
      return [];
    }
    return this.decode("\n");
  }
};
_LineDecoder_buffer = /* @__PURE__ */ new WeakMap(), _LineDecoder_carriageReturnIndex = /* @__PURE__ */ new WeakMap();
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r]/g;
function findNewlineIndex(buffer, startIndex) {
  const newline = 10;
  const carriage = 13;
  for (let i = startIndex ?? 0; i < buffer.length; i++) {
    if (buffer[i] === newline) {
      return { preceding: i, index: i + 1, carriage: false };
    }
    if (buffer[i] === carriage) {
      return { preceding: i, index: i + 1, carriage: true };
    }
  }
  return null;
}
function findDoubleNewlineIndex(buffer) {
  const newline = 10;
  const carriage = 13;
  for (let i = 0; i < buffer.length - 1; i++) {
    if (buffer[i] === newline && buffer[i + 1] === newline) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === carriage) {
      return i + 2;
    }
    if (buffer[i] === carriage && buffer[i + 1] === newline && i + 3 < buffer.length && buffer[i + 2] === carriage && buffer[i + 3] === newline) {
      return i + 4;
    }
  }
  return -1;
}

// node_modules/@tambo-ai/typescript-sdk/internal/utils/log.mjs
var levelNumbers = {
  off: 0,
  error: 200,
  warn: 300,
  info: 400,
  debug: 500
};
var parseLogLevel = (maybeLevel, sourceName, client) => {
  if (!maybeLevel) {
    return void 0;
  }
  if (hasOwn2(levelNumbers, maybeLevel)) {
    return maybeLevel;
  }
  loggerFor(client).warn(`${sourceName} was set to ${JSON.stringify(maybeLevel)}, expected one of ${JSON.stringify(Object.keys(levelNumbers))}`);
  return void 0;
};
function noop() {
}
function makeLogFn(fnLevel, logger, logLevel) {
  if (!logger || levelNumbers[fnLevel] > levelNumbers[logLevel]) {
    return noop;
  } else {
    return logger[fnLevel].bind(logger);
  }
}
var noopLogger = {
  error: noop,
  warn: noop,
  info: noop,
  debug: noop
};
var cachedLoggers = /* @__PURE__ */ new WeakMap();
function loggerFor(client) {
  const logger = client.logger;
  const logLevel = client.logLevel ?? "off";
  if (!logger) {
    return noopLogger;
  }
  const cachedLogger = cachedLoggers.get(logger);
  if (cachedLogger && cachedLogger[0] === logLevel) {
    return cachedLogger[1];
  }
  const levelLogger = {
    error: makeLogFn("error", logger, logLevel),
    warn: makeLogFn("warn", logger, logLevel),
    info: makeLogFn("info", logger, logLevel),
    debug: makeLogFn("debug", logger, logLevel)
  };
  cachedLoggers.set(logger, [logLevel, levelLogger]);
  return levelLogger;
}
var formatRequestDetails = (details) => {
  if (details.options) {
    details.options = { ...details.options };
    delete details.options["headers"];
  }
  if (details.headers) {
    details.headers = Object.fromEntries((details.headers instanceof Headers ? [...details.headers] : Object.entries(details.headers)).map(([name, value]) => [
      name,
      name.toLowerCase() === "x-api-key" || name.toLowerCase() === "authorization" || name.toLowerCase() === "cookie" || name.toLowerCase() === "set-cookie" ? "***" : value
    ]));
  }
  if ("retryOfRequestLogID" in details) {
    if (details.retryOfRequestLogID) {
      details.retryOf = details.retryOfRequestLogID;
    }
    delete details.retryOfRequestLogID;
  }
  return details;
};

// node_modules/@tambo-ai/typescript-sdk/core/streaming.mjs
var _Stream_client;
var Stream = class _Stream {
  constructor(iterator, controller, client) {
    this.iterator = iterator;
    _Stream_client.set(this, void 0);
    this.controller = controller;
    __classPrivateFieldSet(this, _Stream_client, client, "f");
  }
  static fromSSEResponse(response, controller, client) {
    let consumed = false;
    const logger = client ? loggerFor(client) : console;
    async function* iterator() {
      if (consumed) {
        throw new TamboAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of _iterSSEMessages(response, controller)) {
          try {
            yield JSON.parse(sse.data);
          } catch (e2) {
            logger.error(`Could not parse message into JSON:`, sse.data);
            logger.error(`From chunk:`, sse.raw);
            throw e2;
          }
        }
        done = true;
      } catch (e2) {
        if (isAbortError(e2))
          return;
        throw e2;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller, client) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = ReadableStreamToAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new TamboAIError("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e2) {
        if (isAbortError(e2))
          return;
        throw e2;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new _Stream(iterator, controller, client);
  }
  [(_Stream_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new _Stream(() => teeIterator(left), this.controller, __classPrivateFieldGet(this, _Stream_client, "f")),
      new _Stream(() => teeIterator(right), this.controller, __classPrivateFieldGet(this, _Stream_client, "f"))
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self = this;
    let iter;
    return makeReadableStream({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encodeUTF8(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a13;
        await ((_a13 = iter.return) == null ? void 0 : _a13.call(iter));
      }
    });
  }
};
async function* _iterSSEMessages(response, controller) {
  if (!response.body) {
    controller.abort();
    if (typeof globalThis.navigator !== "undefined" && globalThis.navigator.product === "ReactNative") {
      throw new TamboAIError(`The default react-native fetch implementation does not support streaming. Please use expo/fetch: https://docs.expo.dev/versions/latest/sdk/expo/#expofetch-api`);
    }
    throw new TamboAIError(`Attempted to iterate over a response with no body`);
  }
  const sseDecoder = new SSEDecoder();
  const lineDecoder = new LineDecoder();
  const iter = ReadableStreamToAsyncIterable(response.body);
  for await (const sseChunk of iterSSEChunks(iter)) {
    for (const line of lineDecoder.decode(sseChunk)) {
      const sse = sseDecoder.decode(line);
      if (sse)
        yield sse;
    }
  }
  for (const line of lineDecoder.flush()) {
    const sse = sseDecoder.decode(line);
    if (sse)
      yield sse;
  }
}
async function* iterSSEChunks(iterator) {
  let data = new Uint8Array();
  for await (const chunk of iterator) {
    if (chunk == null) {
      continue;
    }
    const binaryChunk = chunk instanceof ArrayBuffer ? new Uint8Array(chunk) : typeof chunk === "string" ? encodeUTF8(chunk) : chunk;
    let newData = new Uint8Array(data.length + binaryChunk.length);
    newData.set(data);
    newData.set(binaryChunk, data.length);
    data = newData;
    let patternIndex;
    while ((patternIndex = findDoubleNewlineIndex(data)) !== -1) {
      yield data.slice(0, patternIndex);
      data = data.slice(patternIndex);
    }
  }
  if (data.length > 0) {
    yield data;
  }
}
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}

// node_modules/@tambo-ai/typescript-sdk/internal/parse.mjs
async function defaultParseResponse(client, props) {
  const { response, requestLogID, retryOfRequestLogID, startTime } = props;
  const body = await (async () => {
    var _a13;
    if (props.options.stream) {
      loggerFor(client).debug("response", response.status, response.url, response.headers, response.body);
      if (props.options.__streamClass) {
        return props.options.__streamClass.fromSSEResponse(response, props.controller, client);
      }
      return Stream.fromSSEResponse(response, props.controller, client);
    }
    if (response.status === 204) {
      return null;
    }
    if (props.options.__binaryResponse) {
      return response;
    }
    const contentType = response.headers.get("content-type");
    const mediaType = (_a13 = contentType == null ? void 0 : contentType.split(";")[0]) == null ? void 0 : _a13.trim();
    const isJSON = (mediaType == null ? void 0 : mediaType.includes("application/json")) || (mediaType == null ? void 0 : mediaType.endsWith("+json"));
    if (isJSON) {
      const json2 = await response.json();
      return json2;
    }
    const text = await response.text();
    return text;
  })();
  loggerFor(client).debug(`[${requestLogID}] response parsed`, formatRequestDetails({
    retryOfRequestLogID,
    url: response.url,
    status: response.status,
    body,
    durationMs: Date.now() - startTime
  }));
  return body;
}

// node_modules/@tambo-ai/typescript-sdk/core/api-promise.mjs
var _APIPromise_client;
var APIPromise = class _APIPromise extends Promise {
  constructor(client, responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
    _APIPromise_client.set(this, void 0);
    __classPrivateFieldSet(this, _APIPromise_client, client, "f");
  }
  _thenUnwrap(transform2) {
    return new _APIPromise(__classPrivateFieldGet(this, _APIPromise_client, "f"), this.responsePromise, async (client, props) => transform2(await this.parseResponse(client, props), props));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *  Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` or add `"lib": ["DOM"]`
   * to your `tsconfig.json`.
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then((data) => this.parseResponse(__classPrivateFieldGet(this, _APIPromise_client, "f"), data));
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
_APIPromise_client = /* @__PURE__ */ new WeakMap();

// node_modules/@tambo-ai/typescript-sdk/core/pagination.mjs
var _AbstractPage_client;
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageRequestOptions() != null;
  }
  async getNextPage() {
    const nextOptions = this.nextPageRequestOptions();
    if (!nextOptions) {
      throw new TamboAIError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page) {
    super(client, request, async (client2, props) => new Page(client2, props.response, await defaultParseResponse(client2, props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var OffsetAndLimit = class extends AbstractPage {
  constructor(client, response, body, options) {
    super(client, response, body, options);
    this.items = body.items || [];
    this.total = body.total || 0;
    this.count = body.count || 0;
  }
  getPaginatedItems() {
    return this.items ?? [];
  }
  nextPageRequestOptions() {
    const offset = this.options.query.offset ?? 0;
    const length = this.getPaginatedItems().length;
    const currentCount = offset + length;
    const totalCount = this.total;
    if (!totalCount) {
      return null;
    }
    if (currentCount < totalCount) {
      return {
        ...this.options,
        query: {
          ...maybeObj(this.options.query),
          offset: currentCount
        }
      };
    }
    return null;
  }
};

// node_modules/@tambo-ai/typescript-sdk/internal/uploads.mjs
var checkFileSupport = () => {
  var _a13;
  if (typeof File === "undefined") {
    const { process: process2 } = globalThis;
    const isOldNode = typeof ((_a13 = process2 == null ? void 0 : process2.versions) == null ? void 0 : _a13.node) === "string" && parseInt(process2.versions.node.split(".")) < 20;
    throw new Error("`File` is not defined as a global, which is required for file uploads." + (isOldNode ? " Update to Node 20 LTS or newer, or set `globalThis.File` to `import('node:buffer').File`." : ""));
  }
};
function makeFile(fileBits, fileName, options) {
  checkFileSupport();
  return new File(fileBits, fileName ?? "unknown_file", options);
}
function getName(value) {
  return (typeof value === "object" && value !== null && ("name" in value && value.name && String(value.name) || "url" in value && value.url && String(value.url) || "filename" in value && value.filename && String(value.filename) || "path" in value && value.path && String(value.path)) || "").split(/[\\/]/).pop() || void 0;
}
var isAsyncIterable = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var multipartFormRequestOptions = async (opts, fetch2) => {
  return { ...opts, body: await createForm(opts.body, fetch2) };
};
var supportsFormDataMap = /* @__PURE__ */ new WeakMap();
function supportsFormData(fetchObject) {
  const fetch2 = typeof fetchObject === "function" ? fetchObject : fetchObject.fetch;
  const cached = supportsFormDataMap.get(fetch2);
  if (cached)
    return cached;
  const promise2 = (async () => {
    try {
      const FetchResponse = "Response" in fetch2 ? fetch2.Response : (await fetch2("data:,")).constructor;
      const data = new FormData();
      if (data.toString() === await new FetchResponse(data).text()) {
        return false;
      }
      return true;
    } catch {
      return true;
    }
  })();
  supportsFormDataMap.set(fetch2, promise2);
  return promise2;
}
var createForm = async (body, fetch2) => {
  if (!await supportsFormData(fetch2)) {
    throw new TypeError("The provided fetch function does not support file uploads with the current global FormData class.");
  }
  const form = new FormData();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var isNamedBlob = (value) => value instanceof Blob && "name" in value;
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (value instanceof Response) {
    form.append(key, makeFile([await value.blob()], getName(value)));
  } else if (isAsyncIterable(value)) {
    form.append(key, makeFile([await new Response(ReadableStreamFrom(value)).blob()], getName(value)));
  } else if (isNamedBlob(value)) {
    form.append(key, value, getName(value));
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/@tambo-ai/typescript-sdk/internal/to-file.mjs
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
async function toFile(value, name, options) {
  checkFileSupport();
  value = await value;
  if (isFileLike(value)) {
    if (value instanceof File) {
      return value;
    }
    return makeFile([await value.arrayBuffer()], value.name);
  }
  if (isResponseLike(value)) {
    const blob3 = await value.blob();
    name || (name = new URL(value.url).pathname.split(/[\\/]/).pop());
    return makeFile(await getBytes(blob3), name, options);
  }
  const parts = await getBytes(value);
  name || (name = getName(value));
  if (!(options == null ? void 0 : options.type)) {
    const type = parts.find((part) => typeof part === "object" && "type" in part && part.type);
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return makeFile(parts, name, options);
}
async function getBytes(value) {
  var _a13;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(value instanceof Blob ? value : await value.arrayBuffer());
  } else if (isAsyncIterable(value)) {
    for await (const chunk of value) {
      parts.push(...await getBytes(chunk));
    }
  } else {
    const constructor = (_a13 = value == null ? void 0 : value.constructor) == null ? void 0 : _a13.name;
    throw new Error(`Unexpected data type: ${typeof value}${constructor ? `; constructor: ${constructor}` : ""}${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  if (typeof value !== "object" || value === null)
    return "";
  const props = Object.getOwnPropertyNames(value);
  return `; props: [${props.map((p) => `"${p}"`).join(", ")}]`;
}

// node_modules/@tambo-ai/typescript-sdk/core/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/@tambo-ai/typescript-sdk/resources/beta/audio.mjs
var Audio = class extends APIResource {
  /**
   * Upload an audio file and get its transcription. Supports MP3, WAV, MP4, MPEG,
   * MPGA, M4A, and WEBM formats. Maximum file size is 25 MB.
   *
   * @example
   * ```ts
   * const response = await client.beta.audio.transcribe({
   *   file: fs.createReadStream('path/to/file'),
   * });
   * ```
   */
  transcribe(body, options) {
    return this._client.post("/audio/transcribe", multipartFormRequestOptions({ body, ...options }, this._client));
  }
};

// node_modules/@tambo-ai/typescript-sdk/internal/headers.mjs
var brand_privateNullableHeaders = Symbol("brand.privateNullableHeaders");
function* iterateHeaders(headers) {
  if (!headers)
    return;
  if (brand_privateNullableHeaders in headers) {
    const { values, nulls } = headers;
    yield* values.entries();
    for (const name of nulls) {
      yield [name, null];
    }
    return;
  }
  let shouldClear = false;
  let iter;
  if (headers instanceof Headers) {
    iter = headers.entries();
  } else if (isReadonlyArray(headers)) {
    iter = headers;
  } else {
    shouldClear = true;
    iter = Object.entries(headers ?? {});
  }
  for (let row of iter) {
    const name = row[0];
    if (typeof name !== "string")
      throw new TypeError("expected header name to be a string");
    const values = isReadonlyArray(row[1]) ? row[1] : [row[1]];
    let didClear = false;
    for (const value of values) {
      if (value === void 0)
        continue;
      if (shouldClear && !didClear) {
        didClear = true;
        yield [name, null];
      }
      yield [name, value];
    }
  }
}
var buildHeaders = (newHeaders) => {
  const targetHeaders = new Headers();
  const nullHeaders = /* @__PURE__ */ new Set();
  for (const headers of newHeaders) {
    const seenHeaders = /* @__PURE__ */ new Set();
    for (const [name, value] of iterateHeaders(headers)) {
      const lowerName = name.toLowerCase();
      if (!seenHeaders.has(lowerName)) {
        targetHeaders.delete(name);
        seenHeaders.add(lowerName);
      }
      if (value === null) {
        targetHeaders.delete(name);
        nullHeaders.add(lowerName);
      } else {
        targetHeaders.append(name, value);
        nullHeaders.delete(lowerName);
      }
    }
  }
  return { [brand_privateNullableHeaders]: true, values: targetHeaders, nulls: nullHeaders };
};

// node_modules/@tambo-ai/typescript-sdk/resources/beta/auth.mjs
var Auth = class extends APIResource {
  /**
   * Creates a JWT MCP access token for the project. If threadId is provided, the
   * token will be bound to that thread. If threadId is omitted, a sessionless token
   * will be created using the provided contextKey (or from Bearer token if not
   * provided). Sessionless tokens can only access resources and prompts, not
   * session-specific features. The token expires in 15 minutes and can be used as a
   * bearer token.
   *
   * @example
   * ```ts
   * const response = await client.beta.auth.getMcpToken();
   * ```
   */
  getMcpToken(body, options) {
    return this._client.post("/auth/mcp/access-token", { body, ...options });
  }
  /**
   * Exchanges an OAuth subject token for a Tambo access token following RFC 6749 and
   * RFC 8693 specifications. Accepts form-encoded data and validates the subject
   * token based on project OAuth validation settings.
   *
   * @example
   * ```ts
   * const response = await client.beta.auth.getToken({
   *   grant_type:
   *     'urn:ietf:params:oauth:grant-type:token-exchange',
   *   subject_token:
   *     'eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCIsImtpZCI6IjEyMzQ1Njc4OTAifQ...',
   *   subject_token_type:
   *     'urn:ietf:params:oauth:token-type:id_token',
   * });
   * ```
   */
  getToken(body, options) {
    return this._client.post("/oauth/token", {
      body,
      ...options,
      headers: buildHeaders([{ "Content-Type": "application/x-www-form-urlencoded" }, options == null ? void 0 : options.headers])
    });
  }
};

// node_modules/@tambo-ai/typescript-sdk/internal/utils/path.mjs
function encodeURIPath(str) {
  return str.replace(/[^A-Za-z0-9\-._~!$&'()*+,;=:@]+/g, encodeURIComponent);
}
var EMPTY = Object.freeze(/* @__PURE__ */ Object.create(null));
var createPathTagFunction = (pathEncoder = encodeURIPath) => function path2(statics, ...params) {
  if (statics.length === 1)
    return statics[0];
  let postPath = false;
  const invalidSegments = [];
  const path3 = statics.reduce((previousValue, currentValue, index) => {
    var _a13;
    if (/[?#]/.test(currentValue)) {
      postPath = true;
    }
    const value = params[index];
    let encoded = (postPath ? encodeURIComponent : pathEncoder)("" + value);
    if (index !== params.length && (value == null || typeof value === "object" && // handle values from other realms
    value.toString === ((_a13 = Object.getPrototypeOf(Object.getPrototypeOf(value.hasOwnProperty ?? EMPTY) ?? EMPTY)) == null ? void 0 : _a13.toString))) {
      encoded = value + "";
      invalidSegments.push({
        start: previousValue.length + currentValue.length,
        length: encoded.length,
        error: `Value of type ${Object.prototype.toString.call(value).slice(8, -1)} is not a valid path parameter`
      });
    }
    return previousValue + currentValue + (index === params.length ? "" : encoded);
  }, "");
  const pathOnly = path3.split(/[?#]/, 1)[0];
  const invalidSegmentPattern = new RegExp("(?<=^|\\/)(?:\\.|%2e){1,2}(?=\\/|$)", "gi");
  let match;
  while ((match = invalidSegmentPattern.exec(pathOnly)) !== null) {
    invalidSegments.push({
      start: match.index,
      length: match[0].length,
      error: `Value "${match[0]}" can't be safely passed as a path parameter`
    });
  }
  invalidSegments.sort((a, b) => a.start - b.start);
  if (invalidSegments.length > 0) {
    let lastEnd = 0;
    const underline = invalidSegments.reduce((acc, segment) => {
      const spaces = " ".repeat(segment.start - lastEnd);
      const arrows = "^".repeat(segment.length);
      lastEnd = segment.start + segment.length;
      return acc + spaces + arrows;
    }, "");
    throw new TamboAIError(`Path parameters result in path with invalid segments:
${invalidSegments.map((e2) => e2.error).join("\n")}
${path3}
${underline}`);
  }
  return path3;
};
var path = createPathTagFunction(encodeURIPath);

// node_modules/@tambo-ai/typescript-sdk/resources/beta/registry.mjs
var Registry = class extends APIResource {
  /**
   * @example
   * ```ts
   * const registry = await client.beta.registry.retrieve(
   *   'componentname',
   * );
   * ```
   */
  retrieve(componentname, options) {
    return this._client.get(path`/registry/${componentname}`, options);
  }
};

// node_modules/@tambo-ai/typescript-sdk/resources/beta/projects/api-key.mjs
var APIKey = class extends APIResource {
  /**
   * @example
   * ```ts
   * const apiKeys = await client.beta.projects.apiKey.list(
   *   'id',
   * );
   * ```
   */
  list(id, options) {
    return this._client.get(path`/projects/${id}/api-keys`, options);
  }
  /**
   * @example
   * ```ts
   * const apiKey = await client.beta.projects.apiKey.delete(
   *   'apiKeyId',
   *   { id: 'id' },
   * );
   * ```
   */
  delete(apiKeyID, params, options) {
    const { id } = params;
    return this._client.delete(path`/projects/${id}/api-key/${apiKeyID}`, options);
  }
};

// node_modules/@tambo-ai/typescript-sdk/resources/beta/projects/provider-key.mjs
var ProviderKey = class extends APIResource {
  /**
   * @example
   * ```ts
   * const providerKeys =
   *   await client.beta.projects.providerKey.list('id');
   * ```
   */
  list(id, options) {
    return this._client.get(path`/projects/${id}/provider-keys`, options);
  }
  /**
   * @example
   * ```ts
   * const providerKey =
   *   await client.beta.projects.providerKey.delete(
   *     'providerKeyId',
   *     { id: 'id' },
   *   );
   * ```
   */
  delete(providerKeyID, params, options) {
    const { id } = params;
    return this._client.delete(path`/projects/${id}/provider-key/${providerKeyID}`, options);
  }
};

// node_modules/@tambo-ai/typescript-sdk/resources/beta/projects/projects.mjs
var Projects = class extends APIResource {
  constructor() {
    super(...arguments);
    this.apiKey = new APIKey(this._client);
    this.providerKey = new ProviderKey(this._client);
  }
  /**
   * @example
   * ```ts
   * const project = await client.beta.projects.retrieve('id');
   * ```
   */
  retrieve(id, options) {
    return this._client.get(path`/projects/${id}`, options);
  }
  /**
   * @example
   * ```ts
   * const project = await client.beta.projects.delete('id');
   * ```
   */
  delete(id, options) {
    return this._client.delete(path`/projects/${id}`, options);
  }
  /**
   * @example
   * ```ts
   * const response = await client.beta.projects.getCurrent();
   * ```
   */
  getCurrent(options) {
    return this._client.get("/projects", options);
  }
};
Projects.APIKey = APIKey;
Projects.ProviderKey = ProviderKey;

// node_modules/@tambo-ai/typescript-sdk/resources/beta/threads/messages.mjs
var Messages = class extends APIResource {
  /**
   * @example
   * ```ts
   * const message = await client.beta.threads.messages.create(
   *   'id',
   *   { content: [{ type: 'text' }], role: 'user' },
   * );
   * ```
   */
  create(id, body, options) {
    return this._client.post(path`/threads/${id}/messages`, { body, ...options });
  }
  /**
   * @example
   * ```ts
   * const threadMessages =
   *   await client.beta.threads.messages.list('thr_123.456');
   * ```
   */
  list(id, query = {}, options) {
    return this._client.get(path`/threads/${id}/messages`, { query, ...options });
  }
  /**
   * @example
   * ```ts
   * await client.beta.threads.messages.delete('msg_123.456', {
   *   id: 'thr_123.456',
   * });
   * ```
   */
  delete(messageID, params, options) {
    const { id } = params;
    return this._client.delete(path`/threads/${id}/messages/${messageID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * @example
   * ```ts
   * const threadMessage =
   *   await client.beta.threads.messages.updateComponentState(
   *     'msg_123.456',
   *     {
   *       id: 'thr_123.456',
   *       state: { foo: 'bar' },
   *     },
   *   );
   * ```
   */
  updateComponentState(messageID, params, options) {
    const { id, ...body } = params;
    return this._client.put(path`/threads/${id}/messages/${messageID}/component-state`, { body, ...options });
  }
};

// node_modules/@tambo-ai/typescript-sdk/resources/beta/threads/suggestions.mjs
var Suggestions = class extends APIResource {
  /**
   * Retrieves all suggestions generated for a specific message
   *
   * @example
   * ```ts
   * const suggestions =
   *   await client.beta.threads.suggestions.list(
   *     'msg_123456789',
   *     { id: 'thread_123456789' },
   *   );
   * ```
   */
  list(messageID, params, options) {
    const { id } = params;
    return this._client.get(path`/threads/${id}/messages/${messageID}/suggestions`, options);
  }
  /**
   * Generates and stores new suggestions for a specific message
   *
   * @example
   * ```ts
   * const suggestions =
   *   await client.beta.threads.suggestions.generate(
   *     'msg_123456789',
   *     { id: 'thread_123456789' },
   *   );
   * ```
   */
  generate(messageID, params, options) {
    const { id, ...body } = params;
    return this._client.post(path`/threads/${id}/messages/${messageID}/suggestions`, { body, ...options });
  }
};

// node_modules/@tambo-ai/typescript-sdk/resources/beta/threads/threads.mjs
var Threads = class extends APIResource {
  constructor() {
    super(...arguments);
    this.messages = new Messages(this._client);
    this.suggestions = new Suggestions(this._client);
  }
  /**
   * @example
   * ```ts
   * const thread = await client.beta.threads.create({
   *   projectId: 'projectId',
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/threads", { body, ...options });
  }
  /**
   * @example
   * ```ts
   * const thread = await client.beta.threads.retrieve('id');
   * ```
   */
  retrieve(id, query = {}, options) {
    return this._client.get(path`/threads/${id}`, { query, ...options });
  }
  /**
   * @example
   * ```ts
   * const thread = await client.beta.threads.update('id', {
   *   projectId: 'projectId',
   * });
   * ```
   */
  update(id, body, options) {
    return this._client.put(path`/threads/${id}`, { body, ...options });
  }
  /**
   * @example
   * ```ts
   * // Automatically fetches more pages as needed.
   * for await (const thread of client.beta.threads.list(
   *   'projectId',
   * )) {
   *   // ...
   * }
   * ```
   */
  list(projectID, query = {}, options) {
    return this._client.getAPIList(path`/threads/project/${projectID}`, OffsetAndLimit, {
      query,
      ...options
    });
  }
  /**
   * @example
   * ```ts
   * await client.beta.threads.delete('id');
   * ```
   */
  delete(id, options) {
    return this._client.delete(path`/threads/${id}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
    });
  }
  /**
   * This endpoint has been deprecated. Use POST /advancestream instead.
   *
   * @deprecated
   */
  advance(options) {
    return this._client.post("/threads/advance", options);
  }
  /**
   * This endpoint has been deprecated. Use POST /:id/advancestream instead.
   *
   * @deprecated
   */
  advanceByID(id, body, options) {
    return this._client.post(path`/threads/${id}/advance`, { body, ...options });
  }
  /**
   * Sets a thread's generation stage to CANCELLED
   *
   * @example
   * ```ts
   * const thread = await client.beta.threads.cancel(
   *   'thread_123456789',
   * );
   * ```
   */
  cancel(id, options) {
    return this._client.post(path`/threads/${id}/cancel`, options);
  }
  /**
   * Automatically generates and sets a name for the thread as a summary based on its
   * messages.
   *
   * @example
   * ```ts
   * const thread = await client.beta.threads.generateName(
   *   'thread_123456789',
   * );
   * ```
   */
  generateName(id, params = {}, options) {
    const { contextKey } = params ?? {};
    return this._client.post(path`/threads/${id}/generate-name`, { query: { contextKey }, ...options });
  }
};
Threads.Messages = Messages;
Threads.Suggestions = Suggestions;

// node_modules/@tambo-ai/typescript-sdk/resources/beta/beta.mjs
var Beta = class extends APIResource {
  constructor() {
    super(...arguments);
    this.registry = new Registry(this._client);
    this.projects = new Projects(this._client);
    this.threads = new Threads(this._client);
    this.auth = new Auth(this._client);
    this.audio = new Audio(this._client);
  }
};
Beta.Registry = Registry;
Beta.Projects = Projects;
Beta.Threads = Threads;
Beta.Auth = Auth;
Beta.Audio = Audio;

// node_modules/@tambo-ai/typescript-sdk/resources/storage.mjs
var Storage = class extends APIResource {
  /**
   * Returns a presigned URL that allows direct file upload to S3. The client should
   * PUT the file directly to the returned uploadUrl.
   *
   * @example
   * ```ts
   * const response = await client.storage.presign({
   *   contentType: 'application/pdf',
   *   size: 1024000,
   * });
   * ```
   */
  presign(body, options) {
    return this._client.post("/storage/presign", { body, ...options });
  }
};

// node_modules/@tambo-ai/typescript-sdk/resources/threads/messages.mjs
var Messages2 = class extends APIResource {
  /**
   * List messages in a thread. Supports cursor-based pagination and ordering.
   *
   * @example
   * ```ts
   * const messages = await client.threads.messages.list(
   *   'thr_abc123xyz',
   * );
   * ```
   */
  list(threadID, query = {}, options) {
    return this._client.get(path`/v1/threads/${threadID}/messages`, { query, ...options });
  }
  /**
   * Get a specific message by ID from a thread.
   *
   * @example
   * ```ts
   * const message = await client.threads.messages.get(
   *   'msg_xyz789abc',
   *   { threadId: 'thr_abc123xyz' },
   * );
   * ```
   */
  get(messageID, params, options) {
    const { threadId } = params;
    return this._client.get(path`/v1/threads/${threadId}/messages/${messageID}`, options);
  }
};

// node_modules/@tambo-ai/typescript-sdk/resources/threads/runs.mjs
var Runs = class extends APIResource {
  /**
   * Creates a new thread and immediately starts a streaming run. Returns an SSE
   * stream of AG-UI events.
   *
   * @example
   * ```ts
   * const run = await client.threads.runs.create({
   *   message: {
   *     content: [{ text: 'Hello, world!', type: 'text' }],
   *     role: 'user',
   *   },
   * });
   * ```
   */
  create(body, options) {
    return this._client.post("/v1/threads/runs", {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "text/event-stream" }, options == null ? void 0 : options.headers]),
      stream: true
    });
  }
  /**
   * Explicitly cancel a running run. Note: closing the SSE connection also cancels
   * the run.
   *
   * @example
   * ```ts
   * const run = await client.threads.runs.delete(
   *   'run_xyz789abc',
   *   { threadId: 'thr_abc123xyz' },
   * );
   * ```
   */
  delete(runID, params, options) {
    const { threadId } = params;
    return this._client.delete(path`/v1/threads/${threadId}/runs/${runID}`, options);
  }
  /**
   * Starts a streaming run on an existing thread. Returns an SSE stream of AG-UI
   * events.
   *
   * @example
   * ```ts
   * const response = await client.threads.runs.run(
   *   'thr_abc123xyz',
   *   {
   *     message: {
   *       content: [{ text: 'Hello, world!', type: 'text' }],
   *       role: 'user',
   *     },
   *   },
   * );
   * ```
   */
  run(threadID, body, options) {
    return this._client.post(path`/v1/threads/${threadID}/runs`, {
      body,
      ...options,
      headers: buildHeaders([{ Accept: "text/event-stream" }, options == null ? void 0 : options.headers]),
      stream: true
    });
  }
};

// node_modules/@tambo-ai/typescript-sdk/resources/threads/threads.mjs
var Threads2 = class extends APIResource {
  constructor() {
    super(...arguments);
    this.messages = new Messages2(this._client);
    this.runs = new Runs(this._client);
  }
  /**
   * Create a new empty thread. Note: initialMessages is not supported yet; create
   * the thread first, then add messages via runs/message endpoints.
   *
   * @example
   * ```ts
   * const thread = await client.threads.create();
   * ```
   */
  create(body, options) {
    return this._client.post("/v1/threads", { body, ...options });
  }
  /**
   * Get a thread by ID with all its messages. The thread must belong to the
   * authenticated project.
   *
   * @example
   * ```ts
   * const thread = await client.threads.retrieve(
   *   'thr_abc123xyz',
   * );
   * ```
   */
  retrieve(threadID, options) {
    return this._client.get(path`/v1/threads/${threadID}`, options);
  }
  /**
   * List all threads for the authenticated project. Supports cursor-based pagination
   * and filtering by context key.
   *
   * @example
   * ```ts
   * const threads = await client.threads.list();
   * ```
   */
  list(query = {}, options) {
    return this._client.get("/v1/threads", { query, ...options });
  }
  /**
   * Delete a thread and all its messages. This action cannot be undone.
   *
   * @example
   * ```ts
   * await client.threads.delete('thr_abc123xyz');
   * ```
   */
  delete(threadID, options) {
    return this._client.delete(path`/v1/threads/${threadID}`, {
      ...options,
      headers: buildHeaders([{ Accept: "*/*" }, options == null ? void 0 : options.headers])
    });
  }
};
Threads2.Messages = Messages2;
Threads2.Runs = Runs;

// node_modules/@tambo-ai/typescript-sdk/internal/utils/env.mjs
var readEnv = (env) => {
  var _a13, _b, _c, _d, _e;
  if (typeof globalThis.process !== "undefined") {
    return ((_b = (_a13 = globalThis.process.env) == null ? void 0 : _a13[env]) == null ? void 0 : _b.trim()) ?? void 0;
  }
  if (typeof globalThis.Deno !== "undefined") {
    return (_e = (_d = (_c = globalThis.Deno.env) == null ? void 0 : _c.get) == null ? void 0 : _d.call(_c, env)) == null ? void 0 : _e.trim();
  }
  return void 0;
};

// node_modules/@tambo-ai/typescript-sdk/client.mjs
var _TamboAI_instances;
var _a;
var _TamboAI_encoder;
var _TamboAI_baseURLOverridden;
var environments = {
  production: "https://api.tambo.co",
  staging: "https://hydra-api-dev.up.railway.app"
};
var TamboAI = class {
  /**
   * API Client for interfacing with the Tambo AI API.
   *
   * @param {string | null | undefined} [opts.apiKey=process.env['TAMBO_API_KEY'] ?? null]
   * @param {string | null | undefined} [opts.bearer]
   * @param {Environment} [opts.environment=production] - Specifies the environment URL to use for the API.
   * @param {string} [opts.baseURL=process.env['TAMBO_AI_BASE_URL'] ?? https://api.tambo.co] - Override the default base URL for the API.
   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {MergedRequestInit} [opts.fetchOptions] - Additional `RequestInit` options to be passed to `fetch` calls.
   * @param {Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=0] - The maximum number of times the client will retry a request.
   * @param {HeadersLike} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Record<string, string | undefined>} opts.defaultQuery - Default query parameters to include with every request to the API.
   */
  constructor({ baseURL = readEnv("TAMBO_AI_BASE_URL"), apiKey = readEnv("TAMBO_API_KEY") ?? null, bearer = null, ...opts } = {}) {
    _TamboAI_instances.add(this);
    _TamboAI_encoder.set(this, void 0);
    this.beta = new Beta(this);
    this.storage = new Storage(this);
    this.threads = new Threads2(this);
    const options = {
      apiKey,
      bearer,
      ...opts,
      baseURL,
      environment: opts.environment ?? "production"
    };
    if (baseURL && opts.environment) {
      throw new TamboAIError("Ambiguous URL; The `baseURL` option (or TAMBO_AI_BASE_URL env var) and the `environment` option are given. If you want to use the environment you must pass baseURL: null");
    }
    this.baseURL = options.baseURL || environments[options.environment || "production"];
    this.timeout = options.timeout ?? _a.DEFAULT_TIMEOUT;
    this.logger = options.logger ?? console;
    const defaultLogLevel = "warn";
    this.logLevel = defaultLogLevel;
    this.logLevel = parseLogLevel(options.logLevel, "ClientOptions.logLevel", this) ?? parseLogLevel(readEnv("TAMBO_AI_LOG"), "process.env['TAMBO_AI_LOG']", this) ?? defaultLogLevel;
    this.fetchOptions = options.fetchOptions;
    this.maxRetries = options.maxRetries ?? 0;
    this.fetch = options.fetch ?? getDefaultFetch();
    __classPrivateFieldSet(this, _TamboAI_encoder, FallbackEncoder, "f");
    this._options = options;
    this.apiKey = apiKey;
    this.bearer = bearer;
  }
  /**
   * Create a new client instance re-using the same options given to the current client with optional overriding.
   */
  withOptions(options) {
    const client = new this.constructor({
      ...this._options,
      environment: options.environment ? options.environment : void 0,
      baseURL: options.environment ? void 0 : this.baseURL,
      maxRetries: this.maxRetries,
      timeout: this.timeout,
      logger: this.logger,
      logLevel: this.logLevel,
      fetch: this.fetch,
      fetchOptions: this.fetchOptions,
      apiKey: this.apiKey,
      bearer: this.bearer,
      ...options
    });
    return client;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  validateHeaders({ values, nulls }) {
    if (this.apiKey && values.get("x-api-key")) {
      return;
    }
    if (nulls.has("x-api-key")) {
      return;
    }
    if (this.bearer && values.get("authorization")) {
      return;
    }
    if (nulls.has("authorization")) {
      return;
    }
    throw new Error('Could not resolve authentication method. Expected either apiKey or bearer to be set. Or for one of the "x-api-key" or "Authorization" headers to be explicitly omitted');
  }
  async authHeaders(opts) {
    return buildHeaders([await this.apiKeyAuth(opts), await this.bearerAuth(opts)]);
  }
  async apiKeyAuth(opts) {
    if (this.apiKey == null) {
      return void 0;
    }
    return buildHeaders([{ "x-api-key": this.apiKey }]);
  }
  async bearerAuth(opts) {
    if (this.bearer == null) {
      return void 0;
    }
    return buildHeaders([{ Authorization: `Bearer ${this.bearer}` }]);
  }
  /**
   * Basic re-implementation of `qs.stringify` for primitive types.
   */
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new TamboAIError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  buildURL(path2, query, defaultBaseURL) {
    const baseURL = !__classPrivateFieldGet(this, _TamboAI_instances, "m", _TamboAI_baseURLOverridden).call(this) && defaultBaseURL || this.baseURL;
    const url4 = isAbsoluteURL(path2) ? new URL(path2) : new URL(baseURL + (baseURL.endsWith("/") && path2.startsWith("/") ? path2.slice(1) : path2));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url4.search = this.stringifyQuery(query);
    }
    return url4.toString();
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url: url4, options }) {
  }
  get(path2, opts) {
    return this.methodRequest("get", path2, opts);
  }
  post(path2, opts) {
    return this.methodRequest("post", path2, opts);
  }
  patch(path2, opts) {
    return this.methodRequest("patch", path2, opts);
  }
  put(path2, opts) {
    return this.methodRequest("put", path2, opts);
  }
  delete(path2, opts) {
    return this.methodRequest("delete", path2, opts);
  }
  methodRequest(method, path2, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => {
      return { method, path: path2, ...opts2 };
    }));
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this, this.makeRequest(options, remainingRetries, void 0));
  }
  async makeRequest(optionsInput, retriesRemaining, retryOfRequestLogID) {
    var _a13, _b;
    const options = await optionsInput;
    const maxRetries = options.maxRetries ?? this.maxRetries;
    if (retriesRemaining == null) {
      retriesRemaining = maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url: url4, timeout } = await this.buildRequest(options, {
      retryCount: maxRetries - retriesRemaining
    });
    await this.prepareRequest(req, { url: url4, options });
    const requestLogID = "log_" + (Math.random() * (1 << 24) | 0).toString(16).padStart(6, "0");
    const retryLogStr = retryOfRequestLogID === void 0 ? "" : `, retryOf: ${retryOfRequestLogID}`;
    const startTime = Date.now();
    loggerFor(this).debug(`[${requestLogID}] sending request`, formatRequestDetails({
      retryOfRequestLogID,
      method: options.method,
      url: url4,
      options,
      headers: req.headers
    }));
    if ((_a13 = options.signal) == null ? void 0 : _a13.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url4, req, timeout, controller).catch(castToError);
    const headersTime = Date.now();
    if (response instanceof globalThis.Error) {
      const retryMessage = `retrying, ${retriesRemaining} attempts remaining`;
      if ((_b = options.signal) == null ? void 0 : _b.aborted) {
        throw new APIUserAbortError();
      }
      const isTimeout = isAbortError(response) || /timed? ?out/i.test(String(response) + ("cause" in response ? String(response.cause) : ""));
      if (retriesRemaining) {
        loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - ${retryMessage}`);
        loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (${retryMessage})`, formatRequestDetails({
          retryOfRequestLogID,
          url: url4,
          durationMs: headersTime - startTime,
          message: response.message
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID);
      }
      loggerFor(this).info(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} - error; no more retries left`);
      loggerFor(this).debug(`[${requestLogID}] connection ${isTimeout ? "timed out" : "failed"} (error; no more retries left)`, formatRequestDetails({
        retryOfRequestLogID,
        url: url4,
        durationMs: headersTime - startTime,
        message: response.message
      }));
      if (isTimeout) {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseInfo = `[${requestLogID}${retryLogStr}] ${req.method} ${url4} ${response.ok ? "succeeded" : "failed"} with status ${response.status} in ${headersTime - startTime}ms`;
    if (!response.ok) {
      const shouldRetry = await this.shouldRetry(response);
      if (retriesRemaining && shouldRetry) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        await CancelReadableStream(response.body);
        loggerFor(this).info(`${responseInfo} - ${retryMessage2}`);
        loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage2})`, formatRequestDetails({
          retryOfRequestLogID,
          url: response.url,
          status: response.status,
          headers: response.headers,
          durationMs: headersTime - startTime
        }));
        return this.retryRequest(options, retriesRemaining, retryOfRequestLogID ?? requestLogID, response.headers);
      }
      const retryMessage = shouldRetry ? `error; no more retries left` : `error; not retryable`;
      loggerFor(this).info(`${responseInfo} - ${retryMessage}`);
      const errText = await response.text().catch((err2) => castToError(err2).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      loggerFor(this).debug(`[${requestLogID}] response error (${retryMessage})`, formatRequestDetails({
        retryOfRequestLogID,
        url: response.url,
        status: response.status,
        headers: response.headers,
        message: errMessage,
        durationMs: Date.now() - startTime
      }));
      const err = this.makeStatusError(response.status, errJSON, errMessage, response.headers);
      throw err;
    }
    loggerFor(this).info(responseInfo);
    loggerFor(this).debug(`[${requestLogID}] response start`, formatRequestDetails({
      retryOfRequestLogID,
      url: response.url,
      status: response.status,
      headers: response.headers,
      durationMs: headersTime - startTime
    }));
    return { response, options, controller, requestLogID, retryOfRequestLogID, startTime };
  }
  getAPIList(path2, Page, opts) {
    return this.requestAPIList(Page, { method: "get", path: path2, ...opts });
  }
  requestAPIList(Page, options) {
    const request = this.makeRequest(options, null, void 0);
    return new PagePromise(this, request, Page);
  }
  async fetchWithTimeout(url4, init, ms, controller) {
    const { signal, method, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    const isReadableBody = globalThis.ReadableStream && options.body instanceof globalThis.ReadableStream || typeof options.body === "object" && options.body !== null && Symbol.asyncIterator in options.body;
    const fetchOptions = {
      signal: controller.signal,
      ...isReadableBody ? { duplex: "half" } : {},
      method: "GET",
      ...options
    };
    if (method) {
      fetchOptions.method = method.toUpperCase();
    }
    try {
      return await this.fetch.call(void 0, url4, fetchOptions);
    } finally {
      clearTimeout(timeout);
    }
  }
  async shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, requestLogID, responseHeaders) {
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after-ms");
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders.get("retry-after");
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = options.maxRetries ?? this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1, requestLogID);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 1;
    const maxRetryDelay = 5;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  async buildRequest(inputOptions, { retryCount = 0 } = {}) {
    const options = { ...inputOptions };
    const { method, path: path2, query, defaultBaseURL } = options;
    const url4 = this.buildURL(path2, query, defaultBaseURL);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    options.timeout = options.timeout ?? this.timeout;
    const { bodyHeaders, body } = this.buildBody({ options });
    const reqHeaders = await this.buildHeaders({ options: inputOptions, method, bodyHeaders, retryCount });
    const req = {
      method,
      headers: reqHeaders,
      ...options.signal && { signal: options.signal },
      ...globalThis.ReadableStream && body instanceof globalThis.ReadableStream && { duplex: "half" },
      ...body && { body },
      ...this.fetchOptions ?? {},
      ...options.fetchOptions ?? {}
    };
    return { req, url: url4, timeout: options.timeout };
  }
  async buildHeaders({ options, method, bodyHeaders, retryCount }) {
    let idempotencyHeaders = {};
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      idempotencyHeaders[this.idempotencyHeader] = options.idempotencyKey;
    }
    const headers = buildHeaders([
      idempotencyHeaders,
      {
        Accept: "application/json",
        "User-Agent": this.getUserAgent(),
        "X-Stainless-Retry-Count": String(retryCount),
        ...options.timeout ? { "X-Stainless-Timeout": String(Math.trunc(options.timeout / 1e3)) } : {},
        ...getPlatformHeaders()
      },
      await this.authHeaders(options),
      this._options.defaultHeaders,
      bodyHeaders,
      options.headers
    ]);
    this.validateHeaders(headers);
    return headers.values;
  }
  buildBody({ options: { body, headers: rawHeaders } }) {
    if (!body) {
      return { bodyHeaders: void 0, body: void 0 };
    }
    const headers = buildHeaders([rawHeaders]);
    if (
      // Pass raw type verbatim
      ArrayBuffer.isView(body) || body instanceof ArrayBuffer || body instanceof DataView || typeof body === "string" && // Preserve legacy string encoding behavior for now
      headers.values.has("content-type") || // `Blob` is superset of `File`
      globalThis.Blob && body instanceof globalThis.Blob || // `FormData` -> `multipart/form-data`
      body instanceof FormData || // `URLSearchParams` -> `application/x-www-form-urlencoded`
      body instanceof URLSearchParams || // Send chunked stream (each chunk has own `length`)
      globalThis.ReadableStream && body instanceof globalThis.ReadableStream
    ) {
      return { bodyHeaders: void 0, body };
    } else if (typeof body === "object" && (Symbol.asyncIterator in body || Symbol.iterator in body && "next" in body && typeof body.next === "function")) {
      return { bodyHeaders: void 0, body: ReadableStreamFrom(body) };
    } else {
      return __classPrivateFieldGet(this, _TamboAI_encoder, "f").call(this, { body, headers });
    }
  }
};
_a = TamboAI, _TamboAI_encoder = /* @__PURE__ */ new WeakMap(), _TamboAI_instances = /* @__PURE__ */ new WeakSet(), _TamboAI_baseURLOverridden = function _TamboAI_baseURLOverridden2() {
  return this.baseURL !== environments[this._options.environment || "production"];
};
TamboAI.TamboAI = _a;
TamboAI.DEFAULT_TIMEOUT = 6e4;
TamboAI.TamboAIError = TamboAIError;
TamboAI.APIError = APIError;
TamboAI.APIConnectionError = APIConnectionError;
TamboAI.APIConnectionTimeoutError = APIConnectionTimeoutError;
TamboAI.APIUserAbortError = APIUserAbortError;
TamboAI.NotFoundError = NotFoundError;
TamboAI.ConflictError = ConflictError;
TamboAI.RateLimitError = RateLimitError;
TamboAI.BadRequestError = BadRequestError;
TamboAI.AuthenticationError = AuthenticationError;
TamboAI.InternalServerError = InternalServerError;
TamboAI.PermissionDeniedError = PermissionDeniedError;
TamboAI.UnprocessableEntityError = UnprocessableEntityError;
TamboAI.toFile = toFile;
TamboAI.Beta = Beta;
TamboAI.Storage = Storage;
TamboAI.Threads = Threads2;

// node_modules/@tambo-ai/typescript-sdk/lib/advance-stream.mjs
async function advanceStream(client, body, threadId, options) {
  const MAX_REQUEST_RETRIES = 2;
  let requestRetryCount = 0;
  while (true) {
    try {
      const responsePromise = client.post(`/threads${threadId ? `/${threadId}` : ""}/advancestream`, {
        body,
        ...options,
        headers: {
          ...options == null ? void 0 : options.headers,
          Accept: "text/event-stream"
        }
      });
      const response = await responsePromise.asResponse();
      return handleStreamResponse(response);
    } catch (error) {
      if (requestRetryCount < MAX_REQUEST_RETRIES) {
        requestRetryCount++;
        console.warn(`Request failed, attempting retry ${requestRetryCount}/${MAX_REQUEST_RETRIES}`);
        continue;
      }
      throw error;
    }
  }
}
async function* handleStreamResponse(response) {
  const decoder = new TextDecoder();
  const MAX_CHUNK_RETRIES = 5;
  let chunkRetryCount = 0;
  const reader = response.body.getReader();
  while (true) {
    try {
      const { done, value: chunk } = await reader.read();
      if (done)
        break;
      const text = decoder.decode(chunk);
      const messages = text.split("\n").filter((msg) => msg.trim());
      for (const msg of messages) {
        if (msg === "data: DONE") {
          continue;
        }
        if (msg.startsWith("error: ")) {
          throw new Error(msg.slice(7));
        }
        const jsonStr = msg.startsWith("data: ") ? msg.slice(6) : msg;
        if (!jsonStr) {
          continue;
        }
        try {
          yield JSON.parse(jsonStr);
          chunkRetryCount = 0;
        } catch (e2) {
          if (chunkRetryCount < MAX_CHUNK_RETRIES) {
            chunkRetryCount++;
            console.warn(`Failed to parse JSON chunk, skipping. Attempt ${chunkRetryCount}/${MAX_CHUNK_RETRIES}`);
            continue;
          }
          throw new Error("Failed to parse JSON after multiple chunks.");
        }
      }
    } catch (error) {
      reader.releaseLock();
      throw error;
    }
  }
}

// node_modules/@tanstack/query-core/build/modern/subscribable.js
var Subscribable = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
    this.subscribe = this.subscribe.bind(this);
  }
  subscribe(listener) {
    this.listeners.add(listener);
    this.onSubscribe();
    return () => {
      this.listeners.delete(listener);
      this.onUnsubscribe();
    };
  }
  hasListeners() {
    return this.listeners.size > 0;
  }
  onSubscribe() {
  }
  onUnsubscribe() {
  }
};

// node_modules/@tanstack/query-core/build/modern/timeoutManager.js
var defaultTimeoutProvider = {
  // We need the wrapper function syntax below instead of direct references to
  // global setTimeout etc.
  //
  // BAD: `setTimeout: setTimeout`
  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`
  //
  // If we use direct references here, then anything that wants to spy on or
  // replace the global setTimeout (like tests) won't work since we'll already
  // have a hard reference to the original implementation at the time when this
  // file was imported.
  setTimeout: (callback, delay) => setTimeout(callback, delay),
  clearTimeout: (timeoutId) => clearTimeout(timeoutId),
  setInterval: (callback, delay) => setInterval(callback, delay),
  clearInterval: (intervalId) => clearInterval(intervalId)
};
var _provider, _providerCalled, _a2;
var TimeoutManager = (_a2 = class {
  constructor() {
    // We cannot have TimeoutManager<T> as we must instantiate it with a concrete
    // type at app boot; and if we leave that type, then any new timer provider
    // would need to support ReturnType<typeof setTimeout>, which is infeasible.
    //
    // We settle for type safety for the TimeoutProvider type, and accept that
    // this class is unsafe internally to allow for extension.
    __privateAdd(this, _provider, defaultTimeoutProvider);
    __privateAdd(this, _providerCalled, false);
  }
  setTimeoutProvider(provider) {
    if (true) {
      if (__privateGet(this, _providerCalled) && provider !== __privateGet(this, _provider)) {
        console.error(
          `[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`,
          { previous: __privateGet(this, _provider), provider }
        );
      }
    }
    __privateSet(this, _provider, provider);
    if (true) {
      __privateSet(this, _providerCalled, false);
    }
  }
  setTimeout(callback, delay) {
    if (true) {
      __privateSet(this, _providerCalled, true);
    }
    return __privateGet(this, _provider).setTimeout(callback, delay);
  }
  clearTimeout(timeoutId) {
    __privateGet(this, _provider).clearTimeout(timeoutId);
  }
  setInterval(callback, delay) {
    if (true) {
      __privateSet(this, _providerCalled, true);
    }
    return __privateGet(this, _provider).setInterval(callback, delay);
  }
  clearInterval(intervalId) {
    __privateGet(this, _provider).clearInterval(intervalId);
  }
}, _provider = new WeakMap(), _providerCalled = new WeakMap(), _a2);
var timeoutManager = new TimeoutManager();
function systemSetTimeoutZero(callback) {
  setTimeout(callback, 0);
}

// node_modules/@tanstack/query-core/build/modern/utils.js
var isServer = typeof window === "undefined" || "Deno" in globalThis;
function noop2() {
}
function functionalUpdate(updater, input) {
  return typeof updater === "function" ? updater(input) : updater;
}
function isValidTimeout(value) {
  return typeof value === "number" && value >= 0 && value !== Infinity;
}
function timeUntilStale(updatedAt, staleTime) {
  return Math.max(updatedAt + (staleTime || 0) - Date.now(), 0);
}
function resolveStaleTime(staleTime, query) {
  return typeof staleTime === "function" ? staleTime(query) : staleTime;
}
function resolveEnabled(enabled, query) {
  return typeof enabled === "function" ? enabled(query) : enabled;
}
function matchQuery(filters, query) {
  const {
    type = "all",
    exact,
    fetchStatus,
    predicate,
    queryKey,
    stale
  } = filters;
  if (queryKey) {
    if (exact) {
      if (query.queryHash !== hashQueryKeyByOptions(queryKey, query.options)) {
        return false;
      }
    } else if (!partialMatchKey(query.queryKey, queryKey)) {
      return false;
    }
  }
  if (type !== "all") {
    const isActive = query.isActive();
    if (type === "active" && !isActive) {
      return false;
    }
    if (type === "inactive" && isActive) {
      return false;
    }
  }
  if (typeof stale === "boolean" && query.isStale() !== stale) {
    return false;
  }
  if (fetchStatus && fetchStatus !== query.state.fetchStatus) {
    return false;
  }
  if (predicate && !predicate(query)) {
    return false;
  }
  return true;
}
function matchMutation(filters, mutation) {
  const { exact, status, predicate, mutationKey } = filters;
  if (mutationKey) {
    if (!mutation.options.mutationKey) {
      return false;
    }
    if (exact) {
      if (hashKey(mutation.options.mutationKey) !== hashKey(mutationKey)) {
        return false;
      }
    } else if (!partialMatchKey(mutation.options.mutationKey, mutationKey)) {
      return false;
    }
  }
  if (status && mutation.state.status !== status) {
    return false;
  }
  if (predicate && !predicate(mutation)) {
    return false;
  }
  return true;
}
function hashQueryKeyByOptions(queryKey, options) {
  const hashFn = (options == null ? void 0 : options.queryKeyHashFn) || hashKey;
  return hashFn(queryKey);
}
function hashKey(queryKey) {
  return JSON.stringify(
    queryKey,
    (_, val) => isPlainObject(val) ? Object.keys(val).sort().reduce((result, key) => {
      result[key] = val[key];
      return result;
    }, {}) : val
  );
}
function partialMatchKey(a, b) {
  if (a === b) {
    return true;
  }
  if (typeof a !== typeof b) {
    return false;
  }
  if (a && b && typeof a === "object" && typeof b === "object") {
    return Object.keys(b).every((key) => partialMatchKey(a[key], b[key]));
  }
  return false;
}
var hasOwn3 = Object.prototype.hasOwnProperty;
function replaceEqualDeep(a, b, depth = 0) {
  if (a === b) {
    return a;
  }
  if (depth > 500) return b;
  const array2 = isPlainArray(a) && isPlainArray(b);
  if (!array2 && !(isPlainObject(a) && isPlainObject(b))) return b;
  const aItems = array2 ? a : Object.keys(a);
  const aSize = aItems.length;
  const bItems = array2 ? b : Object.keys(b);
  const bSize = bItems.length;
  const copy = array2 ? new Array(bSize) : {};
  let equalItems = 0;
  for (let i = 0; i < bSize; i++) {
    const key = array2 ? i : bItems[i];
    const aItem = a[key];
    const bItem = b[key];
    if (aItem === bItem) {
      copy[key] = aItem;
      if (array2 ? i < aSize : hasOwn3.call(a, key)) equalItems++;
      continue;
    }
    if (aItem === null || bItem === null || typeof aItem !== "object" || typeof bItem !== "object") {
      copy[key] = bItem;
      continue;
    }
    const v = replaceEqualDeep(aItem, bItem, depth + 1);
    copy[key] = v;
    if (v === aItem) equalItems++;
  }
  return aSize === bSize && equalItems === aSize ? a : copy;
}
function shallowEqualObjects(a, b) {
  if (!b || Object.keys(a).length !== Object.keys(b).length) {
    return false;
  }
  for (const key in a) {
    if (a[key] !== b[key]) {
      return false;
    }
  }
  return true;
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function isPlainObject(o) {
  if (!hasObjectPrototype(o)) {
    return false;
  }
  const ctor = o.constructor;
  if (ctor === void 0) {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  if (Object.getPrototypeOf(o) !== Object.prototype) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o) {
  return Object.prototype.toString.call(o) === "[object Object]";
}
function sleep2(timeout) {
  return new Promise((resolve) => {
    timeoutManager.setTimeout(resolve, timeout);
  });
}
function replaceData(prevData, data, options) {
  if (typeof options.structuralSharing === "function") {
    return options.structuralSharing(prevData, data);
  } else if (options.structuralSharing !== false) {
    if (true) {
      try {
        return replaceEqualDeep(prevData, data);
      } catch (error) {
        console.error(
          `Structural sharing requires data to be JSON serializable. To fix this, turn off structuralSharing or return JSON-serializable data from your queryFn. [${options.queryHash}]: ${error}`
        );
        throw error;
      }
    }
    return replaceEqualDeep(prevData, data);
  }
  return data;
}
function addToEnd(items, item, max = 0) {
  const newItems = [...items, item];
  return max && newItems.length > max ? newItems.slice(1) : newItems;
}
function addToStart(items, item, max = 0) {
  const newItems = [item, ...items];
  return max && newItems.length > max ? newItems.slice(0, -1) : newItems;
}
var skipToken = Symbol();
function ensureQueryFn(options, fetchOptions) {
  if (true) {
    if (options.queryFn === skipToken) {
      console.error(
        `Attempted to invoke queryFn when set to skipToken. This is likely a configuration error. Query hash: '${options.queryHash}'`
      );
    }
  }
  if (!options.queryFn && (fetchOptions == null ? void 0 : fetchOptions.initialPromise)) {
    return () => fetchOptions.initialPromise;
  }
  if (!options.queryFn || options.queryFn === skipToken) {
    return () => Promise.reject(new Error(`Missing queryFn: '${options.queryHash}'`));
  }
  return options.queryFn;
}
function shouldThrowError(throwOnError, params) {
  if (typeof throwOnError === "function") {
    return throwOnError(...params);
  }
  return !!throwOnError;
}
function addConsumeAwareSignal(object3, getSignal, onCancelled) {
  let consumed = false;
  let signal;
  Object.defineProperty(object3, "signal", {
    enumerable: true,
    get: () => {
      signal ?? (signal = getSignal());
      if (consumed) {
        return signal;
      }
      consumed = true;
      if (signal.aborted) {
        onCancelled();
      } else {
        signal.addEventListener("abort", onCancelled, { once: true });
      }
      return signal;
    }
  });
  return object3;
}

// node_modules/@tanstack/query-core/build/modern/focusManager.js
var _focused, _cleanup, _setup, _a3;
var FocusManager = (_a3 = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _focused);
    __privateAdd(this, _cleanup);
    __privateAdd(this, _setup);
    __privateSet(this, _setup, (onFocus) => {
      if (!isServer && window.addEventListener) {
        const listener = () => onFocus();
        window.addEventListener("visibilitychange", listener, false);
        return () => {
          window.removeEventListener("visibilitychange", listener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup)) {
      this.setEventListener(__privateGet(this, _setup));
    }
  }
  onUnsubscribe() {
    var _a13;
    if (!this.hasListeners()) {
      (_a13 = __privateGet(this, _cleanup)) == null ? void 0 : _a13.call(this);
      __privateSet(this, _cleanup, void 0);
    }
  }
  setEventListener(setup) {
    var _a13;
    __privateSet(this, _setup, setup);
    (_a13 = __privateGet(this, _cleanup)) == null ? void 0 : _a13.call(this);
    __privateSet(this, _cleanup, setup((focused) => {
      if (typeof focused === "boolean") {
        this.setFocused(focused);
      } else {
        this.onFocus();
      }
    }));
  }
  setFocused(focused) {
    const changed = __privateGet(this, _focused) !== focused;
    if (changed) {
      __privateSet(this, _focused, focused);
      this.onFocus();
    }
  }
  onFocus() {
    const isFocused = this.isFocused();
    this.listeners.forEach((listener) => {
      listener(isFocused);
    });
  }
  isFocused() {
    var _a13;
    if (typeof __privateGet(this, _focused) === "boolean") {
      return __privateGet(this, _focused);
    }
    return ((_a13 = globalThis.document) == null ? void 0 : _a13.visibilityState) !== "hidden";
  }
}, _focused = new WeakMap(), _cleanup = new WeakMap(), _setup = new WeakMap(), _a3);
var focusManager = new FocusManager();

// node_modules/@tanstack/query-core/build/modern/thenable.js
function pendingThenable() {
  let resolve;
  let reject;
  const thenable = new Promise((_resolve, _reject) => {
    resolve = _resolve;
    reject = _reject;
  });
  thenable.status = "pending";
  thenable.catch(() => {
  });
  function finalize(data) {
    Object.assign(thenable, data);
    delete thenable.resolve;
    delete thenable.reject;
  }
  thenable.resolve = (value) => {
    finalize({
      status: "fulfilled",
      value
    });
    resolve(value);
  };
  thenable.reject = (reason) => {
    finalize({
      status: "rejected",
      reason
    });
    reject(reason);
  };
  return thenable;
}

// node_modules/@tanstack/query-core/build/modern/notifyManager.js
var defaultScheduler = systemSetTimeoutZero;
function createNotifyManager() {
  let queue = [];
  let transactions = 0;
  let notifyFn = (callback) => {
    callback();
  };
  let batchNotifyFn = (callback) => {
    callback();
  };
  let scheduleFn = defaultScheduler;
  const schedule = (callback) => {
    if (transactions) {
      queue.push(callback);
    } else {
      scheduleFn(() => {
        notifyFn(callback);
      });
    }
  };
  const flush = () => {
    const originalQueue = queue;
    queue = [];
    if (originalQueue.length) {
      scheduleFn(() => {
        batchNotifyFn(() => {
          originalQueue.forEach((callback) => {
            notifyFn(callback);
          });
        });
      });
    }
  };
  return {
    batch: (callback) => {
      let result;
      transactions++;
      try {
        result = callback();
      } finally {
        transactions--;
        if (!transactions) {
          flush();
        }
      }
      return result;
    },
    /**
     * All calls to the wrapped function will be batched.
     */
    batchCalls: (callback) => {
      return (...args) => {
        schedule(() => {
          callback(...args);
        });
      };
    },
    schedule,
    /**
     * Use this method to set a custom notify function.
     * This can be used to for example wrap notifications with `React.act` while running tests.
     */
    setNotifyFunction: (fn) => {
      notifyFn = fn;
    },
    /**
     * Use this method to set a custom function to batch notifications together into a single tick.
     * By default React Query will use the batch function provided by ReactDOM or React Native.
     */
    setBatchNotifyFunction: (fn) => {
      batchNotifyFn = fn;
    },
    setScheduler: (fn) => {
      scheduleFn = fn;
    }
  };
}
var notifyManager = createNotifyManager();

// node_modules/@tanstack/query-core/build/modern/onlineManager.js
var _online, _cleanup2, _setup2, _a4;
var OnlineManager = (_a4 = class extends Subscribable {
  constructor() {
    super();
    __privateAdd(this, _online, true);
    __privateAdd(this, _cleanup2);
    __privateAdd(this, _setup2);
    __privateSet(this, _setup2, (onOnline) => {
      if (!isServer && window.addEventListener) {
        const onlineListener = () => onOnline(true);
        const offlineListener = () => onOnline(false);
        window.addEventListener("online", onlineListener, false);
        window.addEventListener("offline", offlineListener, false);
        return () => {
          window.removeEventListener("online", onlineListener);
          window.removeEventListener("offline", offlineListener);
        };
      }
      return;
    });
  }
  onSubscribe() {
    if (!__privateGet(this, _cleanup2)) {
      this.setEventListener(__privateGet(this, _setup2));
    }
  }
  onUnsubscribe() {
    var _a13;
    if (!this.hasListeners()) {
      (_a13 = __privateGet(this, _cleanup2)) == null ? void 0 : _a13.call(this);
      __privateSet(this, _cleanup2, void 0);
    }
  }
  setEventListener(setup) {
    var _a13;
    __privateSet(this, _setup2, setup);
    (_a13 = __privateGet(this, _cleanup2)) == null ? void 0 : _a13.call(this);
    __privateSet(this, _cleanup2, setup(this.setOnline.bind(this)));
  }
  setOnline(online2) {
    const changed = __privateGet(this, _online) !== online2;
    if (changed) {
      __privateSet(this, _online, online2);
      this.listeners.forEach((listener) => {
        listener(online2);
      });
    }
  }
  isOnline() {
    return __privateGet(this, _online);
  }
}, _online = new WeakMap(), _cleanup2 = new WeakMap(), _setup2 = new WeakMap(), _a4);
var onlineManager = new OnlineManager();

// node_modules/@tanstack/query-core/build/modern/retryer.js
function defaultRetryDelay(failureCount) {
  return Math.min(1e3 * 2 ** failureCount, 3e4);
}
function canFetch(networkMode) {
  return (networkMode ?? "online") === "online" ? onlineManager.isOnline() : true;
}
var CancelledError = class extends Error {
  constructor(options) {
    super("CancelledError");
    this.revert = options == null ? void 0 : options.revert;
    this.silent = options == null ? void 0 : options.silent;
  }
};
function createRetryer(config2) {
  let isRetryCancelled = false;
  let failureCount = 0;
  let continueFn;
  const thenable = pendingThenable();
  const isResolved = () => thenable.status !== "pending";
  const cancel = (cancelOptions) => {
    var _a13;
    if (!isResolved()) {
      const error = new CancelledError(cancelOptions);
      reject(error);
      (_a13 = config2.onCancel) == null ? void 0 : _a13.call(config2, error);
    }
  };
  const cancelRetry = () => {
    isRetryCancelled = true;
  };
  const continueRetry = () => {
    isRetryCancelled = false;
  };
  const canContinue = () => focusManager.isFocused() && (config2.networkMode === "always" || onlineManager.isOnline()) && config2.canRun();
  const canStart = () => canFetch(config2.networkMode) && config2.canRun();
  const resolve = (value) => {
    if (!isResolved()) {
      continueFn == null ? void 0 : continueFn();
      thenable.resolve(value);
    }
  };
  const reject = (value) => {
    if (!isResolved()) {
      continueFn == null ? void 0 : continueFn();
      thenable.reject(value);
    }
  };
  const pause = () => {
    return new Promise((continueResolve) => {
      var _a13;
      continueFn = (value) => {
        if (isResolved() || canContinue()) {
          continueResolve(value);
        }
      };
      (_a13 = config2.onPause) == null ? void 0 : _a13.call(config2);
    }).then(() => {
      var _a13;
      continueFn = void 0;
      if (!isResolved()) {
        (_a13 = config2.onContinue) == null ? void 0 : _a13.call(config2);
      }
    });
  };
  const run = () => {
    if (isResolved()) {
      return;
    }
    let promiseOrValue;
    const initialPromise = failureCount === 0 ? config2.initialPromise : void 0;
    try {
      promiseOrValue = initialPromise ?? config2.fn();
    } catch (error) {
      promiseOrValue = Promise.reject(error);
    }
    Promise.resolve(promiseOrValue).then(resolve).catch((error) => {
      var _a13;
      if (isResolved()) {
        return;
      }
      const retry = config2.retry ?? (isServer ? 0 : 3);
      const retryDelay = config2.retryDelay ?? defaultRetryDelay;
      const delay = typeof retryDelay === "function" ? retryDelay(failureCount, error) : retryDelay;
      const shouldRetry = retry === true || typeof retry === "number" && failureCount < retry || typeof retry === "function" && retry(failureCount, error);
      if (isRetryCancelled || !shouldRetry) {
        reject(error);
        return;
      }
      failureCount++;
      (_a13 = config2.onFail) == null ? void 0 : _a13.call(config2, failureCount, error);
      sleep2(delay).then(() => {
        return canContinue() ? void 0 : pause();
      }).then(() => {
        if (isRetryCancelled) {
          reject(error);
        } else {
          run();
        }
      });
    });
  };
  return {
    promise: thenable,
    status: () => thenable.status,
    cancel,
    continue: () => {
      continueFn == null ? void 0 : continueFn();
      return thenable;
    },
    cancelRetry,
    continueRetry,
    canStart,
    start: () => {
      if (canStart()) {
        run();
      } else {
        pause().then(run);
      }
      return thenable;
    }
  };
}

// node_modules/@tanstack/query-core/build/modern/removable.js
var _gcTimeout, _a5;
var Removable = (_a5 = class {
  constructor() {
    __privateAdd(this, _gcTimeout);
  }
  destroy() {
    this.clearGcTimeout();
  }
  scheduleGc() {
    this.clearGcTimeout();
    if (isValidTimeout(this.gcTime)) {
      __privateSet(this, _gcTimeout, timeoutManager.setTimeout(() => {
        this.optionalRemove();
      }, this.gcTime));
    }
  }
  updateGcTime(newGcTime) {
    this.gcTime = Math.max(
      this.gcTime || 0,
      newGcTime ?? (isServer ? Infinity : 5 * 60 * 1e3)
    );
  }
  clearGcTimeout() {
    if (__privateGet(this, _gcTimeout)) {
      timeoutManager.clearTimeout(__privateGet(this, _gcTimeout));
      __privateSet(this, _gcTimeout, void 0);
    }
  }
}, _gcTimeout = new WeakMap(), _a5);

// node_modules/@tanstack/query-core/build/modern/query.js
var _initialState, _revertState, _cache, _client, _retryer, _defaultOptions, _abortSignalConsumed, _Query_instances, dispatch_fn, _a6;
var Query = (_a6 = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Query_instances);
    __privateAdd(this, _initialState);
    __privateAdd(this, _revertState);
    __privateAdd(this, _cache);
    __privateAdd(this, _client);
    __privateAdd(this, _retryer);
    __privateAdd(this, _defaultOptions);
    __privateAdd(this, _abortSignalConsumed);
    __privateSet(this, _abortSignalConsumed, false);
    __privateSet(this, _defaultOptions, config2.defaultOptions);
    this.setOptions(config2.options);
    this.observers = [];
    __privateSet(this, _client, config2.client);
    __privateSet(this, _cache, __privateGet(this, _client).getQueryCache());
    this.queryKey = config2.queryKey;
    this.queryHash = config2.queryHash;
    __privateSet(this, _initialState, getDefaultState(this.options));
    this.state = config2.state ?? __privateGet(this, _initialState);
    this.scheduleGc();
  }
  get meta() {
    return this.options.meta;
  }
  get promise() {
    var _a13;
    return (_a13 = __privateGet(this, _retryer)) == null ? void 0 : _a13.promise;
  }
  setOptions(options) {
    this.options = { ...__privateGet(this, _defaultOptions), ...options };
    this.updateGcTime(this.options.gcTime);
    if (this.state && this.state.data === void 0) {
      const defaultState = getDefaultState(this.options);
      if (defaultState.data !== void 0) {
        this.setState(
          successState(defaultState.data, defaultState.dataUpdatedAt)
        );
        __privateSet(this, _initialState, defaultState);
      }
    }
  }
  optionalRemove() {
    if (!this.observers.length && this.state.fetchStatus === "idle") {
      __privateGet(this, _cache).remove(this);
    }
  }
  setData(newData, options) {
    const data = replaceData(this.state.data, newData, this.options);
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
      data,
      type: "success",
      dataUpdatedAt: options == null ? void 0 : options.updatedAt,
      manual: options == null ? void 0 : options.manual
    });
    return data;
  }
  setState(state, setStateOptions) {
    __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "setState", state, setStateOptions });
  }
  cancel(options) {
    var _a13, _b;
    const promise2 = (_a13 = __privateGet(this, _retryer)) == null ? void 0 : _a13.promise;
    (_b = __privateGet(this, _retryer)) == null ? void 0 : _b.cancel(options);
    return promise2 ? promise2.then(noop2).catch(noop2) : Promise.resolve();
  }
  destroy() {
    super.destroy();
    this.cancel({ silent: true });
  }
  reset() {
    this.destroy();
    this.setState(__privateGet(this, _initialState));
  }
  isActive() {
    return this.observers.some(
      (observer) => resolveEnabled(observer.options.enabled, this) !== false
    );
  }
  isDisabled() {
    if (this.getObserversCount() > 0) {
      return !this.isActive();
    }
    return this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0;
  }
  isStatic() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => resolveStaleTime(observer.options.staleTime, this) === "static"
      );
    }
    return false;
  }
  isStale() {
    if (this.getObserversCount() > 0) {
      return this.observers.some(
        (observer) => observer.getCurrentResult().isStale
      );
    }
    return this.state.data === void 0 || this.state.isInvalidated;
  }
  isStaleByTime(staleTime = 0) {
    if (this.state.data === void 0) {
      return true;
    }
    if (staleTime === "static") {
      return false;
    }
    if (this.state.isInvalidated) {
      return true;
    }
    return !timeUntilStale(this.state.dataUpdatedAt, staleTime);
  }
  onFocus() {
    var _a13;
    const observer = this.observers.find((x) => x.shouldFetchOnWindowFocus());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a13 = __privateGet(this, _retryer)) == null ? void 0 : _a13.continue();
  }
  onOnline() {
    var _a13;
    const observer = this.observers.find((x) => x.shouldFetchOnReconnect());
    observer == null ? void 0 : observer.refetch({ cancelRefetch: false });
    (_a13 = __privateGet(this, _retryer)) == null ? void 0 : _a13.continue();
  }
  addObserver(observer) {
    if (!this.observers.includes(observer)) {
      this.observers.push(observer);
      this.clearGcTimeout();
      __privateGet(this, _cache).notify({ type: "observerAdded", query: this, observer });
    }
  }
  removeObserver(observer) {
    if (this.observers.includes(observer)) {
      this.observers = this.observers.filter((x) => x !== observer);
      if (!this.observers.length) {
        if (__privateGet(this, _retryer)) {
          if (__privateGet(this, _abortSignalConsumed)) {
            __privateGet(this, _retryer).cancel({ revert: true });
          } else {
            __privateGet(this, _retryer).cancelRetry();
          }
        }
        this.scheduleGc();
      }
      __privateGet(this, _cache).notify({ type: "observerRemoved", query: this, observer });
    }
  }
  getObserversCount() {
    return this.observers.length;
  }
  invalidate() {
    if (!this.state.isInvalidated) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "invalidate" });
    }
  }
  async fetch(options, fetchOptions) {
    var _a13, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    if (this.state.fetchStatus !== "idle" && // If the promise in the retryer is already rejected, we have to definitely
    // re-start the fetch; there is a chance that the query is still in a
    // pending state when that happens
    ((_a13 = __privateGet(this, _retryer)) == null ? void 0 : _a13.status()) !== "rejected") {
      if (this.state.data !== void 0 && (fetchOptions == null ? void 0 : fetchOptions.cancelRefetch)) {
        this.cancel({ silent: true });
      } else if (__privateGet(this, _retryer)) {
        __privateGet(this, _retryer).continueRetry();
        return __privateGet(this, _retryer).promise;
      }
    }
    if (options) {
      this.setOptions(options);
    }
    if (!this.options.queryFn) {
      const observer = this.observers.find((x) => x.options.queryFn);
      if (observer) {
        this.setOptions(observer.options);
      }
    }
    if (true) {
      if (!Array.isArray(this.options.queryKey)) {
        console.error(
          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`
        );
      }
    }
    const abortController = new AbortController();
    const addSignalProperty = (object3) => {
      Object.defineProperty(object3, "signal", {
        enumerable: true,
        get: () => {
          __privateSet(this, _abortSignalConsumed, true);
          return abortController.signal;
        }
      });
    };
    const fetchFn = () => {
      const queryFn = ensureQueryFn(this.options, fetchOptions);
      const createQueryFnContext = () => {
        const queryFnContext2 = {
          client: __privateGet(this, _client),
          queryKey: this.queryKey,
          meta: this.meta
        };
        addSignalProperty(queryFnContext2);
        return queryFnContext2;
      };
      const queryFnContext = createQueryFnContext();
      __privateSet(this, _abortSignalConsumed, false);
      if (this.options.persister) {
        return this.options.persister(
          queryFn,
          queryFnContext,
          this
        );
      }
      return queryFn(queryFnContext);
    };
    const createFetchContext = () => {
      const context2 = {
        fetchOptions,
        options: this.options,
        queryKey: this.queryKey,
        client: __privateGet(this, _client),
        state: this.state,
        fetchFn
      };
      addSignalProperty(context2);
      return context2;
    };
    const context = createFetchContext();
    (_b = this.options.behavior) == null ? void 0 : _b.onFetch(context, this);
    __privateSet(this, _revertState, this.state);
    if (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((_c = context.fetchOptions) == null ? void 0 : _c.meta)) {
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "fetch", meta: (_d = context.fetchOptions) == null ? void 0 : _d.meta });
    }
    __privateSet(this, _retryer, createRetryer({
      initialPromise: fetchOptions == null ? void 0 : fetchOptions.initialPromise,
      fn: context.fetchFn,
      onCancel: (error) => {
        if (error instanceof CancelledError && error.revert) {
          this.setState({
            ...__privateGet(this, _revertState),
            fetchStatus: "idle"
          });
        }
        abortController.abort();
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "pause" });
      },
      onContinue: () => {
        __privateMethod(this, _Query_instances, dispatch_fn).call(this, { type: "continue" });
      },
      retry: context.options.retry,
      retryDelay: context.options.retryDelay,
      networkMode: context.options.networkMode,
      canRun: () => true
    }));
    try {
      const data = await __privateGet(this, _retryer).start();
      if (data === void 0) {
        if (true) {
          console.error(
            `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`
          );
        }
        throw new Error(`${this.queryHash} data is undefined`);
      }
      this.setData(data);
      (_f = (_e = __privateGet(this, _cache).config).onSuccess) == null ? void 0 : _f.call(_e, data, this);
      (_h = (_g = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _h.call(
        _g,
        data,
        this.state.error,
        this
      );
      return data;
    } catch (error) {
      if (error instanceof CancelledError) {
        if (error.silent) {
          return __privateGet(this, _retryer).promise;
        } else if (error.revert) {
          if (this.state.data === void 0) {
            throw error;
          }
          return this.state.data;
        }
      }
      __privateMethod(this, _Query_instances, dispatch_fn).call(this, {
        type: "error",
        error
      });
      (_j = (_i = __privateGet(this, _cache).config).onError) == null ? void 0 : _j.call(
        _i,
        error,
        this
      );
      (_l = (_k = __privateGet(this, _cache).config).onSettled) == null ? void 0 : _l.call(
        _k,
        this.state.data,
        error,
        this
      );
      throw error;
    } finally {
      this.scheduleGc();
    }
  }
}, _initialState = new WeakMap(), _revertState = new WeakMap(), _cache = new WeakMap(), _client = new WeakMap(), _retryer = new WeakMap(), _defaultOptions = new WeakMap(), _abortSignalConsumed = new WeakMap(), _Query_instances = new WeakSet(), dispatch_fn = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          fetchFailureCount: action.failureCount,
          fetchFailureReason: action.error
        };
      case "pause":
        return {
          ...state,
          fetchStatus: "paused"
        };
      case "continue":
        return {
          ...state,
          fetchStatus: "fetching"
        };
      case "fetch":
        return {
          ...state,
          ...fetchState(state.data, this.options),
          fetchMeta: action.meta ?? null
        };
      case "success":
        const newState = {
          ...state,
          ...successState(action.data, action.dataUpdatedAt),
          dataUpdateCount: state.dataUpdateCount + 1,
          ...!action.manual && {
            fetchStatus: "idle",
            fetchFailureCount: 0,
            fetchFailureReason: null
          }
        };
        __privateSet(this, _revertState, action.manual ? newState : void 0);
        return newState;
      case "error":
        const error = action.error;
        return {
          ...state,
          error,
          errorUpdateCount: state.errorUpdateCount + 1,
          errorUpdatedAt: Date.now(),
          fetchFailureCount: state.fetchFailureCount + 1,
          fetchFailureReason: error,
          fetchStatus: "idle",
          status: "error",
          // flag existing data as invalidated if we get a background error
          // note that "no data" always means stale so we can set unconditionally here
          isInvalidated: true
        };
      case "invalidate":
        return {
          ...state,
          isInvalidated: true
        };
      case "setState":
        return {
          ...state,
          ...action.state
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    this.observers.forEach((observer) => {
      observer.onQueryUpdate();
    });
    __privateGet(this, _cache).notify({ query: this, type: "updated", action });
  });
}, _a6);
function fetchState(data, options) {
  return {
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchStatus: canFetch(options.networkMode) ? "fetching" : "paused",
    ...data === void 0 && {
      error: null,
      status: "pending"
    }
  };
}
function successState(data, dataUpdatedAt) {
  return {
    data,
    dataUpdatedAt: dataUpdatedAt ?? Date.now(),
    error: null,
    isInvalidated: false,
    status: "success"
  };
}
function getDefaultState(options) {
  const data = typeof options.initialData === "function" ? options.initialData() : options.initialData;
  const hasData = data !== void 0;
  const initialDataUpdatedAt = hasData ? typeof options.initialDataUpdatedAt === "function" ? options.initialDataUpdatedAt() : options.initialDataUpdatedAt : 0;
  return {
    data,
    dataUpdateCount: 0,
    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,
    error: null,
    errorUpdateCount: 0,
    errorUpdatedAt: 0,
    fetchFailureCount: 0,
    fetchFailureReason: null,
    fetchMeta: null,
    isInvalidated: false,
    status: hasData ? "success" : "pending",
    fetchStatus: "idle"
  };
}

// node_modules/@tanstack/query-core/build/modern/queryObserver.js
var _client2, _currentQuery, _currentQueryInitialState, _currentResult, _currentResultState, _currentResultOptions, _currentThenable, _selectError, _selectFn, _selectResult, _lastQueryWithDefinedData, _staleTimeoutId, _refetchIntervalId, _currentRefetchInterval, _trackedProps, _QueryObserver_instances, executeFetch_fn, updateStaleTimeout_fn, computeRefetchInterval_fn, updateRefetchInterval_fn, updateTimers_fn, clearStaleTimeout_fn, clearRefetchInterval_fn, updateQuery_fn, notify_fn, _a7;
var QueryObserver = (_a7 = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _QueryObserver_instances);
    __privateAdd(this, _client2);
    __privateAdd(this, _currentQuery);
    __privateAdd(this, _currentQueryInitialState);
    __privateAdd(this, _currentResult);
    __privateAdd(this, _currentResultState);
    __privateAdd(this, _currentResultOptions);
    __privateAdd(this, _currentThenable);
    __privateAdd(this, _selectError);
    __privateAdd(this, _selectFn);
    __privateAdd(this, _selectResult);
    // This property keeps track of the last query with defined data.
    // It will be used to pass the previous data and query to the placeholder function between renders.
    __privateAdd(this, _lastQueryWithDefinedData);
    __privateAdd(this, _staleTimeoutId);
    __privateAdd(this, _refetchIntervalId);
    __privateAdd(this, _currentRefetchInterval);
    __privateAdd(this, _trackedProps, /* @__PURE__ */ new Set());
    this.options = options;
    __privateSet(this, _client2, client);
    __privateSet(this, _selectError, null);
    __privateSet(this, _currentThenable, pendingThenable());
    this.bindMethods();
    this.setOptions(options);
  }
  bindMethods() {
    this.refetch = this.refetch.bind(this);
  }
  onSubscribe() {
    if (this.listeners.size === 1) {
      __privateGet(this, _currentQuery).addObserver(this);
      if (shouldFetchOnMount(__privateGet(this, _currentQuery), this.options)) {
        __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
      } else {
        this.updateResult();
      }
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
  onUnsubscribe() {
    if (!this.hasListeners()) {
      this.destroy();
    }
  }
  shouldFetchOnReconnect() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnReconnect
    );
  }
  shouldFetchOnWindowFocus() {
    return shouldFetchOn(
      __privateGet(this, _currentQuery),
      this.options,
      this.options.refetchOnWindowFocus
    );
  }
  destroy() {
    this.listeners = /* @__PURE__ */ new Set();
    __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
    __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
    __privateGet(this, _currentQuery).removeObserver(this);
  }
  setOptions(options) {
    const prevOptions = this.options;
    const prevQuery = __privateGet(this, _currentQuery);
    this.options = __privateGet(this, _client2).defaultQueryOptions(options);
    if (this.options.enabled !== void 0 && typeof this.options.enabled !== "boolean" && typeof this.options.enabled !== "function" && typeof resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== "boolean") {
      throw new Error(
        "Expected enabled to be a boolean or a callback that returns a boolean"
      );
    }
    __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
    __privateGet(this, _currentQuery).setOptions(this.options);
    if (prevOptions._defaulted && !shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client2).getQueryCache().notify({
        type: "observerOptionsUpdated",
        query: __privateGet(this, _currentQuery),
        observer: this
      });
    }
    const mounted = this.hasListeners();
    if (mounted && shouldFetchOptionally(
      __privateGet(this, _currentQuery),
      prevQuery,
      this.options,
      prevOptions
    )) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
    this.updateResult();
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || resolveStaleTime(this.options.staleTime, __privateGet(this, _currentQuery)) !== resolveStaleTime(prevOptions.staleTime, __privateGet(this, _currentQuery)))) {
      __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
    }
    const nextRefetchInterval = __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this);
    if (mounted && (__privateGet(this, _currentQuery) !== prevQuery || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) !== resolveEnabled(prevOptions.enabled, __privateGet(this, _currentQuery)) || nextRefetchInterval !== __privateGet(this, _currentRefetchInterval))) {
      __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, nextRefetchInterval);
    }
  }
  getOptimisticResult(options) {
    const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), options);
    const result = this.createResult(query, options);
    if (shouldAssignObserverCurrentProperties(this, result)) {
      __privateSet(this, _currentResult, result);
      __privateSet(this, _currentResultOptions, this.options);
      __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    }
    return result;
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult);
  }
  trackResult(result, onPropTracked) {
    return new Proxy(result, {
      get: (target, key) => {
        this.trackProp(key);
        onPropTracked == null ? void 0 : onPropTracked(key);
        if (key === "promise") {
          this.trackProp("data");
          if (!this.options.experimental_prefetchInRender && __privateGet(this, _currentThenable).status === "pending") {
            __privateGet(this, _currentThenable).reject(
              new Error(
                "experimental_prefetchInRender feature flag is not enabled"
              )
            );
          }
        }
        return Reflect.get(target, key);
      }
    });
  }
  trackProp(key) {
    __privateGet(this, _trackedProps).add(key);
  }
  getCurrentQuery() {
    return __privateGet(this, _currentQuery);
  }
  refetch({ ...options } = {}) {
    return this.fetch({
      ...options
    });
  }
  fetchOptimistic(options) {
    const defaultedOptions = __privateGet(this, _client2).defaultQueryOptions(options);
    const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), defaultedOptions);
    return query.fetch().then(() => this.createResult(query, defaultedOptions));
  }
  fetch(fetchOptions) {
    return __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this, {
      ...fetchOptions,
      cancelRefetch: fetchOptions.cancelRefetch ?? true
    }).then(() => {
      this.updateResult();
      return __privateGet(this, _currentResult);
    });
  }
  createResult(query, options) {
    var _a13;
    const prevQuery = __privateGet(this, _currentQuery);
    const prevOptions = this.options;
    const prevResult = __privateGet(this, _currentResult);
    const prevResultState = __privateGet(this, _currentResultState);
    const prevResultOptions = __privateGet(this, _currentResultOptions);
    const queryChange = query !== prevQuery;
    const queryInitialState = queryChange ? query.state : __privateGet(this, _currentQueryInitialState);
    const { state } = query;
    let newState = { ...state };
    let isPlaceholderData = false;
    let data;
    if (options._optimisticResults) {
      const mounted = this.hasListeners();
      const fetchOnMount = !mounted && shouldFetchOnMount(query, options);
      const fetchOptionally = mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions);
      if (fetchOnMount || fetchOptionally) {
        newState = {
          ...newState,
          ...fetchState(state.data, query.options)
        };
      }
      if (options._optimisticResults === "isRestoring") {
        newState.fetchStatus = "idle";
      }
    }
    let { error, errorUpdatedAt, status } = newState;
    data = newState.data;
    let skipSelect = false;
    if (options.placeholderData !== void 0 && data === void 0 && status === "pending") {
      let placeholderData;
      if ((prevResult == null ? void 0 : prevResult.isPlaceholderData) && options.placeholderData === (prevResultOptions == null ? void 0 : prevResultOptions.placeholderData)) {
        placeholderData = prevResult.data;
        skipSelect = true;
      } else {
        placeholderData = typeof options.placeholderData === "function" ? options.placeholderData(
          (_a13 = __privateGet(this, _lastQueryWithDefinedData)) == null ? void 0 : _a13.state.data,
          __privateGet(this, _lastQueryWithDefinedData)
        ) : options.placeholderData;
      }
      if (placeholderData !== void 0) {
        status = "success";
        data = replaceData(
          prevResult == null ? void 0 : prevResult.data,
          placeholderData,
          options
        );
        isPlaceholderData = true;
      }
    }
    if (options.select && data !== void 0 && !skipSelect) {
      if (prevResult && data === (prevResultState == null ? void 0 : prevResultState.data) && options.select === __privateGet(this, _selectFn)) {
        data = __privateGet(this, _selectResult);
      } else {
        try {
          __privateSet(this, _selectFn, options.select);
          data = options.select(data);
          data = replaceData(prevResult == null ? void 0 : prevResult.data, data, options);
          __privateSet(this, _selectResult, data);
          __privateSet(this, _selectError, null);
        } catch (selectError) {
          __privateSet(this, _selectError, selectError);
        }
      }
    }
    if (__privateGet(this, _selectError)) {
      error = __privateGet(this, _selectError);
      data = __privateGet(this, _selectResult);
      errorUpdatedAt = Date.now();
      status = "error";
    }
    const isFetching = newState.fetchStatus === "fetching";
    const isPending = status === "pending";
    const isError = status === "error";
    const isLoading = isPending && isFetching;
    const hasData = data !== void 0;
    const result = {
      status,
      fetchStatus: newState.fetchStatus,
      isPending,
      isSuccess: status === "success",
      isError,
      isInitialLoading: isLoading,
      isLoading,
      data,
      dataUpdatedAt: newState.dataUpdatedAt,
      error,
      errorUpdatedAt,
      failureCount: newState.fetchFailureCount,
      failureReason: newState.fetchFailureReason,
      errorUpdateCount: newState.errorUpdateCount,
      isFetched: newState.dataUpdateCount > 0 || newState.errorUpdateCount > 0,
      isFetchedAfterMount: newState.dataUpdateCount > queryInitialState.dataUpdateCount || newState.errorUpdateCount > queryInitialState.errorUpdateCount,
      isFetching,
      isRefetching: isFetching && !isPending,
      isLoadingError: isError && !hasData,
      isPaused: newState.fetchStatus === "paused",
      isPlaceholderData,
      isRefetchError: isError && hasData,
      isStale: isStale(query, options),
      refetch: this.refetch,
      promise: __privateGet(this, _currentThenable),
      isEnabled: resolveEnabled(options.enabled, query) !== false
    };
    const nextResult = result;
    if (this.options.experimental_prefetchInRender) {
      const hasResultData = nextResult.data !== void 0;
      const isErrorWithoutData = nextResult.status === "error" && !hasResultData;
      const finalizeThenableIfPossible = (thenable) => {
        if (isErrorWithoutData) {
          thenable.reject(nextResult.error);
        } else if (hasResultData) {
          thenable.resolve(nextResult.data);
        }
      };
      const recreateThenable = () => {
        const pending = __privateSet(this, _currentThenable, nextResult.promise = pendingThenable());
        finalizeThenableIfPossible(pending);
      };
      const prevThenable = __privateGet(this, _currentThenable);
      switch (prevThenable.status) {
        case "pending":
          if (query.queryHash === prevQuery.queryHash) {
            finalizeThenableIfPossible(prevThenable);
          }
          break;
        case "fulfilled":
          if (isErrorWithoutData || nextResult.data !== prevThenable.value) {
            recreateThenable();
          }
          break;
        case "rejected":
          if (!isErrorWithoutData || nextResult.error !== prevThenable.reason) {
            recreateThenable();
          }
          break;
      }
    }
    return nextResult;
  }
  updateResult() {
    const prevResult = __privateGet(this, _currentResult);
    const nextResult = this.createResult(__privateGet(this, _currentQuery), this.options);
    __privateSet(this, _currentResultState, __privateGet(this, _currentQuery).state);
    __privateSet(this, _currentResultOptions, this.options);
    if (__privateGet(this, _currentResultState).data !== void 0) {
      __privateSet(this, _lastQueryWithDefinedData, __privateGet(this, _currentQuery));
    }
    if (shallowEqualObjects(nextResult, prevResult)) {
      return;
    }
    __privateSet(this, _currentResult, nextResult);
    const shouldNotifyListeners = () => {
      if (!prevResult) {
        return true;
      }
      const { notifyOnChangeProps } = this.options;
      const notifyOnChangePropsValue = typeof notifyOnChangeProps === "function" ? notifyOnChangeProps() : notifyOnChangeProps;
      if (notifyOnChangePropsValue === "all" || !notifyOnChangePropsValue && !__privateGet(this, _trackedProps).size) {
        return true;
      }
      const includedProps = new Set(
        notifyOnChangePropsValue ?? __privateGet(this, _trackedProps)
      );
      if (this.options.throwOnError) {
        includedProps.add("error");
      }
      return Object.keys(__privateGet(this, _currentResult)).some((key) => {
        const typedKey = key;
        const changed = __privateGet(this, _currentResult)[typedKey] !== prevResult[typedKey];
        return changed && includedProps.has(typedKey);
      });
    };
    __privateMethod(this, _QueryObserver_instances, notify_fn).call(this, { listeners: shouldNotifyListeners() });
  }
  onQueryUpdate() {
    this.updateResult();
    if (this.hasListeners()) {
      __privateMethod(this, _QueryObserver_instances, updateTimers_fn).call(this);
    }
  }
}, _client2 = new WeakMap(), _currentQuery = new WeakMap(), _currentQueryInitialState = new WeakMap(), _currentResult = new WeakMap(), _currentResultState = new WeakMap(), _currentResultOptions = new WeakMap(), _currentThenable = new WeakMap(), _selectError = new WeakMap(), _selectFn = new WeakMap(), _selectResult = new WeakMap(), _lastQueryWithDefinedData = new WeakMap(), _staleTimeoutId = new WeakMap(), _refetchIntervalId = new WeakMap(), _currentRefetchInterval = new WeakMap(), _trackedProps = new WeakMap(), _QueryObserver_instances = new WeakSet(), executeFetch_fn = function(fetchOptions) {
  __privateMethod(this, _QueryObserver_instances, updateQuery_fn).call(this);
  let promise2 = __privateGet(this, _currentQuery).fetch(
    this.options,
    fetchOptions
  );
  if (!(fetchOptions == null ? void 0 : fetchOptions.throwOnError)) {
    promise2 = promise2.catch(noop2);
  }
  return promise2;
}, updateStaleTimeout_fn = function() {
  __privateMethod(this, _QueryObserver_instances, clearStaleTimeout_fn).call(this);
  const staleTime = resolveStaleTime(
    this.options.staleTime,
    __privateGet(this, _currentQuery)
  );
  if (isServer || __privateGet(this, _currentResult).isStale || !isValidTimeout(staleTime)) {
    return;
  }
  const time3 = timeUntilStale(__privateGet(this, _currentResult).dataUpdatedAt, staleTime);
  const timeout = time3 + 1;
  __privateSet(this, _staleTimeoutId, timeoutManager.setTimeout(() => {
    if (!__privateGet(this, _currentResult).isStale) {
      this.updateResult();
    }
  }, timeout));
}, computeRefetchInterval_fn = function() {
  return (typeof this.options.refetchInterval === "function" ? this.options.refetchInterval(__privateGet(this, _currentQuery)) : this.options.refetchInterval) ?? false;
}, updateRefetchInterval_fn = function(nextInterval) {
  __privateMethod(this, _QueryObserver_instances, clearRefetchInterval_fn).call(this);
  __privateSet(this, _currentRefetchInterval, nextInterval);
  if (isServer || resolveEnabled(this.options.enabled, __privateGet(this, _currentQuery)) === false || !isValidTimeout(__privateGet(this, _currentRefetchInterval)) || __privateGet(this, _currentRefetchInterval) === 0) {
    return;
  }
  __privateSet(this, _refetchIntervalId, timeoutManager.setInterval(() => {
    if (this.options.refetchIntervalInBackground || focusManager.isFocused()) {
      __privateMethod(this, _QueryObserver_instances, executeFetch_fn).call(this);
    }
  }, __privateGet(this, _currentRefetchInterval)));
}, updateTimers_fn = function() {
  __privateMethod(this, _QueryObserver_instances, updateStaleTimeout_fn).call(this);
  __privateMethod(this, _QueryObserver_instances, updateRefetchInterval_fn).call(this, __privateMethod(this, _QueryObserver_instances, computeRefetchInterval_fn).call(this));
}, clearStaleTimeout_fn = function() {
  if (__privateGet(this, _staleTimeoutId)) {
    timeoutManager.clearTimeout(__privateGet(this, _staleTimeoutId));
    __privateSet(this, _staleTimeoutId, void 0);
  }
}, clearRefetchInterval_fn = function() {
  if (__privateGet(this, _refetchIntervalId)) {
    timeoutManager.clearInterval(__privateGet(this, _refetchIntervalId));
    __privateSet(this, _refetchIntervalId, void 0);
  }
}, updateQuery_fn = function() {
  const query = __privateGet(this, _client2).getQueryCache().build(__privateGet(this, _client2), this.options);
  if (query === __privateGet(this, _currentQuery)) {
    return;
  }
  const prevQuery = __privateGet(this, _currentQuery);
  __privateSet(this, _currentQuery, query);
  __privateSet(this, _currentQueryInitialState, query.state);
  if (this.hasListeners()) {
    prevQuery == null ? void 0 : prevQuery.removeObserver(this);
    query.addObserver(this);
  }
}, notify_fn = function(notifyOptions) {
  notifyManager.batch(() => {
    if (notifyOptions.listeners) {
      this.listeners.forEach((listener) => {
        listener(__privateGet(this, _currentResult));
      });
    }
    __privateGet(this, _client2).getQueryCache().notify({
      query: __privateGet(this, _currentQuery),
      type: "observerResultsUpdated"
    });
  });
}, _a7);
function shouldLoadOnMount(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.state.data === void 0 && !(query.state.status === "error" && options.retryOnMount === false);
}
function shouldFetchOnMount(query, options) {
  return shouldLoadOnMount(query, options) || query.state.data !== void 0 && shouldFetchOn(query, options, options.refetchOnMount);
}
function shouldFetchOn(query, options, field) {
  if (resolveEnabled(options.enabled, query) !== false && resolveStaleTime(options.staleTime, query) !== "static") {
    const value = typeof field === "function" ? field(query) : field;
    return value === "always" || value !== false && isStale(query, options);
  }
  return false;
}
function shouldFetchOptionally(query, prevQuery, options, prevOptions) {
  return (query !== prevQuery || resolveEnabled(prevOptions.enabled, query) === false) && (!options.suspense || query.state.status !== "error") && isStale(query, options);
}
function isStale(query, options) {
  return resolveEnabled(options.enabled, query) !== false && query.isStaleByTime(resolveStaleTime(options.staleTime, query));
}
function shouldAssignObserverCurrentProperties(observer, optimisticResult) {
  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {
    return true;
  }
  return false;
}

// node_modules/@tanstack/query-core/build/modern/infiniteQueryBehavior.js
function infiniteQueryBehavior(pages) {
  return {
    onFetch: (context, query) => {
      var _a13, _b, _c, _d, _e;
      const options = context.options;
      const direction = (_c = (_b = (_a13 = context.fetchOptions) == null ? void 0 : _a13.meta) == null ? void 0 : _b.fetchMore) == null ? void 0 : _c.direction;
      const oldPages = ((_d = context.state.data) == null ? void 0 : _d.pages) || [];
      const oldPageParams = ((_e = context.state.data) == null ? void 0 : _e.pageParams) || [];
      let result = { pages: [], pageParams: [] };
      let currentPage = 0;
      const fetchFn = async () => {
        let cancelled = false;
        const addSignalProperty = (object3) => {
          addConsumeAwareSignal(
            object3,
            () => context.signal,
            () => cancelled = true
          );
        };
        const queryFn = ensureQueryFn(context.options, context.fetchOptions);
        const fetchPage = async (data, param, previous) => {
          if (cancelled) {
            return Promise.reject();
          }
          if (param == null && data.pages.length) {
            return Promise.resolve(data);
          }
          const createQueryFnContext = () => {
            const queryFnContext2 = {
              client: context.client,
              queryKey: context.queryKey,
              pageParam: param,
              direction: previous ? "backward" : "forward",
              meta: context.options.meta
            };
            addSignalProperty(queryFnContext2);
            return queryFnContext2;
          };
          const queryFnContext = createQueryFnContext();
          const page = await queryFn(queryFnContext);
          const { maxPages } = context.options;
          const addTo = previous ? addToStart : addToEnd;
          return {
            pages: addTo(data.pages, page, maxPages),
            pageParams: addTo(data.pageParams, param, maxPages)
          };
        };
        if (direction && oldPages.length) {
          const previous = direction === "backward";
          const pageParamFn = previous ? getPreviousPageParam : getNextPageParam;
          const oldData = {
            pages: oldPages,
            pageParams: oldPageParams
          };
          const param = pageParamFn(options, oldData);
          result = await fetchPage(oldData, param, previous);
        } else {
          const remainingPages = pages ?? oldPages.length;
          do {
            const param = currentPage === 0 ? oldPageParams[0] ?? options.initialPageParam : getNextPageParam(options, result);
            if (currentPage > 0 && param == null) {
              break;
            }
            result = await fetchPage(result, param);
            currentPage++;
          } while (currentPage < remainingPages);
        }
        return result;
      };
      if (context.options.persister) {
        context.fetchFn = () => {
          var _a14, _b2;
          return (_b2 = (_a14 = context.options).persister) == null ? void 0 : _b2.call(
            _a14,
            fetchFn,
            {
              client: context.client,
              queryKey: context.queryKey,
              meta: context.options.meta,
              signal: context.signal
            },
            query
          );
        };
      } else {
        context.fetchFn = fetchFn;
      }
    }
  };
}
function getNextPageParam(options, { pages, pageParams }) {
  const lastIndex = pages.length - 1;
  return pages.length > 0 ? options.getNextPageParam(
    pages[lastIndex],
    pages,
    pageParams[lastIndex],
    pageParams
  ) : void 0;
}
function getPreviousPageParam(options, { pages, pageParams }) {
  var _a13;
  return pages.length > 0 ? (_a13 = options.getPreviousPageParam) == null ? void 0 : _a13.call(options, pages[0], pages, pageParams[0], pageParams) : void 0;
}

// node_modules/@tanstack/query-core/build/modern/mutation.js
var _client3, _observers, _mutationCache, _retryer2, _Mutation_instances, dispatch_fn2, _a8;
var Mutation = (_a8 = class extends Removable {
  constructor(config2) {
    super();
    __privateAdd(this, _Mutation_instances);
    __privateAdd(this, _client3);
    __privateAdd(this, _observers);
    __privateAdd(this, _mutationCache);
    __privateAdd(this, _retryer2);
    __privateSet(this, _client3, config2.client);
    this.mutationId = config2.mutationId;
    __privateSet(this, _mutationCache, config2.mutationCache);
    __privateSet(this, _observers, []);
    this.state = config2.state || getDefaultState2();
    this.setOptions(config2.options);
    this.scheduleGc();
  }
  setOptions(options) {
    this.options = options;
    this.updateGcTime(this.options.gcTime);
  }
  get meta() {
    return this.options.meta;
  }
  addObserver(observer) {
    if (!__privateGet(this, _observers).includes(observer)) {
      __privateGet(this, _observers).push(observer);
      this.clearGcTimeout();
      __privateGet(this, _mutationCache).notify({
        type: "observerAdded",
        mutation: this,
        observer
      });
    }
  }
  removeObserver(observer) {
    __privateSet(this, _observers, __privateGet(this, _observers).filter((x) => x !== observer));
    this.scheduleGc();
    __privateGet(this, _mutationCache).notify({
      type: "observerRemoved",
      mutation: this,
      observer
    });
  }
  optionalRemove() {
    if (!__privateGet(this, _observers).length) {
      if (this.state.status === "pending") {
        this.scheduleGc();
      } else {
        __privateGet(this, _mutationCache).remove(this);
      }
    }
  }
  continue() {
    var _a13;
    return ((_a13 = __privateGet(this, _retryer2)) == null ? void 0 : _a13.continue()) ?? // continuing a mutation assumes that variables are set, mutation must have been dehydrated before
    this.execute(this.state.variables);
  }
  async execute(variables) {
    var _a13, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
    const onContinue = () => {
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "continue" });
    };
    const mutationFnContext = {
      client: __privateGet(this, _client3),
      meta: this.options.meta,
      mutationKey: this.options.mutationKey
    };
    __privateSet(this, _retryer2, createRetryer({
      fn: () => {
        if (!this.options.mutationFn) {
          return Promise.reject(new Error("No mutationFn found"));
        }
        return this.options.mutationFn(variables, mutationFnContext);
      },
      onFail: (failureCount, error) => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "failed", failureCount, error });
      },
      onPause: () => {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pause" });
      },
      onContinue,
      retry: this.options.retry ?? 0,
      retryDelay: this.options.retryDelay,
      networkMode: this.options.networkMode,
      canRun: () => __privateGet(this, _mutationCache).canRun(this)
    }));
    const restored = this.state.status === "pending";
    const isPaused = !__privateGet(this, _retryer2).canStart();
    try {
      if (restored) {
        onContinue();
      } else {
        __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "pending", variables, isPaused });
        if (__privateGet(this, _mutationCache).config.onMutate) {
          await __privateGet(this, _mutationCache).config.onMutate(
            variables,
            this,
            mutationFnContext
          );
        }
        const context = await ((_b = (_a13 = this.options).onMutate) == null ? void 0 : _b.call(
          _a13,
          variables,
          mutationFnContext
        ));
        if (context !== this.state.context) {
          __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, {
            type: "pending",
            context,
            variables,
            isPaused
          });
        }
      }
      const data = await __privateGet(this, _retryer2).start();
      await ((_d = (_c = __privateGet(this, _mutationCache).config).onSuccess) == null ? void 0 : _d.call(
        _c,
        data,
        variables,
        this.state.context,
        this,
        mutationFnContext
      ));
      await ((_f = (_e = this.options).onSuccess) == null ? void 0 : _f.call(
        _e,
        data,
        variables,
        this.state.context,
        mutationFnContext
      ));
      await ((_h = (_g = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _h.call(
        _g,
        data,
        null,
        this.state.variables,
        this.state.context,
        this,
        mutationFnContext
      ));
      await ((_j = (_i = this.options).onSettled) == null ? void 0 : _j.call(
        _i,
        data,
        null,
        variables,
        this.state.context,
        mutationFnContext
      ));
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "success", data });
      return data;
    } catch (error) {
      try {
        await ((_l = (_k = __privateGet(this, _mutationCache).config).onError) == null ? void 0 : _l.call(
          _k,
          error,
          variables,
          this.state.context,
          this,
          mutationFnContext
        ));
      } catch (e2) {
        void Promise.reject(e2);
      }
      try {
        await ((_n = (_m = this.options).onError) == null ? void 0 : _n.call(
          _m,
          error,
          variables,
          this.state.context,
          mutationFnContext
        ));
      } catch (e2) {
        void Promise.reject(e2);
      }
      try {
        await ((_p = (_o = __privateGet(this, _mutationCache).config).onSettled) == null ? void 0 : _p.call(
          _o,
          void 0,
          error,
          this.state.variables,
          this.state.context,
          this,
          mutationFnContext
        ));
      } catch (e2) {
        void Promise.reject(e2);
      }
      try {
        await ((_r = (_q = this.options).onSettled) == null ? void 0 : _r.call(
          _q,
          void 0,
          error,
          variables,
          this.state.context,
          mutationFnContext
        ));
      } catch (e2) {
        void Promise.reject(e2);
      }
      __privateMethod(this, _Mutation_instances, dispatch_fn2).call(this, { type: "error", error });
      throw error;
    } finally {
      __privateGet(this, _mutationCache).runNext(this);
    }
  }
}, _client3 = new WeakMap(), _observers = new WeakMap(), _mutationCache = new WeakMap(), _retryer2 = new WeakMap(), _Mutation_instances = new WeakSet(), dispatch_fn2 = function(action) {
  const reducer = (state) => {
    switch (action.type) {
      case "failed":
        return {
          ...state,
          failureCount: action.failureCount,
          failureReason: action.error
        };
      case "pause":
        return {
          ...state,
          isPaused: true
        };
      case "continue":
        return {
          ...state,
          isPaused: false
        };
      case "pending":
        return {
          ...state,
          context: action.context,
          data: void 0,
          failureCount: 0,
          failureReason: null,
          error: null,
          isPaused: action.isPaused,
          status: "pending",
          variables: action.variables,
          submittedAt: Date.now()
        };
      case "success":
        return {
          ...state,
          data: action.data,
          failureCount: 0,
          failureReason: null,
          error: null,
          status: "success",
          isPaused: false
        };
      case "error":
        return {
          ...state,
          data: void 0,
          error: action.error,
          failureCount: state.failureCount + 1,
          failureReason: action.error,
          isPaused: false,
          status: "error"
        };
    }
  };
  this.state = reducer(this.state);
  notifyManager.batch(() => {
    __privateGet(this, _observers).forEach((observer) => {
      observer.onMutationUpdate(action);
    });
    __privateGet(this, _mutationCache).notify({
      mutation: this,
      type: "updated",
      action
    });
  });
}, _a8);
function getDefaultState2() {
  return {
    context: void 0,
    data: void 0,
    error: null,
    failureCount: 0,
    failureReason: null,
    isPaused: false,
    status: "idle",
    variables: void 0,
    submittedAt: 0
  };
}

// node_modules/@tanstack/query-core/build/modern/mutationCache.js
var _mutations, _scopes, _mutationId, _a9;
var MutationCache = (_a9 = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _mutations);
    __privateAdd(this, _scopes);
    __privateAdd(this, _mutationId);
    this.config = config2;
    __privateSet(this, _mutations, /* @__PURE__ */ new Set());
    __privateSet(this, _scopes, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationId, 0);
  }
  build(client, options, state) {
    const mutation = new Mutation({
      client,
      mutationCache: this,
      mutationId: ++__privateWrapper(this, _mutationId)._,
      options: client.defaultMutationOptions(options),
      state
    });
    this.add(mutation);
    return mutation;
  }
  add(mutation) {
    __privateGet(this, _mutations).add(mutation);
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const scopedMutations = __privateGet(this, _scopes).get(scope);
      if (scopedMutations) {
        scopedMutations.push(mutation);
      } else {
        __privateGet(this, _scopes).set(scope, [mutation]);
      }
    }
    this.notify({ type: "added", mutation });
  }
  remove(mutation) {
    if (__privateGet(this, _mutations).delete(mutation)) {
      const scope = scopeFor(mutation);
      if (typeof scope === "string") {
        const scopedMutations = __privateGet(this, _scopes).get(scope);
        if (scopedMutations) {
          if (scopedMutations.length > 1) {
            const index = scopedMutations.indexOf(mutation);
            if (index !== -1) {
              scopedMutations.splice(index, 1);
            }
          } else if (scopedMutations[0] === mutation) {
            __privateGet(this, _scopes).delete(scope);
          }
        }
      }
    }
    this.notify({ type: "removed", mutation });
  }
  canRun(mutation) {
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const mutationsWithSameScope = __privateGet(this, _scopes).get(scope);
      const firstPendingMutation = mutationsWithSameScope == null ? void 0 : mutationsWithSameScope.find(
        (m) => m.state.status === "pending"
      );
      return !firstPendingMutation || firstPendingMutation === mutation;
    } else {
      return true;
    }
  }
  runNext(mutation) {
    var _a13;
    const scope = scopeFor(mutation);
    if (typeof scope === "string") {
      const foundMutation = (_a13 = __privateGet(this, _scopes).get(scope)) == null ? void 0 : _a13.find((m) => m !== mutation && m.state.isPaused);
      return (foundMutation == null ? void 0 : foundMutation.continue()) ?? Promise.resolve();
    } else {
      return Promise.resolve();
    }
  }
  clear() {
    notifyManager.batch(() => {
      __privateGet(this, _mutations).forEach((mutation) => {
        this.notify({ type: "removed", mutation });
      });
      __privateGet(this, _mutations).clear();
      __privateGet(this, _scopes).clear();
    });
  }
  getAll() {
    return Array.from(__privateGet(this, _mutations));
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (mutation) => matchMutation(defaultedFilters, mutation)
    );
  }
  findAll(filters = {}) {
    return this.getAll().filter((mutation) => matchMutation(filters, mutation));
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  resumePausedMutations() {
    const pausedMutations = this.getAll().filter((x) => x.state.isPaused);
    return notifyManager.batch(
      () => Promise.all(
        pausedMutations.map((mutation) => mutation.continue().catch(noop2))
      )
    );
  }
}, _mutations = new WeakMap(), _scopes = new WeakMap(), _mutationId = new WeakMap(), _a9);
function scopeFor(mutation) {
  var _a13;
  return (_a13 = mutation.options.scope) == null ? void 0 : _a13.id;
}

// node_modules/@tanstack/query-core/build/modern/mutationObserver.js
var _client4, _currentResult2, _currentMutation, _mutateOptions, _MutationObserver_instances, updateResult_fn, notify_fn2, _a10;
var MutationObserver = (_a10 = class extends Subscribable {
  constructor(client, options) {
    super();
    __privateAdd(this, _MutationObserver_instances);
    __privateAdd(this, _client4);
    __privateAdd(this, _currentResult2);
    __privateAdd(this, _currentMutation);
    __privateAdd(this, _mutateOptions);
    __privateSet(this, _client4, client);
    this.setOptions(options);
    this.bindMethods();
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
  }
  bindMethods() {
    this.mutate = this.mutate.bind(this);
    this.reset = this.reset.bind(this);
  }
  setOptions(options) {
    var _a13;
    const prevOptions = this.options;
    this.options = __privateGet(this, _client4).defaultMutationOptions(options);
    if (!shallowEqualObjects(this.options, prevOptions)) {
      __privateGet(this, _client4).getMutationCache().notify({
        type: "observerOptionsUpdated",
        mutation: __privateGet(this, _currentMutation),
        observer: this
      });
    }
    if ((prevOptions == null ? void 0 : prevOptions.mutationKey) && this.options.mutationKey && hashKey(prevOptions.mutationKey) !== hashKey(this.options.mutationKey)) {
      this.reset();
    } else if (((_a13 = __privateGet(this, _currentMutation)) == null ? void 0 : _a13.state.status) === "pending") {
      __privateGet(this, _currentMutation).setOptions(this.options);
    }
  }
  onUnsubscribe() {
    var _a13;
    if (!this.hasListeners()) {
      (_a13 = __privateGet(this, _currentMutation)) == null ? void 0 : _a13.removeObserver(this);
    }
  }
  onMutationUpdate(action) {
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this, action);
  }
  getCurrentResult() {
    return __privateGet(this, _currentResult2);
  }
  reset() {
    var _a13;
    (_a13 = __privateGet(this, _currentMutation)) == null ? void 0 : _a13.removeObserver(this);
    __privateSet(this, _currentMutation, void 0);
    __privateMethod(this, _MutationObserver_instances, updateResult_fn).call(this);
    __privateMethod(this, _MutationObserver_instances, notify_fn2).call(this);
  }
  mutate(variables, options) {
    var _a13;
    __privateSet(this, _mutateOptions, options);
    (_a13 = __privateGet(this, _currentMutation)) == null ? void 0 : _a13.removeObserver(this);
    __privateSet(this, _currentMutation, __privateGet(this, _client4).getMutationCache().build(__privateGet(this, _client4), this.options));
    __privateGet(this, _currentMutation).addObserver(this);
    return __privateGet(this, _currentMutation).execute(variables);
  }
}, _client4 = new WeakMap(), _currentResult2 = new WeakMap(), _currentMutation = new WeakMap(), _mutateOptions = new WeakMap(), _MutationObserver_instances = new WeakSet(), updateResult_fn = function() {
  var _a13;
  const state = ((_a13 = __privateGet(this, _currentMutation)) == null ? void 0 : _a13.state) ?? getDefaultState2();
  __privateSet(this, _currentResult2, {
    ...state,
    isPending: state.status === "pending",
    isSuccess: state.status === "success",
    isError: state.status === "error",
    isIdle: state.status === "idle",
    mutate: this.mutate,
    reset: this.reset
  });
}, notify_fn2 = function(action) {
  notifyManager.batch(() => {
    var _a13, _b, _c, _d, _e, _f, _g, _h;
    if (__privateGet(this, _mutateOptions) && this.hasListeners()) {
      const variables = __privateGet(this, _currentResult2).variables;
      const onMutateResult = __privateGet(this, _currentResult2).context;
      const context = {
        client: __privateGet(this, _client4),
        meta: this.options.meta,
        mutationKey: this.options.mutationKey
      };
      if ((action == null ? void 0 : action.type) === "success") {
        try {
          (_b = (_a13 = __privateGet(this, _mutateOptions)).onSuccess) == null ? void 0 : _b.call(
            _a13,
            action.data,
            variables,
            onMutateResult,
            context
          );
        } catch (e2) {
          void Promise.reject(e2);
        }
        try {
          (_d = (_c = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _d.call(
            _c,
            action.data,
            null,
            variables,
            onMutateResult,
            context
          );
        } catch (e2) {
          void Promise.reject(e2);
        }
      } else if ((action == null ? void 0 : action.type) === "error") {
        try {
          (_f = (_e = __privateGet(this, _mutateOptions)).onError) == null ? void 0 : _f.call(
            _e,
            action.error,
            variables,
            onMutateResult,
            context
          );
        } catch (e2) {
          void Promise.reject(e2);
        }
        try {
          (_h = (_g = __privateGet(this, _mutateOptions)).onSettled) == null ? void 0 : _h.call(
            _g,
            void 0,
            action.error,
            variables,
            onMutateResult,
            context
          );
        } catch (e2) {
          void Promise.reject(e2);
        }
      }
    }
    this.listeners.forEach((listener) => {
      listener(__privateGet(this, _currentResult2));
    });
  });
}, _a10);

// node_modules/@tanstack/query-core/build/modern/queryCache.js
var _queries, _a11;
var QueryCache = (_a11 = class extends Subscribable {
  constructor(config2 = {}) {
    super();
    __privateAdd(this, _queries);
    this.config = config2;
    __privateSet(this, _queries, /* @__PURE__ */ new Map());
  }
  build(client, options, state) {
    const queryKey = options.queryKey;
    const queryHash = options.queryHash ?? hashQueryKeyByOptions(queryKey, options);
    let query = this.get(queryHash);
    if (!query) {
      query = new Query({
        client,
        queryKey,
        queryHash,
        options: client.defaultQueryOptions(options),
        state,
        defaultOptions: client.getQueryDefaults(queryKey)
      });
      this.add(query);
    }
    return query;
  }
  add(query) {
    if (!__privateGet(this, _queries).has(query.queryHash)) {
      __privateGet(this, _queries).set(query.queryHash, query);
      this.notify({
        type: "added",
        query
      });
    }
  }
  remove(query) {
    const queryInMap = __privateGet(this, _queries).get(query.queryHash);
    if (queryInMap) {
      query.destroy();
      if (queryInMap === query) {
        __privateGet(this, _queries).delete(query.queryHash);
      }
      this.notify({ type: "removed", query });
    }
  }
  clear() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        this.remove(query);
      });
    });
  }
  get(queryHash) {
    return __privateGet(this, _queries).get(queryHash);
  }
  getAll() {
    return [...__privateGet(this, _queries).values()];
  }
  find(filters) {
    const defaultedFilters = { exact: true, ...filters };
    return this.getAll().find(
      (query) => matchQuery(defaultedFilters, query)
    );
  }
  findAll(filters = {}) {
    const queries = this.getAll();
    return Object.keys(filters).length > 0 ? queries.filter((query) => matchQuery(filters, query)) : queries;
  }
  notify(event) {
    notifyManager.batch(() => {
      this.listeners.forEach((listener) => {
        listener(event);
      });
    });
  }
  onFocus() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onFocus();
      });
    });
  }
  onOnline() {
    notifyManager.batch(() => {
      this.getAll().forEach((query) => {
        query.onOnline();
      });
    });
  }
}, _queries = new WeakMap(), _a11);

// node_modules/@tanstack/query-core/build/modern/queryClient.js
var _queryCache, _mutationCache2, _defaultOptions2, _queryDefaults, _mutationDefaults, _mountCount, _unsubscribeFocus, _unsubscribeOnline, _a12;
var QueryClient = (_a12 = class {
  constructor(config2 = {}) {
    __privateAdd(this, _queryCache);
    __privateAdd(this, _mutationCache2);
    __privateAdd(this, _defaultOptions2);
    __privateAdd(this, _queryDefaults);
    __privateAdd(this, _mutationDefaults);
    __privateAdd(this, _mountCount);
    __privateAdd(this, _unsubscribeFocus);
    __privateAdd(this, _unsubscribeOnline);
    __privateSet(this, _queryCache, config2.queryCache || new QueryCache());
    __privateSet(this, _mutationCache2, config2.mutationCache || new MutationCache());
    __privateSet(this, _defaultOptions2, config2.defaultOptions || {});
    __privateSet(this, _queryDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mutationDefaults, /* @__PURE__ */ new Map());
    __privateSet(this, _mountCount, 0);
  }
  mount() {
    __privateWrapper(this, _mountCount)._++;
    if (__privateGet(this, _mountCount) !== 1) return;
    __privateSet(this, _unsubscribeFocus, focusManager.subscribe(async (focused) => {
      if (focused) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onFocus();
      }
    }));
    __privateSet(this, _unsubscribeOnline, onlineManager.subscribe(async (online2) => {
      if (online2) {
        await this.resumePausedMutations();
        __privateGet(this, _queryCache).onOnline();
      }
    }));
  }
  unmount() {
    var _a13, _b;
    __privateWrapper(this, _mountCount)._--;
    if (__privateGet(this, _mountCount) !== 0) return;
    (_a13 = __privateGet(this, _unsubscribeFocus)) == null ? void 0 : _a13.call(this);
    __privateSet(this, _unsubscribeFocus, void 0);
    (_b = __privateGet(this, _unsubscribeOnline)) == null ? void 0 : _b.call(this);
    __privateSet(this, _unsubscribeOnline, void 0);
  }
  isFetching(filters) {
    return __privateGet(this, _queryCache).findAll({ ...filters, fetchStatus: "fetching" }).length;
  }
  isMutating(filters) {
    return __privateGet(this, _mutationCache2).findAll({ ...filters, status: "pending" }).length;
  }
  /**
   * Imperative (non-reactive) way to retrieve data for a QueryKey.
   * Should only be used in callbacks or functions where reading the latest data is necessary, e.g. for optimistic updates.
   *
   * Hint: Do not use this function inside a component, because it won't receive updates.
   * Use `useQuery` to create a `QueryObserver` that subscribes to changes.
   */
  getQueryData(queryKey) {
    var _a13;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a13 = __privateGet(this, _queryCache).get(options.queryHash)) == null ? void 0 : _a13.state.data;
  }
  ensureQueryData(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    const cachedData = query.state.data;
    if (cachedData === void 0) {
      return this.fetchQuery(options);
    }
    if (options.revalidateIfStale && query.isStaleByTime(resolveStaleTime(defaultedOptions.staleTime, query))) {
      void this.prefetchQuery(defaultedOptions);
    }
    return Promise.resolve(cachedData);
  }
  getQueriesData(filters) {
    return __privateGet(this, _queryCache).findAll(filters).map(({ queryKey, state }) => {
      const data = state.data;
      return [queryKey, data];
    });
  }
  setQueryData(queryKey, updater, options) {
    const defaultedOptions = this.defaultQueryOptions({ queryKey });
    const query = __privateGet(this, _queryCache).get(
      defaultedOptions.queryHash
    );
    const prevData = query == null ? void 0 : query.state.data;
    const data = functionalUpdate(updater, prevData);
    if (data === void 0) {
      return void 0;
    }
    return __privateGet(this, _queryCache).build(this, defaultedOptions).setData(data, { ...options, manual: true });
  }
  setQueriesData(filters, updater, options) {
    return notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map(({ queryKey }) => [
        queryKey,
        this.setQueryData(queryKey, updater, options)
      ])
    );
  }
  getQueryState(queryKey) {
    var _a13;
    const options = this.defaultQueryOptions({ queryKey });
    return (_a13 = __privateGet(this, _queryCache).get(
      options.queryHash
    )) == null ? void 0 : _a13.state;
  }
  removeQueries(filters) {
    const queryCache = __privateGet(this, _queryCache);
    notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        queryCache.remove(query);
      });
    });
  }
  resetQueries(filters, options) {
    const queryCache = __privateGet(this, _queryCache);
    return notifyManager.batch(() => {
      queryCache.findAll(filters).forEach((query) => {
        query.reset();
      });
      return this.refetchQueries(
        {
          type: "active",
          ...filters
        },
        options
      );
    });
  }
  cancelQueries(filters, cancelOptions = {}) {
    const defaultedCancelOptions = { revert: true, ...cancelOptions };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).map((query) => query.cancel(defaultedCancelOptions))
    );
    return Promise.all(promises).then(noop2).catch(noop2);
  }
  invalidateQueries(filters, options = {}) {
    return notifyManager.batch(() => {
      __privateGet(this, _queryCache).findAll(filters).forEach((query) => {
        query.invalidate();
      });
      if ((filters == null ? void 0 : filters.refetchType) === "none") {
        return Promise.resolve();
      }
      return this.refetchQueries(
        {
          ...filters,
          type: (filters == null ? void 0 : filters.refetchType) ?? (filters == null ? void 0 : filters.type) ?? "active"
        },
        options
      );
    });
  }
  refetchQueries(filters, options = {}) {
    const fetchOptions = {
      ...options,
      cancelRefetch: options.cancelRefetch ?? true
    };
    const promises = notifyManager.batch(
      () => __privateGet(this, _queryCache).findAll(filters).filter((query) => !query.isDisabled() && !query.isStatic()).map((query) => {
        let promise2 = query.fetch(void 0, fetchOptions);
        if (!fetchOptions.throwOnError) {
          promise2 = promise2.catch(noop2);
        }
        return query.state.fetchStatus === "paused" ? Promise.resolve() : promise2;
      })
    );
    return Promise.all(promises).then(noop2);
  }
  fetchQuery(options) {
    const defaultedOptions = this.defaultQueryOptions(options);
    if (defaultedOptions.retry === void 0) {
      defaultedOptions.retry = false;
    }
    const query = __privateGet(this, _queryCache).build(this, defaultedOptions);
    return query.isStaleByTime(
      resolveStaleTime(defaultedOptions.staleTime, query)
    ) ? query.fetch(defaultedOptions) : Promise.resolve(query.state.data);
  }
  prefetchQuery(options) {
    return this.fetchQuery(options).then(noop2).catch(noop2);
  }
  fetchInfiniteQuery(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.fetchQuery(options);
  }
  prefetchInfiniteQuery(options) {
    return this.fetchInfiniteQuery(options).then(noop2).catch(noop2);
  }
  ensureInfiniteQueryData(options) {
    options.behavior = infiniteQueryBehavior(options.pages);
    return this.ensureQueryData(options);
  }
  resumePausedMutations() {
    if (onlineManager.isOnline()) {
      return __privateGet(this, _mutationCache2).resumePausedMutations();
    }
    return Promise.resolve();
  }
  getQueryCache() {
    return __privateGet(this, _queryCache);
  }
  getMutationCache() {
    return __privateGet(this, _mutationCache2);
  }
  getDefaultOptions() {
    return __privateGet(this, _defaultOptions2);
  }
  setDefaultOptions(options) {
    __privateSet(this, _defaultOptions2, options);
  }
  setQueryDefaults(queryKey, options) {
    __privateGet(this, _queryDefaults).set(hashKey(queryKey), {
      queryKey,
      defaultOptions: options
    });
  }
  getQueryDefaults(queryKey) {
    const defaults = [...__privateGet(this, _queryDefaults).values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(queryKey, queryDefault.queryKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  setMutationDefaults(mutationKey, options) {
    __privateGet(this, _mutationDefaults).set(hashKey(mutationKey), {
      mutationKey,
      defaultOptions: options
    });
  }
  getMutationDefaults(mutationKey) {
    const defaults = [...__privateGet(this, _mutationDefaults).values()];
    const result = {};
    defaults.forEach((queryDefault) => {
      if (partialMatchKey(mutationKey, queryDefault.mutationKey)) {
        Object.assign(result, queryDefault.defaultOptions);
      }
    });
    return result;
  }
  defaultQueryOptions(options) {
    if (options._defaulted) {
      return options;
    }
    const defaultedOptions = {
      ...__privateGet(this, _defaultOptions2).queries,
      ...this.getQueryDefaults(options.queryKey),
      ...options,
      _defaulted: true
    };
    if (!defaultedOptions.queryHash) {
      defaultedOptions.queryHash = hashQueryKeyByOptions(
        defaultedOptions.queryKey,
        defaultedOptions
      );
    }
    if (defaultedOptions.refetchOnReconnect === void 0) {
      defaultedOptions.refetchOnReconnect = defaultedOptions.networkMode !== "always";
    }
    if (defaultedOptions.throwOnError === void 0) {
      defaultedOptions.throwOnError = !!defaultedOptions.suspense;
    }
    if (!defaultedOptions.networkMode && defaultedOptions.persister) {
      defaultedOptions.networkMode = "offlineFirst";
    }
    if (defaultedOptions.queryFn === skipToken) {
      defaultedOptions.enabled = false;
    }
    return defaultedOptions;
  }
  defaultMutationOptions(options) {
    if (options == null ? void 0 : options._defaulted) {
      return options;
    }
    return {
      ...__privateGet(this, _defaultOptions2).mutations,
      ...(options == null ? void 0 : options.mutationKey) && this.getMutationDefaults(options.mutationKey),
      ...options,
      _defaulted: true
    };
  }
  clear() {
    __privateGet(this, _queryCache).clear();
    __privateGet(this, _mutationCache2).clear();
  }
}, _queryCache = new WeakMap(), _mutationCache2 = new WeakMap(), _defaultOptions2 = new WeakMap(), _queryDefaults = new WeakMap(), _mutationDefaults = new WeakMap(), _mountCount = new WeakMap(), _unsubscribeFocus = new WeakMap(), _unsubscribeOnline = new WeakMap(), _a12);

// node_modules/@tanstack/query-core/build/modern/types.js
var dataTagSymbol = Symbol("dataTagSymbol");
var dataTagErrorSymbol = Symbol("dataTagErrorSymbol");
var unsetMarker = Symbol("unsetMarker");

// node_modules/@tanstack/react-query/build/modern/useQueries.js
var React5 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/QueryClientProvider.js
var React = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var QueryClientContext = React.createContext(
  void 0
);
var useQueryClient = (queryClient) => {
  const client = React.useContext(QueryClientContext);
  if (queryClient) {
    return queryClient;
  }
  if (!client) {
    throw new Error("No QueryClient set, use QueryClientProvider to set one");
  }
  return client;
};

// node_modules/@tanstack/react-query/build/modern/IsRestoringProvider.js
var React2 = __toESM(require_react(), 1);
var IsRestoringContext = React2.createContext(false);
var useIsRestoring = () => React2.useContext(IsRestoringContext);
var IsRestoringProvider = IsRestoringContext.Provider;

// node_modules/@tanstack/react-query/build/modern/QueryErrorResetBoundary.js
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
function createValue() {
  let isReset = false;
  return {
    clearReset: () => {
      isReset = false;
    },
    reset: () => {
      isReset = true;
    },
    isReset: () => {
      return isReset;
    }
  };
}
var QueryErrorResetBoundaryContext = React3.createContext(createValue());
var useQueryErrorResetBoundary = () => React3.useContext(QueryErrorResetBoundaryContext);

// node_modules/@tanstack/react-query/build/modern/errorBoundaryUtils.js
var React4 = __toESM(require_react(), 1);
var ensurePreventErrorBoundaryRetry = (options, errorResetBoundary, query) => {
  const throwOnError = (query == null ? void 0 : query.state.error) && typeof options.throwOnError === "function" ? shouldThrowError(options.throwOnError, [query.state.error, query]) : options.throwOnError;
  if (options.suspense || options.experimental_prefetchInRender || throwOnError) {
    if (!errorResetBoundary.isReset()) {
      options.retryOnMount = false;
    }
  }
};
var useClearResetErrorBoundary = (errorResetBoundary) => {
  React4.useEffect(() => {
    errorResetBoundary.clearReset();
  }, [errorResetBoundary]);
};
var getHasError = ({
  result,
  errorResetBoundary,
  throwOnError,
  query,
  suspense
}) => {
  return result.isError && !errorResetBoundary.isReset() && !result.isFetching && query && (suspense && result.data === void 0 || shouldThrowError(throwOnError, [result.error, query]));
};

// node_modules/@tanstack/react-query/build/modern/suspense.js
var ensureSuspenseTimers = (defaultedOptions) => {
  if (defaultedOptions.suspense) {
    const MIN_SUSPENSE_TIME_MS = 1e3;
    const clamp = (value) => value === "static" ? value : Math.max(value ?? MIN_SUSPENSE_TIME_MS, MIN_SUSPENSE_TIME_MS);
    const originalStaleTime = defaultedOptions.staleTime;
    defaultedOptions.staleTime = typeof originalStaleTime === "function" ? (...args) => clamp(originalStaleTime(...args)) : clamp(originalStaleTime);
    if (typeof defaultedOptions.gcTime === "number") {
      defaultedOptions.gcTime = Math.max(
        defaultedOptions.gcTime,
        MIN_SUSPENSE_TIME_MS
      );
    }
  }
};
var willFetch = (result, isRestoring) => result.isLoading && result.isFetching && !isRestoring;
var shouldSuspend = (defaultedOptions, result) => (defaultedOptions == null ? void 0 : defaultedOptions.suspense) && result.isPending;
var fetchOptimistic = (defaultedOptions, observer, errorResetBoundary) => observer.fetchOptimistic(defaultedOptions).catch(() => {
  errorResetBoundary.clearReset();
});

// node_modules/@tanstack/react-query/build/modern/useBaseQuery.js
var React6 = __toESM(require_react(), 1);
function useBaseQuery(options, Observer, queryClient) {
  var _a13, _b, _c, _d;
  if (true) {
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new Error(
        'Bad argument type. Starting with v5, only the "Object" form is allowed when calling query related functions. Please use the error stack to find the culprit call. More info here: https://tanstack.com/query/latest/docs/react/guides/migrating-to-v5#supports-a-single-signature-one-object'
      );
    }
  }
  const isRestoring = useIsRestoring();
  const errorResetBoundary = useQueryErrorResetBoundary();
  const client = useQueryClient(queryClient);
  const defaultedOptions = client.defaultQueryOptions(options);
  (_b = (_a13 = client.getDefaultOptions().queries) == null ? void 0 : _a13._experimental_beforeQuery) == null ? void 0 : _b.call(
    _a13,
    defaultedOptions
  );
  const query = client.getQueryCache().get(defaultedOptions.queryHash);
  if (true) {
    if (!defaultedOptions.queryFn) {
      console.error(
        `[${defaultedOptions.queryHash}]: No queryFn was passed as an option, and no default queryFn was found. The queryFn parameter is only optional when using a default queryFn. More info here: https://tanstack.com/query/latest/docs/framework/react/guides/default-query-function`
      );
    }
  }
  defaultedOptions._optimisticResults = isRestoring ? "isRestoring" : "optimistic";
  ensureSuspenseTimers(defaultedOptions);
  ensurePreventErrorBoundaryRetry(defaultedOptions, errorResetBoundary, query);
  useClearResetErrorBoundary(errorResetBoundary);
  const isNewCacheEntry = !client.getQueryCache().get(defaultedOptions.queryHash);
  const [observer] = React6.useState(
    () => new Observer(
      client,
      defaultedOptions
    )
  );
  const result = observer.getOptimisticResult(defaultedOptions);
  const shouldSubscribe = !isRestoring && options.subscribed !== false;
  React6.useSyncExternalStore(
    React6.useCallback(
      (onStoreChange) => {
        const unsubscribe = shouldSubscribe ? observer.subscribe(notifyManager.batchCalls(onStoreChange)) : noop2;
        observer.updateResult();
        return unsubscribe;
      },
      [observer, shouldSubscribe]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  React6.useEffect(() => {
    observer.setOptions(defaultedOptions);
  }, [defaultedOptions, observer]);
  if (shouldSuspend(defaultedOptions, result)) {
    throw fetchOptimistic(defaultedOptions, observer, errorResetBoundary);
  }
  if (getHasError({
    result,
    errorResetBoundary,
    throwOnError: defaultedOptions.throwOnError,
    query,
    suspense: defaultedOptions.suspense
  })) {
    throw result.error;
  }
  ;
  (_d = (_c = client.getDefaultOptions().queries) == null ? void 0 : _c._experimental_afterQuery) == null ? void 0 : _d.call(
    _c,
    defaultedOptions,
    result
  );
  if (defaultedOptions.experimental_prefetchInRender && !isServer && willFetch(result, isRestoring)) {
    const promise2 = isNewCacheEntry ? (
      // Fetch immediately on render in order to ensure `.promise` is resolved even if the component is unmounted
      fetchOptimistic(defaultedOptions, observer, errorResetBoundary)
    ) : (
      // subscribe to the "cache promise" so that we can finalize the currentThenable once data comes in
      query == null ? void 0 : query.promise
    );
    promise2 == null ? void 0 : promise2.catch(noop2).finally(() => {
      observer.updateResult();
    });
  }
  return !defaultedOptions.notifyOnChangeProps ? observer.trackResult(result) : result;
}

// node_modules/@tanstack/react-query/build/modern/useQuery.js
function useQuery(options, queryClient) {
  return useBaseQuery(options, QueryObserver, queryClient);
}

// node_modules/@tanstack/react-query/build/modern/HydrationBoundary.js
var React7 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useIsFetching.js
var React8 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useMutationState.js
var React9 = __toESM(require_react(), 1);

// node_modules/@tanstack/react-query/build/modern/useMutation.js
var React10 = __toESM(require_react(), 1);
function useMutation(options, queryClient) {
  const client = useQueryClient(queryClient);
  const [observer] = React10.useState(
    () => new MutationObserver(
      client,
      options
    )
  );
  React10.useEffect(() => {
    observer.setOptions(options);
  }, [observer, options]);
  const result = React10.useSyncExternalStore(
    React10.useCallback(
      (onStoreChange) => observer.subscribe(notifyManager.batchCalls(onStoreChange)),
      [observer]
    ),
    () => observer.getCurrentResult(),
    () => observer.getCurrentResult()
  );
  const mutate = React10.useCallback(
    (variables, mutateOptions) => {
      observer.mutate(variables, mutateOptions).catch(noop2);
    },
    [observer]
  );
  if (result.error && shouldThrowError(observer.options.throwOnError, [result.error])) {
    throw result.error;
  }
  return { ...result, mutate, mutateAsync: result.mutate };
}

// node_modules/@tambo-ai/react/esm/providers/tambo-client-provider.js
var import_react3 = __toESM(require_react());

// node_modules/@tambo-ai/react/package.json
var package_default = {
  name: "@tambo-ai/react",
  version: "0.70.0",
  description: "React client package for Tambo AI",
  license: "MIT",
  repository: {
    type: "git",
    url: "https://github.com/tambo-ai/tambo.git",
    directory: "react-sdk"
  },
  homepage: "https://tambo.co",
  main: "./dist/index.js",
  module: "./esm/index.js",
  types: "./dist/index.d.ts",
  exports: {
    ".": {
      import: "./esm/index.js",
      require: "./dist/index.js",
      types: "./dist/index.d.ts"
    },
    "./mcp": {
      import: "./esm/mcp/index.js",
      require: "./dist/mcp/index.js",
      types: "./dist/mcp/index.d.ts"
    },
    "./v1": {
      import: "./esm/v1/index.js",
      require: "./dist/v1/index.js",
      types: "./dist/v1/index.d.ts"
    }
  },
  files: [
    "dist",
    "esm",
    "LICENSE"
  ],
  volta: {
    extends: "../package.json"
  },
  sideEffects: false,
  scripts: {
    build: "npm run build:cjs && npm run build:esm",
    "build:cjs": "tsc -p tsconfig.cjs.json",
    "build:esm": "tsc -p tsconfig.esm.json",
    "check-types": "tsc --noEmit",
    dev: 'concurrently "npm run dev:cjs" "npm run dev:esm"',
    "dev:cjs": "tsc -p tsconfig.cjs.json --watch",
    "dev:esm": "tsc -p tsconfig.esm.json --watch",
    test: "jest --config jest.config.ts",
    format: "prettier --write .",
    lint: "eslint",
    "lint:fix": "eslint --fix",
    "format:lint": "npm run format && npm run lint:fix",
    prepare: "husky",
    clean: "rimraf dist esm coverage"
  },
  "lint-staged": {
    "*.{js,jsx,ts,tsx}": [
      "prettier --write",
      "eslint --fix"
    ],
    "*.{json,md,yml,yaml}": [
      "prettier --write"
    ]
  },
  peerDependencies: {
    "@modelcontextprotocol/sdk": "^1.25.1",
    "@types/react": "^18.0.0 || ^19.0.0",
    "@types/react-dom": "^18.0.0 || ^19.0.0",
    react: "^18.0.0 || ^19.0.0",
    "react-dom": "^18.0.0 || ^19.0.0",
    zod: "^3.25.76 || ^4",
    "zod-to-json-schema": "^3.25.1"
  },
  peerDependenciesMeta: {
    "@modelcontextprotocol/sdk": {
      optional: true
    },
    "zod-to-json-schema": {
      optional: true
    }
  },
  dependencies: {
    "@ag-ui/core": "^0.0.42",
    "@modelcontextprotocol/sdk": "^1.25.1",
    "@standard-community/standard-json": "^0.3.5",
    "@standard-schema/spec": "^1.1.0",
    "@tambo-ai/typescript-sdk": "^0.84.0",
    "@tanstack/react-query": "^5.90.16",
    "fast-equals": "^5.3.3",
    "partial-json": "^0.1.7",
    "react-fast-compare": "^3.2.2",
    "react-media-recorder": "^1.7.2",
    "ts-node": "^10.9.2",
    "type-fest": "^5.4.1",
    "use-debounce": "^10.0.6"
  },
  devDependencies: {
    "@eslint/js": "^9.39.2",
    "@modelcontextprotocol/sdk": "^1.25.1",
    "@tambo-ai/eslint-config": "*",
    "@tambo-ai/typescript-config": "*",
    "@testing-library/jest-dom": "^6.9.1",
    "@testing-library/react": "^16.3.1",
    "@types/jest": "^30.0.0",
    "@types/json-schema": "^7.0.15",
    "@types/node": "^22.19.5",
    "@types/react": "^18.3.23",
    "@types/react-dom": "^18.3.7",
    "@valibot/to-json-schema": "^1.5.0",
    concurrently: "^9.2.1",
    eslint: "^9.39.2",
    "eslint-plugin-jsdoc": "^62.0.0",
    "eslint-plugin-react": "^7.37.5",
    "eslint-plugin-react-hooks": "^6.1.1",
    jest: "^30.2.0",
    "jest-environment-jsdom": "^30.2.0",
    "lint-staged": "^16.2.7",
    prettier: "^3.8.0",
    "prettier-2": "npm:prettier@^2",
    react: "^18.3.1",
    "react-dom": "^18.3.1",
    "ts-jest": "^29.4.6",
    typescript: "^5.9.3",
    "typescript-eslint": "^8.53.0",
    zod: "^3.25.76 || ^4",
    "zod-to-json-schema": "^3.25.1"
  }
};

// node_modules/@tambo-ai/react/esm/providers/hooks/use-tambo-session-token.js
var import_react2 = __toESM(require_react());
function useTamboSessionToken(client, queryClient, userToken) {
  var _a13;
  const result = useQuery({
    queryKey: ["tambo-session-token", userToken],
    queryFn: async () => {
      const tokenRequest = {
        grant_type: "urn:ietf:params:oauth:grant-type:token-exchange",
        // will only be undefined if the userToken is not provided, in which case the query will be disabled.
        subject_token: userToken,
        subject_token_type: "urn:ietf:params:oauth:token-type:access_token"
      };
      const tokenRequestFormEncoded = new URLSearchParams(tokenRequest).toString();
      const tokenAsArrayBuffer = new TextEncoder().encode(tokenRequestFormEncoded);
      return await client.beta.auth.getToken(tokenAsArrayBuffer);
    },
    enabled: !!userToken,
    refetchInterval: (result2) => {
      var _a14;
      if ((_a14 = result2.state.data) == null ? void 0 : _a14.expires_in) {
        return result2.state.data.expires_in * 1e3;
      }
      return false;
    }
  }, queryClient);
  const accessToken = ((_a13 = result.data) == null ? void 0 : _a13.access_token) ?? null;
  (0, import_react2.useEffect)(() => {
    client.bearer = accessToken;
  }, [accessToken, client]);
  return result;
}

// node_modules/@tambo-ai/react/esm/providers/tambo-client-provider.js
var TamboClientContext = (0, import_react3.createContext)(void 0);
var TamboClientProvider = ({ children, tamboUrl, apiKey, environment, userToken, additionalHeaders }) => {
  const tamboConfig = (0, import_react3.useMemo)(() => ({
    apiKey,
    defaultHeaders: {
      "X-Tambo-React-Version": package_default.version,
      ...additionalHeaders
    },
    baseURL: tamboUrl ?? void 0,
    environment: environment ?? void 0
  }), [additionalHeaders, apiKey, tamboUrl, environment]);
  const client = (0, import_react3.useMemo)(() => new TamboAI(tamboConfig), [tamboConfig]);
  const queryClient = (0, import_react3.useMemo)(() => new QueryClient(), []);
  const { isFetching: isUpdatingToken } = useTamboSessionToken(client, queryClient, userToken);
  return import_react3.default.createElement(TamboClientContext.Provider, { value: {
    client,
    queryClient,
    isUpdatingToken,
    additionalHeaders: tamboConfig.defaultHeaders
  } }, children);
};
var useTamboClient = () => {
  const context = import_react3.default.useContext(TamboClientContext);
  if (context === void 0) {
    throw new Error("useTamboClient must be used within a TamboClientProvider");
  }
  return context.client;
};
var useTamboQueryClient = () => {
  const context = import_react3.default.useContext(TamboClientContext);
  if (context === void 0) {
    throw new Error("useTamboQueryClient must be used within a TamboClientProvider");
  }
  return context.queryClient;
};
var useIsTamboTokenUpdating = () => {
  const context = import_react3.default.useContext(TamboClientContext);
  if (context === void 0) {
    throw new Error("useIsTamboTokenUpdating must be used within a TamboClientProvider");
  }
  return context.isUpdatingToken;
};

// node_modules/@tambo-ai/react/esm/providers/tambo-registry-provider.js
var import_react4 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/model/mcp-server-info.js
var MCPTransport;
(function(MCPTransport2) {
  MCPTransport2["SSE"] = "sse";
  MCPTransport2["HTTP"] = "http";
})(MCPTransport || (MCPTransport = {}));
function getMcpServerUniqueKey(serverInfo) {
  const headerStr = serverInfo.customHeaders ? JSON.stringify(Object.entries(serverInfo.customHeaders).map(([k, v]) => [k.toLowerCase(), v]).sort(([a], [b]) => a.localeCompare(b))) : "";
  return `${serverInfo.url}|${serverInfo.transport ?? MCPTransport.HTTP}|${headerStr}`;
}

// node_modules/@tambo-ai/react/esm/util/mcp-server-utils.js
function deriveServerKey(url4) {
  var _a13;
  try {
    const parsed = new URL(url4);
    const hostname = parsed.hostname;
    const parts = hostname.split(".");
    let relevantParts = [...parts];
    if (relevantParts.length >= 3 && relevantParts[relevantParts.length - 1].length <= 3 && relevantParts[relevantParts.length - 2].length <= 3) {
      relevantParts = relevantParts.slice(0, -2);
    } else if (relevantParts.length >= 2) {
      relevantParts = relevantParts.slice(0, -1);
    }
    const commonPrefixes = /* @__PURE__ */ new Set([
      "www",
      "api",
      "mcp",
      "app",
      "staging",
      "dev",
      "prod"
    ]);
    for (let i = relevantParts.length - 1; i >= 0; i--) {
      const part = relevantParts[i];
      if (part && !commonPrefixes.has(part.toLowerCase())) {
        return part.toLowerCase();
      }
    }
    return ((_a13 = relevantParts[relevantParts.length - 1]) == null ? void 0 : _a13.toLowerCase()) || hostname;
  } catch {
    return url4.replace(/[^a-zA-Z0-9]/g, "_").toLowerCase();
  }
}
function normalizeServerInfo(server) {
  const base = typeof server === "string" ? {
    url: server,
    transport: MCPTransport.HTTP
  } : server;
  const serverKey = base.serverKey ?? deriveServerKey(base.url);
  const transport = base.transport ?? MCPTransport.HTTP;
  return { ...base, transport, serverKey };
}
function deduplicateMcpServers(servers) {
  if (servers.length === 0) {
    return servers;
  }
  const byKey = /* @__PURE__ */ new Map();
  for (const server of servers) {
    const key = getMcpServerUniqueKey(server);
    byKey.set(key, server);
  }
  const deduped = Array.from(byKey.values());
  const seen = /* @__PURE__ */ new Map();
  return deduped.map((server) => {
    const baseKey = server.serverKey;
    const count = (seen.get(baseKey) ?? 0) + 1;
    seen.set(baseKey, count);
    if (count === 1) {
      return server;
    }
    return {
      ...server,
      serverKey: `${baseKey}-${count}`
    };
  });
}

// node_modules/@tambo-ai/react/esm/util/registry-validators.js
function isObjectSchema(schema) {
  return schema.type === "object" || schema.properties !== void 0;
}
function assertObjectSchema(schema, context) {
  let jsonSchema;
  if (isStandardSchema(schema)) {
    try {
      jsonSchema = schemaToJsonSchema(schema);
    } catch {
      return;
    }
  } else if (looksLikeJSONSchema(schema)) {
    jsonSchema = schema;
  } else {
    return;
  }
  if (!isObjectSchema(jsonSchema)) {
    throw new Error(`${context} must be an object schema (e.g., z.object({...})). Received type: "${jsonSchema.type ?? "unknown"}". Tool parameters are passed as a single object argument.`);
  }
}
function validateTool(tool) {
  if (!tool || typeof tool !== "object") {
    throw new Error("Tool must be an object");
  }
  const toolName = "name" in tool && typeof tool.name === "string" ? tool.name : "<unknown>";
  if ("toolSchema" in tool) {
    throw new Error(`Tool "${toolName}" uses deprecated "toolSchema" property. Migrate to "inputSchema" and "outputSchema" properties. See migration guide: https://tambo.ai/docs/migration/toolschema`);
  }
  if (!("name" in tool) || typeof tool.name !== "string") {
    throw new Error("Tool must have a 'name' property of type string");
  }
  if (!("description" in tool) || typeof tool.description !== "string") {
    throw new Error(`Tool "${tool.name}" must have a 'description' property of type string`);
  }
  if (!("tool" in tool) || typeof tool.tool !== "function") {
    throw new Error(`Tool "${tool.name}" must have a 'tool' property of type function`);
  }
  if (!("inputSchema" in tool)) {
    throw new Error(`Tool "${tool.name}" must have an 'inputSchema' property`);
  }
  if (!("outputSchema" in tool)) {
    throw new Error(`Tool "${tool.name}" must have an 'outputSchema' property`);
  }
  assertValidName(tool.name, "tool");
  if (tool.inputSchema) {
    assertObjectSchema(tool.inputSchema, `inputSchema of tool "${tool.name}"`);
    assertNoRecordSchema(tool.inputSchema, `inputSchema of tool "${tool.name}"`);
  }
  if ("maxCalls" in tool && tool.maxCalls !== void 0 && tool.maxCalls !== null) {
    const maxCalls = tool.maxCalls;
    if (typeof maxCalls !== "number" || !Number.isInteger(maxCalls) || maxCalls < 0) {
      throw new Error(`maxCalls for tool "${tool.name}" must be a positive integer`);
    }
  }
}
function getSerializedProps(propsDefinition, propsSchema, name) {
  if (propsDefinition) {
    console.warn(`propsDefinition is deprecated. Use propsSchema instead.`);
    return propsDefinition;
  }
  if (isStandardSchema(propsSchema)) {
    try {
      return schemaToJsonSchema(propsSchema);
    } catch (error) {
      console.error(`Error converting ${name} props schema to JSON Schema:`, error);
      throw new Error(`Error converting ${name} props schema to JSON Schema: ${error}`);
    }
  }
  if (looksLikeJSONSchema(propsSchema)) {
    return propsSchema;
  }
  throw new Error(`Invalid props schema for ${name}`);
}
function validateAndPrepareComponent(component) {
  const { name, propsSchema, propsDefinition } = component;
  assertValidName(name, "component");
  if (!propsSchema && !propsDefinition) {
    throw new Error(`Component ${name} must have either propsSchema (recommended) or propsDefinition defined`);
  }
  if (propsSchema && propsDefinition) {
    throw new Error(`Component ${name} cannot have both propsSchema and propsDefinition defined. Use only one. We recommend using propsSchema.`);
  }
  if (propsSchema) {
    assertNoRecordSchema(propsSchema, `propsSchema of component "${name}"`);
  }
  const props = getSerializedProps(propsDefinition, propsSchema, name);
  return { props };
}
function validateToolAssociation(componentName, toolName, componentExists, toolExists) {
  assertValidName(componentName, "component");
  assertValidName(toolName, "tool");
  if (!componentExists) {
    throw new Error(`Component ${componentName} not found in registry`);
  }
  if (!toolExists) {
    throw new Error(`Tool ${toolName} not found in registry`);
  }
}

// node_modules/@tambo-ai/react/esm/util/resource-validators.js
function validateResourceSource(listResources, getResource) {
  const hasListResources = listResources != null;
  const hasGetResource = getResource != null;
  if (hasListResources !== hasGetResource) {
    throw new Error(`Both listResources and getResource must be provided together, or neither should be provided. Got: listResources=${hasListResources ? "defined" : "undefined"}, getResource=${hasGetResource ? "defined" : "undefined"}`);
  }
}
function validateResource(resource) {
  if (!resource.uri) {
    throw new Error("Resource must have a 'uri' field");
  }
  if (!resource.name) {
    throw new Error(`Resource with URI '${resource.uri}' must have a 'name' field`);
  }
}

// node_modules/@tambo-ai/react/esm/providers/tambo-registry-provider.js
var TamboRegistryContext = (0, import_react4.createContext)({
  componentList: {},
  toolRegistry: {},
  componentToolAssociations: {},
  mcpServerInfos: [],
  resources: [],
  resourceSource: null,
  /**
   *
   */
  registerComponent: () => {
  },
  /**
   *
   */
  registerTool: () => {
  },
  /**
   *
   */
  registerTools: () => {
  },
  /**
   *
   */
  addToolAssociation: () => {
  },
  /**
   *
   */
  registerMcpServer: () => {
  },
  /**
   *
   */
  registerMcpServers: () => {
  },
  /**
   *
   */
  registerResource: () => {
  },
  /**
   *
   */
  registerResources: () => {
  },
  /**
   *
   */
  registerResourceSource: () => {
  }
});
var TamboRegistryProvider = ({ children, components: userComponents, tools: userTools, mcpServers: userMcpServers, resources: userResources, listResources: userListResources, getResource: userGetResource, onCallUnregisteredTool }) => {
  const [componentList, setComponentList] = (0, import_react4.useState)({});
  const [toolRegistry, setToolRegistry] = (0, import_react4.useState)({});
  const [componentToolAssociations, setComponentToolAssociations] = (0, import_react4.useState)({});
  const [staticMcpServerInfos, setStaticMcpServerInfos] = (0, import_react4.useState)([]);
  const [dynamicMcpServerInfos, setDynamicMcpServerInfos] = (0, import_react4.useState)([]);
  const [staticResources, setStaticResources] = (0, import_react4.useState)([]);
  const [resourceSource, setResourceSource] = (0, import_react4.useState)(null);
  const registryWithTool = (0, import_react4.useCallback)((warnOnOverwrite) => {
    return (registry2, tool) => {
      validateTool(tool);
      if (registry2[tool.name] && warnOnOverwrite) {
        console.warn(`Overwriting tool ${tool.name}`);
      }
      return {
        ...registry2,
        [tool.name]: tool
      };
    };
  }, []);
  const registerTool = (0, import_react4.useCallback)((tool, warnOnOverwrite = true) => {
    setToolRegistry((registry2) => registryWithTool(warnOnOverwrite)(registry2, tool));
  }, [registryWithTool]);
  const registerTools = (0, import_react4.useCallback)((tools, warnOnOverwrite = true) => {
    setToolRegistry((existingRegistry) => tools.reduce(registryWithTool(warnOnOverwrite), existingRegistry));
  }, [registryWithTool]);
  const registerMcpServer = (0, import_react4.useCallback)((info) => {
    const normalized = normalizeServerInfo(info);
    setDynamicMcpServerInfos((prev) => [...prev, normalized]);
  }, []);
  const registerMcpServers = (0, import_react4.useCallback)((infos) => {
    const normalized = infos.map(normalizeServerInfo);
    setDynamicMcpServerInfos((prev) => [...prev, ...normalized]);
  }, []);
  const addToolAssociation = (0, import_react4.useCallback)((componentName, tool) => {
    validateToolAssociation(componentName, tool.name, !!componentList[componentName], !!toolRegistry[tool.name]);
    setComponentToolAssociations((prev) => ({
      ...prev,
      [componentName]: [...prev[componentName] || [], tool.name]
    }));
  }, [componentList, toolRegistry]);
  const registerComponent = (0, import_react4.useCallback)((options, warnOnOverwrite = true) => {
    const { name, description, component, loadingComponent, associatedTools } = options;
    const { props } = validateAndPrepareComponent(options);
    setComponentList((prev) => {
      if (prev[name] && warnOnOverwrite) {
        console.warn(`overwriting component ${name}`);
      }
      return {
        ...prev,
        [name]: {
          component,
          loadingComponent,
          name,
          description,
          props,
          contextTools: []
        }
      };
    });
    if (associatedTools) {
      registerTools(associatedTools);
      setComponentToolAssociations((prev) => ({
        ...prev,
        [name]: associatedTools.map((tool) => tool.name)
      }));
    }
  }, [registerTools]);
  (0, import_react4.useEffect)(() => {
    if (userComponents) {
      userComponents.forEach((component) => {
        registerComponent(component, false);
      });
    }
  }, [registerComponent, userComponents]);
  (0, import_react4.useEffect)(() => {
    if (userTools) {
      registerTools(userTools, false);
    }
  }, [registerTools, userTools]);
  (0, import_react4.useEffect)(() => {
    if (!userMcpServers || userMcpServers.length === 0) {
      setStaticMcpServerInfos([]);
      return;
    }
    const normalized = userMcpServers.map(normalizeServerInfo);
    setStaticMcpServerInfos(normalized);
  }, [userMcpServers]);
  (0, import_react4.useEffect)(() => {
    validateResourceSource(userListResources, userGetResource);
    if (userResources) {
      userResources.forEach((resource) => validateResource(resource));
      setStaticResources(userResources);
    } else {
      setStaticResources([]);
    }
    if (userListResources && userGetResource) {
      setResourceSource({
        listResources: userListResources,
        getResource: userGetResource
      });
    } else {
      setResourceSource(null);
    }
  }, [userResources, userListResources, userGetResource]);
  const registerResource = (0, import_react4.useCallback)((resource) => {
    validateResource(resource);
    setStaticResources((prev) => [...prev, resource]);
  }, []);
  const registerResources = (0, import_react4.useCallback)((resources) => {
    resources.forEach((resource) => validateResource(resource));
    setStaticResources((prev) => [...prev, ...resources]);
  }, []);
  const registerResourceSource = (0, import_react4.useCallback)((source) => {
    validateResourceSource(source.listResources, source.getResource);
    setResourceSource(source);
  }, []);
  const mcpServerInfos = (0, import_react4.useMemo)(() => {
    const allServers = [...staticMcpServerInfos, ...dynamicMcpServerInfos];
    return deduplicateMcpServers(allServers);
  }, [staticMcpServerInfos, dynamicMcpServerInfos]);
  const value = {
    componentList,
    toolRegistry,
    componentToolAssociations,
    mcpServerInfos,
    resources: staticResources,
    resourceSource,
    registerComponent,
    registerTool,
    registerTools,
    addToolAssociation,
    registerMcpServer,
    registerMcpServers,
    registerResource,
    registerResources,
    registerResourceSource,
    onCallUnregisteredTool
  };
  return import_react4.default.createElement(TamboRegistryContext.Provider, { value }, children);
};
var useTamboRegistry = () => {
  return (0, import_react4.useContext)(TamboRegistryContext);
};
var useTamboMcpServerInfos = () => {
  return (0, import_react4.useContext)(TamboRegistryContext).mcpServerInfos;
};

// node_modules/@tambo-ai/react/esm/providers/tambo-component-provider.js
var TamboComponentContext = (0, import_react5.createContext)({
  /**
   *
   */
  registerComponent: () => {
  },
  /**
   *
   */
  registerTool: () => {
  },
  /**
   *
   */
  registerTools: () => {
  },
  /**
   *
   */
  addToolAssociation: () => {
  }
});
var TamboComponentProvider = ({ children }) => {
  const client = useTamboClient();
  const { registerComponent, addToolAssociation, registerTool, registerTools } = useTamboRegistry();
  const value = {
    client,
    registerComponent,
    registerTool,
    registerTools,
    addToolAssociation
  };
  return import_react5.default.createElement(TamboComponentContext.Provider, { value }, children);
};
var useTamboComponent = () => {
  return (0, import_react5.useContext)(TamboComponentContext);
};

// node_modules/@tambo-ai/react/esm/providers/tambo-context-helpers-provider.js
var import_react6 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/context-helpers/registry.js
async function resolveAdditionalContext(helpers) {
  const entries = Object.entries(helpers);
  if (entries.length === 0)
    return [];
  const results = await Promise.all(entries.map(async ([name, fn]) => {
    try {
      const value = await fn();
      if (value == null)
        return null;
      return { name, context: value };
    } catch (error) {
      console.error(`Error running context helper ${name}:`, error);
      return null;
    }
  }));
  return results.filter(Boolean);
}

// node_modules/@tambo-ai/react/esm/providers/tambo-context-helpers-provider.js
var TamboContextHelpersContext = (0, import_react6.createContext)(null);
var TamboContextHelpersProvider = ({ children, contextHelpers }) => {
  const [helpers, setHelpers] = (0, import_react6.useState)({});
  const addContextHelper = (0, import_react6.useCallback)((name, fn) => {
    setHelpers((prev) => ({ ...prev, [name]: fn }));
  }, []);
  const removeContextHelper = (0, import_react6.useCallback)((name, fn) => {
    setHelpers((prev) => {
      const { [name]: registeredFn, ...rest } = prev;
      if (fn === void 0 || registeredFn === fn) {
        return rest;
      }
      return prev;
    });
  }, []);
  (0, import_react6.useEffect)(() => {
    const addedEntries = [];
    if (contextHelpers) {
      for (const [name, fn] of Object.entries(contextHelpers)) {
        addContextHelper(name, fn);
        addedEntries.push([name, fn]);
      }
    }
    return () => {
      for (const [name, fn] of addedEntries) {
        removeContextHelper(name, fn);
      }
    };
  }, [addContextHelper, contextHelpers, removeContextHelper]);
  const getAdditionalContext = (0, import_react6.useCallback)(async () => {
    const contexts = await resolveAdditionalContext(helpers);
    return contexts;
  }, [helpers]);
  const getContextHelpers = (0, import_react6.useCallback)(() => {
    return helpers;
  }, [helpers]);
  const value = (0, import_react6.useMemo)(() => ({
    getAdditionalContext,
    getContextHelpers,
    addContextHelper,
    removeContextHelper
  }), [
    getAdditionalContext,
    getContextHelpers,
    addContextHelper,
    removeContextHelper
  ]);
  return import_react6.default.createElement(TamboContextHelpersContext.Provider, { value }, children);
};
var useTamboContextHelpers = () => {
  const context = (0, import_react6.useContext)(TamboContextHelpersContext);
  if (context)
    return context;
  return {
    getAdditionalContext: async () => {
      throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
    },
    getContextHelpers: () => {
      throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
    },
    addContextHelper: (_name, _helper) => {
      throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
    },
    removeContextHelper: (_name) => {
      throw new Error("useTamboContextHelpers must be used within a TamboContextHelpersProvider");
    }
  };
};

// node_modules/@tambo-ai/react/esm/providers/tambo-interactable-provider.js
var TamboInteractableContext = (0, import_react7.createContext)({
  interactableComponents: [],
  addInteractableComponent: () => "",
  removeInteractableComponent: () => {
  },
  updateInteractableComponentProps: () => "",
  getInteractableComponent: () => void 0,
  getInteractableComponentsByName: () => [],
  clearAllInteractableComponents: () => {
  },
  setInteractableState: () => {
  },
  getInteractableComponentState: () => void 0,
  setInteractableSelected: () => {
  },
  clearInteractableSelections: () => {
  }
});
var TamboInteractableProvider = ({ children }) => {
  const [interactableComponents, setInteractableComponents] = (0, import_react7.useState)([]);
  const { registerTool } = useTamboComponent();
  const { addContextHelper, removeContextHelper } = useTamboContextHelpers();
  const interactablesContextHelper = (0, import_react7.useMemo)(() => createInteractablesContextHelper(interactableComponents), [interactableComponents]);
  (0, import_react7.useEffect)(() => {
    addContextHelper("interactables", interactablesContextHelper);
    return () => {
      removeContextHelper("interactables");
    };
  }, [interactablesContextHelper, addContextHelper, removeContextHelper]);
  (0, import_react7.useEffect)(() => {
    if (interactableComponents.length > 0) {
      registerTool({
        name: "get_all_interactable_components",
        description: "Only use this tool if the user is asking about interactable components.Get all currently interactable components with their details including their current props. These are components that you can interact with on behalf of the user.",
        tool: () => {
          return {
            components: interactableComponents
          };
        },
        inputSchema: external_exports.object({}),
        outputSchema: external_exports.object({
          components: external_exports.array(external_exports.object({
            id: external_exports.string(),
            name: external_exports.string(),
            props: external_exports.record(external_exports.string(), external_exports.any()),
            propsSchema: external_exports.record(external_exports.string(), external_exports.any()).optional()
          }))
        })
      });
      registerTool({
        name: "get_interactable_component_by_id",
        description: "Get a specific interactable component by its ID",
        tool: ({ componentId }) => {
          const component = interactableComponents.find((c2) => c2.id === componentId);
          if (!component) {
            return {
              success: false,
              error: `Component with ID ${componentId} not found`
            };
          }
          return {
            success: true,
            component: {
              id: component.id,
              componentName: component.name,
              props: component.props
            }
          };
        },
        inputSchema: external_exports.object({
          componentId: external_exports.string().describe("The ID of the component")
        }),
        outputSchema: external_exports.discriminatedUnion("success", [
          external_exports.object({
            success: external_exports.literal(true),
            component: external_exports.object({
              id: external_exports.string(),
              componentName: external_exports.string(),
              props: external_exports.record(external_exports.string(), external_exports.any())
            }).optional()
          }),
          external_exports.object({
            success: external_exports.literal(false),
            error: external_exports.string()
          })
        ])
      });
      registerTool({
        name: "remove_interactable_component",
        description: "Remove an interactable component from the system",
        tool: ({ componentId }) => {
          const component = interactableComponents.find((c2) => c2.id === componentId);
          if (!component) {
            return {
              success: false,
              error: `Component with ID ${componentId} not found`
            };
          }
          setInteractableComponents((prev) => prev.filter((c2) => c2.id !== componentId));
          return {
            success: true,
            componentId,
            removedComponent: {
              id: component.id,
              componentName: component.name,
              props: component.props
            }
          };
        },
        inputSchema: external_exports.object({
          componentId: external_exports.string().describe("The ID of the component")
        }),
        outputSchema: external_exports.discriminatedUnion("success", [
          external_exports.object({
            success: external_exports.literal(true),
            componentId: external_exports.string(),
            removedComponent: external_exports.object({
              id: external_exports.string(),
              componentName: external_exports.string(),
              props: external_exports.record(external_exports.string(), external_exports.any())
            })
          }),
          external_exports.object({
            success: external_exports.literal(false),
            error: external_exports.string()
          })
        ])
      });
    }
  }, [interactableComponents, registerTool]);
  const updateInteractableComponentProps = (0, import_react7.useCallback)((id, newProps) => {
    if (!newProps || Object.keys(newProps).length === 0) {
      return `Warning: No props provided for component with ID ${id}.`;
    }
    setInteractableComponents((prev) => {
      const component = prev.find((c2) => c2.id === id);
      if (!component) {
        return prev;
      }
      const propsChanged = Object.entries(newProps).some(([key, value2]) => {
        return component.props[key] !== value2;
      });
      if (!propsChanged) {
        return prev;
      }
      const updated = {
        ...component,
        props: { ...component.props, ...newProps }
      };
      const updatedComponents = [...prev];
      const idx = prev.findIndex((c2) => c2.id === id);
      updatedComponents[idx] = updated;
      return updatedComponents;
    });
    return "Updated successfully";
  }, []);
  const updateInteractableComponentState = (0, import_react7.useCallback)((componentId, newState) => {
    if (!newState || Object.keys(newState).length === 0) {
      return `Warning: No state values provided for component with ID ${componentId}.`;
    }
    setInteractableComponents((components = []) => {
      const component = components.find((c2) => c2.id === componentId);
      if (!component)
        return components;
      const prevState = component.state ?? {};
      const updatedState = { ...prevState, ...newState };
      if (deepEqual(prevState, updatedState))
        return components;
      const updated = {
        ...component,
        state: updatedState
      };
      return components.map((c2) => c2.id === componentId ? updated : c2);
    });
    return "Updated successfully";
  }, []);
  const registerInteractableComponentPropsUpdateTool = (0, import_react7.useCallback)((component, maxNameLength = 60) => {
    const tamboToolNamePart = `update_component_props_`;
    const availableLength = maxNameLength - tamboToolNamePart.length;
    if (component.id.length > availableLength) {
      throw new Error(`Interactable component id ${component.id} is too long. It must be less than ${availableLength} characters.`);
    }
    let newPropsSchema;
    if (component.propsSchema) {
      const fullSchema = schemaToJsonSchema(component.propsSchema);
      newPropsSchema = makeJsonSchemaPartial(fullSchema);
    } else {
      newPropsSchema = { type: "object", additionalProperties: true };
    }
    const inputSchema = {
      type: "object",
      properties: {
        componentId: {
          type: "string",
          description: "The ID of the interactable component to update"
        },
        newProps: {
          ...newPropsSchema,
          description: "The props to update. Provide only the props you want to change."
        }
      },
      required: ["componentId", "newProps"]
    };
    registerTool({
      name: `${tamboToolNamePart}${component.id}`,
      description: `Update the props of interactable component ${component.id} (${component.name}). Provide partial props (only props to change).`,
      tool: ({ componentId, newProps }) => {
        return updateInteractableComponentProps(componentId, newProps);
      },
      inputSchema,
      outputSchema: external_exports.string()
    });
  }, [registerTool, updateInteractableComponentProps]);
  const registerInteractableComponentStateUpdateTool = (0, import_react7.useCallback)((component, maxNameLength = 60) => {
    const tamboToolNamePart = `update_component_state_`;
    const availableLength = maxNameLength - tamboToolNamePart.length;
    if (component.id.length > availableLength) {
      throw new Error(`Interactable component id ${component.id} is too long. It must be less than ${availableLength} characters.`);
    }
    let newStateSchema = {
      type: "object",
      additionalProperties: true
    };
    if (component.stateSchema) {
      const fullSchema = schemaToJsonSchema(component.stateSchema);
      newStateSchema = makeJsonSchemaPartial(fullSchema);
    }
    const inputSchema = {
      type: "object",
      properties: {
        componentId: {
          type: "string",
          description: "The ID of the interactable component to update"
        },
        newState: {
          ...newStateSchema,
          description: "The state values to update. Provide only the keys you want to change."
        }
      },
      required: ["componentId", "newState"]
    };
    registerTool({
      name: `${tamboToolNamePart}${component.id}`,
      description: `Update the state of interactable component ${component.id} (${component.name}). You may provide partial state (only keys to change).`,
      tool: ({ componentId, newState }) => {
        return updateInteractableComponentState(componentId, newState);
      },
      inputSchema,
      outputSchema: external_exports.string()
    });
  }, [registerTool, updateInteractableComponentState]);
  const addInteractableComponent = (0, import_react7.useCallback)((component) => {
    assertValidName(component.name, "component");
    const tamboGeneratedNamePart = `-${Math.random().toString(36).slice(2, 5)}`;
    const id = `${component.name}${tamboGeneratedNamePart}`;
    const newComponent = {
      ...component,
      id,
      state: component.state ?? {}
    };
    registerInteractableComponentPropsUpdateTool(newComponent);
    registerInteractableComponentStateUpdateTool(newComponent);
    setInteractableComponents((prev) => {
      return [...prev, newComponent];
    });
    return id;
  }, [
    registerInteractableComponentPropsUpdateTool,
    registerInteractableComponentStateUpdateTool
  ]);
  const removeInteractableComponent = (0, import_react7.useCallback)((id) => {
    setInteractableComponents((prev) => prev.filter((c2) => c2.id !== id));
  }, []);
  const getInteractableComponent = (0, import_react7.useCallback)((id) => {
    return interactableComponents.find((c2) => c2.id === id);
  }, [interactableComponents]);
  const getInteractableComponentsByName = (0, import_react7.useCallback)((componentName) => {
    return interactableComponents.filter((c2) => c2.name === componentName);
  }, [interactableComponents]);
  const clearAllInteractableComponents = (0, import_react7.useCallback)(() => {
    setInteractableComponents([]);
  }, []);
  const setInteractableStateValue = (0, import_react7.useCallback)((componentId, key, value2) => {
    setInteractableComponents((prev) => {
      const component = prev.find((c2) => c2.id === componentId);
      if (!component) {
        console.warn(`Tried to update state for component ${componentId} but it was not found.`);
        return prev;
      }
      const updated = {
        ...component,
        state: {
          ...component.state,
          [key]: value2
        }
      };
      const updatedComponents = prev.map((component2) => {
        if (component2.id === componentId) {
          return updated;
        }
        return component2;
      });
      return updatedComponents;
    });
  }, []);
  const getInteractableComponentState = (0, import_react7.useCallback)((componentId) => {
    const component = interactableComponents.find((c2) => c2.id === componentId);
    return component == null ? void 0 : component.state;
  }, [interactableComponents]);
  const setInteractableSelected = (0, import_react7.useCallback)((componentId, isSelected) => {
    setInteractableComponents((prev) => {
      let found = false;
      const next = prev.map((component) => {
        if (component.id !== componentId)
          return component;
        found = true;
        return component.isSelected === isSelected ? component : { ...component, isSelected };
      });
      return found ? next : prev;
    });
  }, []);
  const clearInteractableSelections = (0, import_react7.useCallback)(() => {
    setInteractableComponents((prev) => {
      if (!prev.some((c2) => c2.isSelected))
        return prev;
      return prev.map((c2) => c2.isSelected ? { ...c2, isSelected: false } : c2);
    });
  }, []);
  const value = {
    interactableComponents,
    addInteractableComponent,
    removeInteractableComponent,
    updateInteractableComponentProps,
    getInteractableComponent,
    getInteractableComponentsByName,
    clearAllInteractableComponents,
    setInteractableState: setInteractableStateValue,
    getInteractableComponentState,
    setInteractableSelected,
    clearInteractableSelections
  };
  return import_react7.default.createElement(TamboInteractableContext.Provider, { value }, children);
};
var useTamboInteractable = () => {
  return (0, import_react7.useContext)(TamboInteractableContext);
};
var useCurrentInteractablesSnapshot = () => {
  const { interactableComponents } = useTamboInteractable();
  const copy = interactableComponents.map((c2) => ({
    ...c2,
    props: { ...c2.props }
  }));
  return copy;
};

// node_modules/@tambo-ai/react/esm/hooks/use-current-message.js
var import_react8 = __toESM(require_react());
var TamboMessageContext = (0, import_react8.createContext)(null);
var TamboMessageProvider = ({ children, message, interactableMetadata }) => {
  const enhancedMessage = interactableMetadata ? { ...message, interactableMetadata } : message;
  return import_react8.default.createElement(TamboMessageContext.Provider, { value: enhancedMessage, key: message.id }, children);
};
function wrapWithTamboMessageProvider(children, message, interactableMetadata) {
  return import_react8.default.createElement(TamboMessageProvider, { message, interactableMetadata }, children);
}
var useTamboCurrentMessage = () => {
  const message = (0, import_react8.useContext)(TamboMessageContext);
  if (!message) {
    throw new Error("useTamboCurrentMessage must be used within a TamboMessageProvider");
  }
  return message;
};
var useTamboCurrentComponent = () => {
  var _a13, _b, _c, _d, _e;
  const message = (0, import_react8.useContext)(TamboMessageContext);
  if (!message) {
    return null;
  }
  return {
    componentName: ((_a13 = message.interactableMetadata) == null ? void 0 : _a13.componentName) ?? ((_b = message.component) == null ? void 0 : _b.componentName) ?? void 0,
    props: (_c = message.component) == null ? void 0 : _c.props,
    interactableId: ((_d = message.interactableMetadata) == null ? void 0 : _d.id) ?? void 0,
    description: ((_e = message.interactableMetadata) == null ? void 0 : _e.description) ?? void 0,
    threadId: message.threadId
  };
};

// node_modules/@tambo-ai/react/esm/hooks/use-component-state.js
function useTamboComponentState(keyName, initialValue, setFromProp, debounceTime = 500) {
  var _a13, _b, _c, _d;
  const message = (0, import_react9.useContext)(TamboMessageContext);
  const { updateThreadMessage } = useTamboThread();
  const client = useTamboClient();
  const componentId = ((_a13 = message == null ? void 0 : message.interactableMetadata) == null ? void 0 : _a13.id) ?? null;
  const { setInteractableState, getInteractableComponentState } = useTamboInteractable();
  const messageState = (_b = message == null ? void 0 : message.componentState) == null ? void 0 : _b[keyName];
  const interactableState = componentId ? (_c = getInteractableComponentState(componentId)) == null ? void 0 : _c[keyName] : void 0;
  const initialState = interactableState ?? messageState ?? initialValue;
  const [localState, setLocalState] = (0, import_react9.useState)(initialState);
  const [initializedFromThreadMessage, setInitializedFromThreadMessage] = (0, import_react9.useState)(messageState ? true : false);
  const updateLocalThreadMessage = (0, import_react9.useCallback)(async (newState, existingMessage) => {
    if (!existingMessage) {
      return;
    }
    const updatedMessage = {
      threadId: existingMessage.threadId,
      componentState: {
        ...existingMessage.componentState,
        [keyName]: newState
      }
    };
    await updateThreadMessage(existingMessage.id, updatedMessage, false);
  }, [updateThreadMessage, keyName]);
  const updateRemoteThreadMessage = c(async (newState, existingMessage) => {
    if (!existingMessage) {
      return;
    }
    await client.beta.threads.messages.updateComponentState(existingMessage.id, {
      id: existingMessage.threadId,
      state: { [keyName]: newState }
    });
  }, debounceTime);
  const setValue = (0, import_react9.useCallback)((newState) => {
    setLocalState(newState);
    if (componentId) {
      setInteractableState(componentId, keyName, newState);
    } else if (message) {
      void updateLocalThreadMessage(newState, message);
      void updateRemoteThreadMessage(newState, message);
    }
  }, [
    message,
    updateLocalThreadMessage,
    updateRemoteThreadMessage,
    setInteractableState,
    componentId,
    keyName
  ]);
  const existingInteractableState = componentId ? (_d = getInteractableComponentState(componentId)) == null ? void 0 : _d[keyName] : void 0;
  const shouldUpdateInteractableInitial = !!componentId && existingInteractableState === void 0 && initialValue !== void 0;
  (0, import_react9.useEffect)(() => {
    if (!shouldUpdateInteractableInitial) {
      return;
    }
    setInteractableState(componentId, keyName, initialValue);
  }, [
    shouldUpdateInteractableInitial,
    componentId,
    keyName,
    initialValue,
    setInteractableState
  ]);
  const shouldSyncFromMessage = !!message && messageState !== void 0 && messageState !== null;
  (0, import_react9.useEffect)(() => {
    if (!shouldSyncFromMessage) {
      return;
    }
    setInitializedFromThreadMessage(true);
    const stateValue = messageState;
    setLocalState(stateValue);
    if (componentId) {
      setInteractableState(componentId, keyName, stateValue);
    }
  }, [
    shouldSyncFromMessage,
    messageState,
    keyName,
    setInteractableState,
    componentId
  ]);
  (0, import_react9.useEffect)(() => {
    if (!componentId)
      return;
    setLocalState((prev) => deepEqual(prev, interactableState) ? prev : interactableState);
  }, [componentId, interactableState]);
  (0, import_react9.useEffect)(() => {
    if (setFromProp !== void 0 && !initializedFromThreadMessage) {
      setLocalState(setFromProp);
    }
  }, [setFromProp, initializedFromThreadMessage]);
  (0, import_react9.useEffect)(() => {
    if (componentId) {
      return;
    }
    return () => {
      async function flushUpdates() {
        try {
          await updateRemoteThreadMessage.flush();
        } catch (error) {
          console.error("Failed to flush pending thread message updates:", error);
        }
      }
      void flushUpdates();
    };
  }, [updateRemoteThreadMessage, componentId]);
  return [localState, setValue];
}

// node_modules/@tambo-ai/react/esm/hooks/use-message-images.js
var import_react10 = __toESM(require_react());
function useMessageImages() {
  const [images, setImages] = (0, import_react10.useState)([]);
  const fileToDataUrl = async (file2) => {
    return await new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(file2);
    });
  };
  const addImage = (0, import_react10.useCallback)(async (file2) => {
    if (!file2.type.startsWith("image/")) {
      throw new Error("Only image files are allowed");
    }
    const dataUrl = await fileToDataUrl(file2);
    const newImage = {
      id: crypto.randomUUID(),
      name: file2.name,
      dataUrl,
      file: file2,
      size: file2.size,
      type: file2.type
    };
    setImages((prev) => [...prev, newImage]);
  }, []);
  const addImages = (0, import_react10.useCallback)(async (files) => {
    const imageFiles = files.filter((file2) => file2.type.startsWith("image/"));
    if (imageFiles.length === 0) {
      throw new Error("No valid image files provided");
    }
    const newImages = await Promise.all(imageFiles.map(async (file2) => {
      const dataUrl = await fileToDataUrl(file2);
      return {
        id: crypto.randomUUID(),
        name: file2.name,
        dataUrl,
        file: file2,
        size: file2.size,
        type: file2.type
      };
    }));
    setImages((prev) => [...prev, ...newImages]);
  }, []);
  const removeImage = (0, import_react10.useCallback)((id) => {
    setImages((prev) => prev.filter((img) => img.id !== id));
  }, []);
  const clearImages = (0, import_react10.useCallback)(() => {
    setImages([]);
  }, []);
  return {
    images,
    addImage,
    addImages,
    removeImage,
    clearImages
  };
}

// node_modules/@tambo-ai/react/esm/hooks/use-streaming-props.js
var import_react11 = __toESM(require_react());
function useTamboStreamingProps(currentState, setState, streamingProps) {
  (0, import_react11.useEffect)(() => {
    if (currentState) {
      let shouldUpdate = false;
      const updates = {};
      Object.entries(streamingProps).forEach(([key, value]) => {
        if (value !== void 0 && value !== currentState[key]) {
          shouldUpdate = true;
          updates[key] = value;
        }
      });
      if (shouldUpdate) {
        setState({
          ...currentState,
          ...updates
        });
      }
    }
  }, [...Object.values(streamingProps)]);
}

// node_modules/@tambo-ai/react/esm/hooks/use-suggestions.js
var import_react20 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/model/generate-component-response.js
var GenerationStage;
(function(GenerationStage2) {
  GenerationStage2["IDLE"] = "IDLE";
  GenerationStage2["CHOOSING_COMPONENT"] = "CHOOSING_COMPONENT";
  GenerationStage2["FETCHING_CONTEXT"] = "FETCHING_CONTEXT";
  GenerationStage2["HYDRATING_COMPONENT"] = "HYDRATING_COMPONENT";
  GenerationStage2["STREAMING_RESPONSE"] = "STREAMING_RESPONSE";
  GenerationStage2["COMPLETE"] = "COMPLETE";
  GenerationStage2["ERROR"] = "ERROR";
  GenerationStage2["CANCELLED"] = "CANCELLED";
})(GenerationStage || (GenerationStage = {}));
function isIdleStage(generationStage) {
  return [
    GenerationStage.IDLE,
    GenerationStage.COMPLETE,
    GenerationStage.ERROR,
    GenerationStage.CANCELLED
  ].includes(generationStage);
}

// node_modules/@tambo-ai/react/esm/model/validate-input.js
function validateInput(input) {
  const trimmed = input.trim();
  if (trimmed.length === 0) {
    return {
      isValid: false,
      error: new Error("Message cannot be empty"),
      sanitizedInput: trimmed
    };
  }
  if (trimmed.length > 1e4) {
    return {
      isValid: false,
      error: new Error("Message is too long (max 10000 characters)"),
      sanitizedInput: trimmed
    };
  }
  return {
    isValid: true,
    sanitizedInput: trimmed
  };
}

// node_modules/@tambo-ai/react/esm/providers/tambo-provider.js
var import_react19 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/mcp/tambo-mcp-provider.js
var import_react16 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/mcp/mcp-constants.js
var ServerType = {
  /** Client-side MCP server passed via mcpServers prop */
  BROWSER_SIDE: "browser-side",
  /** Internal Tambo MCP server at /mcp endpoint (server-side MCP) */
  TAMBO_INTERNAL: "tambo-internal",
  /** Virtual server representing browser-only registry resources */
  TAMBO_REGISTRY: "tambo-registry"
};
var REGISTRY_SERVER_KEY = "registry";

// node_modules/@tambo-ai/react/esm/providers/tambo-mcp-token-provider.js
var import_react14 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/providers/tambo-thread-provider.js
var import_react13 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/util/content-parts.js
function isContentPart(val) {
  return !!val && typeof val === "object" && "type" in val && typeof val.type === "string";
}
function isContentPartArray(val) {
  return Array.isArray(val) && val.every((item) => isContentPart(item));
}
function toText(val) {
  if (typeof val === "string")
    return val;
  try {
    const json2 = JSON.stringify(val);
    return json2 ?? String(val);
  } catch {
    return String(val);
  }
}

// node_modules/@tambo-ai/react/esm/util/generate-component.js
var import_partial_json = __toESM(require_dist());
var import_react12 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/util/is-promise.js
function isPromise(value) {
  if (value === null) {
    return false;
  }
  if (typeof value !== "object" && typeof value !== "function") {
    return false;
  }
  return typeof value.then === "function";
}

// node_modules/@tambo-ai/react/esm/util/registry.js
var getAvailableComponents = (componentRegistry, toolRegistry, toolAssociations) => {
  const availableComponents = [];
  for (const [name, componentEntry] of Object.entries(componentRegistry)) {
    const associatedToolNames = toolAssociations[name] || [];
    const contextTools = associatedToolNames.map((toolName) => {
      const tool = toolRegistry[toolName];
      if (!tool)
        return null;
      return mapTamboToolToContextTool(tool);
    }).filter((tool) => tool !== null);
    availableComponents.push({
      name: componentEntry.name,
      description: componentEntry.description,
      props: componentEntry.props,
      contextTools
    });
  }
  return availableComponents;
};
var getUnassociatedTools = (toolRegistry, toolAssociations) => {
  return Object.values(toolRegistry).filter((tool) => {
    return !Object.values(toolAssociations).flat().includes(tool.name);
  });
};
var getComponentFromRegistry = (componentName, componentRegistry) => {
  const componentEntry = componentRegistry[componentName];
  if (!componentEntry) {
    throw new Error(`Tambo tried to use Component ${componentName}, but it was not found.`);
  }
  return componentEntry;
};
var mapTamboToolToContextTool = (tool) => {
  const parameters = getParametersFromToolSchema(tool);
  return {
    name: tool.name,
    description: tool.description,
    parameters,
    ..."maxCalls" in tool && tool.maxCalls !== void 0 ? { maxCalls: tool.maxCalls } : {},
    ..."annotations" in tool && tool.annotations !== void 0 ? { annotations: tool.annotations } : {}
  };
};
var defineTool = (tool) => {
  if ("toolSchema" in tool) {
    return tool;
  }
  tool.inputSchema ?? (tool.inputSchema = { type: "object", properties: {}, required: [] });
  tool.outputSchema ?? (tool.outputSchema = { type: "object", properties: {}, required: [] });
  return tool;
};

// node_modules/@tambo-ai/react/esm/util/generate-component.js
function renderComponentIntoMessage(message, componentList) {
  var _a13, _b, _c;
  if (!((_a13 = message.component) == null ? void 0 : _a13.componentName)) {
    throw new Error("Component not found");
  }
  const parsedProps = (0, import_partial_json.parse)(JSON.stringify(message.component.props));
  const registeredComponent = getComponentFromRegistry(message.component.componentName, componentList);
  let validatedProps = parsedProps;
  if (isStandardSchema(registeredComponent.props)) {
    const result = registeredComponent.props["~standard"].validate(parsedProps);
    if (isPromise(result)) {
      throw new Error("Async schema validation is not supported for component props");
    }
    if ("value" in result) {
      validatedProps = result.value;
    } else {
      const issueMessage = ((_c = (_b = result.issues) == null ? void 0 : _b[0]) == null ? void 0 : _c.message) ?? "Schema validation failed";
      throw new Error(`Component props validation failed: ${issueMessage}`);
    }
  }
  const renderedComponent = import_react12.default.createElement(registeredComponent.component, validatedProps);
  const fullMessage = {
    ...message,
    component: {
      ...message.component,
      props: validatedProps
    }
  };
  const wrappedComponent = wrapWithTamboMessageProvider(renderedComponent, fullMessage);
  return {
    ...fullMessage,
    renderedComponent: wrappedComponent
  };
}

// node_modules/@tambo-ai/react/esm/util/tool-caller.js
var handleToolCall = async (toolCallRequest, toolRegistry, onCallUnregisteredTool) => {
  if (!(toolCallRequest == null ? void 0 : toolCallRequest.toolName)) {
    throw new Error("Tool name is required");
  }
  try {
    const { tool, tamboTool } = findTool(toolCallRequest.toolName, toolRegistry);
    if (!tool) {
      if (onCallUnregisteredTool) {
        const result = await onCallUnregisteredTool(toolCallRequest.toolName, toolCallRequest.parameters);
        return {
          result
        };
      }
      throw new Error(`Tool ${toolCallRequest.toolName} not found in registry`);
    }
    return {
      result: await runToolChoice(toolCallRequest, tool),
      tamboTool
    };
  } catch (error) {
    console.error("Error in calling tool: ", error);
    return {
      result: `When attempting to call tool ${toolCallRequest.toolName} the following error occurred: ${error}. Explain to the user that the tool call failed and try again if needed.`,
      error: error instanceof Error ? error.message : "Unknown error"
    };
  }
};
var findTool = (toolName, toolRegistry) => {
  const registryTool = toolRegistry[toolName];
  if (!registryTool) {
    return { tool: null, tamboTool: null };
  }
  const contextTool = mapTamboToolToContextTool(registryTool);
  return {
    tool: {
      getComponentContext: registryTool.tool,
      definition: contextTool
    },
    tamboTool: registryTool
  };
};
var runToolChoice = async (toolCallRequest, tool) => {
  const parameters = toolCallRequest.parameters ?? [];
  const inputObject = Object.fromEntries(parameters.map((param) => [param.parameterName, param.parameterValue]));
  return await tool.getComponentContext(inputObject);
};

// node_modules/@tambo-ai/react/esm/providers/tambo-thread-provider.js
var TamboGenerationStageContext = (0, import_react13.createContext)(void 0);
var TamboGenerationStageProvider = ({ children, generationStage, statusMessage }) => {
  const isIdle = isIdleStage(generationStage);
  const contextValue = (0, import_react13.useMemo)(() => {
    return {
      generationStage,
      generationStatusMessage: statusMessage,
      isIdle
    };
  }, [generationStage, statusMessage, isIdle]);
  return import_react13.default.createElement(TamboGenerationStageContext.Provider, { value: contextValue }, children);
};
var PLACEHOLDER_THREAD = {
  id: "placeholder",
  messages: [],
  createdAt: "",
  projectId: "",
  updatedAt: "",
  metadata: {}
};
var TamboThreadContext = (0, import_react13.createContext)({
  thread: PLACEHOLDER_THREAD,
  currentThreadId: PLACEHOLDER_THREAD.id,
  currentThread: PLACEHOLDER_THREAD,
  threadMap: { [PLACEHOLDER_THREAD.id]: PLACEHOLDER_THREAD },
  setThreadMap: () => {
    throw new Error("setThreadMap not implemented");
  },
  /**
   *
   */
  switchCurrentThread: () => {
    throw new Error("switchCurrentThread not implemented");
  },
  /**
   *
   */
  startNewThread: () => {
    throw new Error("startNewThread not implemented");
  },
  /**
   *
   */
  updateThreadName: () => {
    throw new Error("updateThreadName not implemented");
  },
  /**
   *
   */
  generateThreadName: () => {
    throw new Error("generateThreadName not implemented");
  },
  /**
   *
   */
  addThreadMessage: () => {
    throw new Error("updateThreadMessageHistory not implemented");
  },
  streaming: true,
  /**
   *
   */
  updateThreadMessage: () => {
    throw new Error("updateThreadMessage not implemented");
  },
  /**
   *
   */
  sendThreadMessage: () => {
    throw new Error("sendThreadMessage not implemented");
  },
  /**
   *
   */
  cancel: () => {
    throw new Error("cancel not implemented");
  }
});
var TamboThreadProvider = ({ children, streaming = true, initialMessages = [], autoGenerateThreadName = true, autoGenerateNameThreshold = 3, contextKey }) => {
  const placeholderThread = (0, import_react13.useMemo)(() => ({
    id: "placeholder",
    messages: initialMessages.map((msg) => ({
      ...msg,
      id: msg.id ?? crypto.randomUUID(),
      threadId: "placeholder",
      createdAt: msg.createdAt ?? (/* @__PURE__ */ new Date()).toISOString(),
      componentState: msg.componentState ?? {}
    })),
    createdAt: "",
    projectId: "",
    updatedAt: "",
    metadata: {},
    contextKey
  }), [contextKey, initialMessages]);
  const [threadMap, setThreadMap] = (0, import_react13.useState)({
    [placeholderThread.id]: placeholderThread
  });
  const client = useTamboClient();
  const queryClient = useTamboQueryClient();
  const { componentList, toolRegistry, componentToolAssociations, onCallUnregisteredTool } = useTamboRegistry();
  const { getAdditionalContext } = useTamboContextHelpers();
  const [ignoreResponse, setIgnoreResponse] = (0, import_react13.useState)(false);
  const ignoreResponseRef = (0, import_react13.useRef)(ignoreResponse);
  const [currentThreadId, setCurrentThreadId] = (0, import_react13.useState)(placeholderThread.id);
  const currentThread = threadMap[currentThreadId];
  const currentGenerationStage = (currentThread == null ? void 0 : currentThread.generationStage) ?? GenerationStage.IDLE;
  const currentStatusMessage = (currentThread == null ? void 0 : currentThread.statusMessage) ?? "";
  const currentMessageCache = (0, import_react13.useMemo)(() => {
    const messageCache = /* @__PURE__ */ new Map();
    if (currentThread) {
      for (const message of currentThread.messages) {
        messageCache.set(message.id, message);
      }
    }
    return messageCache;
  }, [currentThread]);
  (0, import_react13.useEffect)(() => {
    ignoreResponseRef.current = ignoreResponse;
  }, [ignoreResponse]);
  const updateThreadsCache = (0, import_react13.useCallback)(async (updateFn, contextKey2) => {
    try {
      const currentProject = await client.beta.projects.getCurrent();
      queryClient.setQueryData(["threads", currentProject.id, contextKey2], updateFn);
      await queryClient.invalidateQueries({
        queryKey: ["threads"]
      });
    } catch (error) {
      console.warn("Failed to update threads cache:", error);
    }
  }, [client.beta.projects, queryClient]);
  const addThreadToCache = (0, import_react13.useCallback)(async (threadId, contextKey2) => {
    const optimisticThread = {
      ...PLACEHOLDER_THREAD,
      id: threadId,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      updatedAt: (/* @__PURE__ */ new Date()).toISOString()
    };
    await updateThreadsCache((old) => {
      if (!old)
        return old;
      return {
        ...old,
        items: [optimisticThread, ...old.items ?? []],
        total: (old.total ?? 0) + 1,
        count: (old.count ?? 0) + 1
      };
    }, contextKey2);
  }, [updateThreadsCache]);
  const updateThreadInCache = (0, import_react13.useCallback)(async (threadId, updateFn, contextKey2) => {
    await updateThreadsCache((old) => {
      if (!(old == null ? void 0 : old.items))
        return old;
      return {
        ...old,
        items: old.items.map((thread) => thread.id === threadId ? updateFn(thread) : thread),
        total: old.total,
        count: old.count
      };
    }, contextKey2);
  }, [updateThreadsCache]);
  const fetchThread = (0, import_react13.useCallback)(async (threadId) => {
    const thread = await client.beta.threads.retrieve(threadId);
    const threadWithRenderedComponents = {
      ...thread,
      messages: thread.messages.map((message) => {
        var _a13;
        if (currentMessageCache.has(message.id)) {
          const renderedMessage = currentMessageCache.get(message.id);
          return {
            ...renderedMessage,
            ...message
          };
        }
        if ((_a13 = message.component) == null ? void 0 : _a13.componentName) {
          const messageWithComponent = renderComponentIntoMessage(message, componentList);
          return messageWithComponent;
        }
        return message;
      })
    };
    setThreadMap((prevMap) => {
      const updatedThreadMap = {
        ...prevMap,
        [threadId]: threadWithRenderedComponents
      };
      return updatedThreadMap;
    });
  }, [client.beta.threads, componentList, currentMessageCache]);
  (0, import_react13.useEffect)(() => {
    async function loadThread() {
      try {
        await fetchThread(currentThreadId);
      } catch (error) {
        console.error("Failed to fetch thread:", error);
      }
    }
    if (currentThreadId && currentThreadId !== placeholderThread.id && !threadMap[currentThreadId]) {
      loadThread().catch((err) => {
        console.error("Unexpected error in loadThread:", err);
      });
    }
  }, [currentThreadId, fetchThread, threadMap, placeholderThread.id]);
  const addThreadMessage = (0, import_react13.useCallback)(async (message, sendToServer = true, createdAt = (/* @__PURE__ */ new Date()).toISOString()) => {
    var _a13;
    if (!currentThread) {
      console.warn("Cannot add messages if we do not have a current thread");
      return [];
    }
    const chatMessage = {
      ...message,
      createdAt
    };
    const threadId = message.threadId;
    const messageId = chatMessage.id;
    setThreadMap((prevMap) => {
      var _a14;
      if (!threadId) {
        return prevMap;
      }
      const prevMessages = ((_a14 = prevMap[threadId]) == null ? void 0 : _a14.messages) || [];
      const haveMessage = prevMessages.find((msg) => msg.id === messageId);
      const updatedMessages = haveMessage ? prevMessages.map((msg) => {
        if (msg.id === messageId) {
          return chatMessage;
        }
        return msg;
      }) : [...prevMessages, chatMessage];
      const updatedThreadMap = {
        ...prevMap,
        [threadId]: {
          ...prevMap[threadId],
          messages: updatedMessages
        }
      };
      return updatedThreadMap;
    });
    if (sendToServer) {
      try {
        await client.beta.threads.messages.create(message.threadId, {
          content: message.content,
          role: message.role,
          additionalContext: chatMessage.additionalContext
        });
      } catch (error) {
        console.error("Failed to add message to server", error);
        setThreadMap((prev) => {
          var _a14;
          const prevMessages = ((_a14 = prev[threadId]) == null ? void 0 : _a14.messages) || [];
          const updatedMessages = prevMessages.filter((msg) => msg.id !== messageId);
          return {
            ...prev,
            [threadId]: {
              ...prev[threadId],
              messages: updatedMessages
            }
          };
        });
        throw error;
      }
    }
    return ((_a13 = threadMap[threadId]) == null ? void 0 : _a13.messages) || [];
  }, [client.beta.threads.messages, currentThread, threadMap]);
  const updateThreadMessage = (0, import_react13.useCallback)(async (id, message, sendToServer = true, createdAt = (/* @__PURE__ */ new Date()).toISOString()) => {
    setThreadMap((prevMap) => {
      var _a13;
      const prevMessages = ((_a13 = prevMap[message.threadId]) == null ? void 0 : _a13.messages) || [];
      const updatedMessages = prevMessages.map((msg) => {
        if (msg.id === id) {
          const updatedMessage = {
            ...msg,
            ...message,
            id: msg.id,
            createdAt: message.createdAt ?? msg.createdAt ?? createdAt
          };
          return updatedMessage;
        }
        return msg;
      });
      return {
        ...prevMap,
        [message.threadId]: {
          ...prevMap[message.threadId],
          messages: updatedMessages
        }
      };
    });
    if (sendToServer && message.content && message.role) {
      try {
        await client.beta.threads.messages.create(message.threadId, {
          content: message.content,
          role: message.role,
          additionalContext: message.additionalContext
        });
      } catch (error) {
        console.error("Failed to update message on server", error);
        setThreadMap((prev) => {
          var _a13, _b;
          const updatedMessages = (_b = (_a13 = prev[message.threadId]) == null ? void 0 : _a13.messages) == null ? void 0 : _b.filter((msg) => msg.id !== id);
          return {
            ...prev,
            [message.threadId]: {
              ...prev[message.threadId],
              messages: updatedMessages
            }
          };
        });
        throw error;
      }
    }
  }, [client.beta.threads.messages]);
  const generateThreadName = (0, import_react13.useCallback)(async (threadId, contextKey2) => {
    threadId ?? (threadId = currentThreadId);
    if (threadId === placeholderThread.id) {
      console.warn("Cannot generate name for empty thread");
      return threadMap[threadId];
    }
    const threadWithGeneratedName = await client.beta.threads.generateName(threadId);
    setThreadMap((prevMap) => {
      if (!prevMap[threadId]) {
        return prevMap;
      }
      return {
        ...prevMap,
        [threadId]: {
          ...prevMap[threadId],
          name: threadWithGeneratedName.name
        }
      };
    });
    await updateThreadInCache(threadId, (thread) => ({
      ...thread,
      name: threadWithGeneratedName.name
    }), contextKey2);
    return threadWithGeneratedName;
  }, [
    client.beta.threads,
    currentThreadId,
    threadMap,
    placeholderThread.id,
    updateThreadInCache
  ]);
  const maybeAutoGenerateThreadName = (0, import_react13.useCallback)((threadId, contextKey2) => {
    setThreadMap((map2) => {
      const thread = map2[threadId];
      if (!thread || !autoGenerateThreadName) {
        return map2;
      }
      if (autoGenerateNameThreshold == null || thread.id === placeholderThread.id) {
        return map2;
      }
      const messageCount = thread.messages.length;
      if (!thread.name && messageCount >= autoGenerateNameThreshold) {
        void generateThreadName(threadId, contextKey2).catch((error) => {
          console.error("Failed to generate thread name:", error);
        });
      }
      return map2;
    });
  }, [
    autoGenerateThreadName,
    autoGenerateNameThreshold,
    placeholderThread.id,
    generateThreadName
  ]);
  const startNewThread = (0, import_react13.useCallback)(() => {
    setCurrentThreadId(placeholderThread.id);
    setThreadMap((prevMap) => {
      return {
        ...prevMap,
        [placeholderThread.id]: placeholderThread
      };
    });
  }, [placeholderThread]);
  const updateThreadName = (0, import_react13.useCallback)(async (name, threadId) => {
    var _a13;
    threadId ?? (threadId = currentThreadId);
    const previousName = (_a13 = threadMap[threadId]) == null ? void 0 : _a13.name;
    setThreadMap((prevMap) => {
      if (!prevMap[threadId]) {
        return prevMap;
      }
      return { ...prevMap, [threadId]: { ...prevMap[threadId], name } };
    });
    if (threadId !== placeholderThread.id) {
      try {
        const currentProject = await client.beta.projects.getCurrent();
        await client.beta.threads.update(threadId, {
          name,
          projectId: currentProject.id
        });
      } catch (error) {
        console.error("Failed to update thread name on server", error);
        setThreadMap((prevMap) => {
          if (!prevMap[threadId]) {
            return prevMap;
          }
          return {
            ...prevMap,
            [threadId]: { ...prevMap[threadId], name: previousName }
          };
        });
        throw error;
      }
    }
  }, [
    currentThreadId,
    client.beta.projects,
    client.beta.threads,
    placeholderThread.id,
    threadMap
  ]);
  const switchCurrentThread = (0, import_react13.useCallback)(async (threadId, fetch2 = true) => {
    if (threadId === placeholderThread.id) {
      console.warn("Switching to placeholder thread, may be a bug.");
      return;
    }
    setCurrentThreadId(threadId);
    setThreadMap((prevMap) => {
      if (prevMap[threadId]) {
        return prevMap;
      }
      const updatedThreadMap = {
        ...prevMap,
        [threadId]: {
          ...prevMap[placeholderThread.id],
          id: threadId
        }
      };
      return updatedThreadMap;
    });
    if (fetch2) {
      await fetchThread(threadId);
    }
  }, [fetchThread, placeholderThread]);
  const updateThreadStatus = (0, import_react13.useCallback)((threadId, stage, statusMessage) => {
    setThreadMap((prevMap) => {
      const updatedThreadMap = {
        ...prevMap,
        [threadId]: {
          ...prevMap[threadId],
          generationStage: stage,
          statusMessage
        }
      };
      return updatedThreadMap;
    });
  }, []);
  const cancel = (0, import_react13.useCallback)(async (threadId) => {
    threadId ?? (threadId = currentThreadId);
    const currentGenerationStage2 = (currentThread == null ? void 0 : currentThread.generationStage) ?? GenerationStage.IDLE;
    if (isIdleStage(currentGenerationStage2)) {
      return;
    }
    setIgnoreResponse(true);
    setThreadMap((prevMap) => {
      if (!prevMap[threadId]) {
        return prevMap;
      }
      return {
        ...prevMap,
        [threadId]: {
          ...prevMap[threadId],
          generationStage: GenerationStage.CANCELLED,
          messages: prevMap[threadId].messages.map((message) => {
            if (message.id === prevMap[threadId].messages[prevMap[threadId].messages.length - 1].id) {
              return {
                ...message,
                isCancelled: true
              };
            }
            return message;
          })
        }
      };
    });
    await client.beta.threads.cancel(threadId);
  }, [client.beta.threads, currentThreadId, currentThread == null ? void 0 : currentThread.generationStage]);
  const handleAdvanceStream = (0, import_react13.useCallback)(async (stream, params, threadId, contextKey2) => {
    var _a13, _b, _c, _d, _e;
    if (ignoreResponseRef.current) {
      setIgnoreResponse(false);
      return createEmptyMessage(threadId);
    }
    let finalMessage;
    let hasSetThreadId = false;
    updateThreadStatus(threadId, GenerationStage.STREAMING_RESPONSE);
    for await (const chunk of stream) {
      if (chunk.mcpAccessToken) {
        setThreadMap((prev) => {
          const thread = prev[threadId];
          if (thread) {
            return {
              ...prev,
              [threadId]: {
                ...thread,
                mcpAccessToken: chunk.mcpAccessToken
              }
            };
          }
          return prev;
        });
      }
      if (chunk.responseMessageDto.toolCallRequest) {
        const toolName = chunk.responseMessageDto.toolCallRequest.toolName;
        updateThreadStatus(chunk.responseMessageDto.threadId, GenerationStage.FETCHING_CONTEXT);
        await updateThreadMessage(chunk.responseMessageDto.id, {
          ...chunk.responseMessageDto
        }, false);
        const toolCallResponse = await handleToolCall(chunk.responseMessageDto.toolCallRequest, toolRegistry, onCallUnregisteredTool);
        if (ignoreResponseRef.current) {
          setIgnoreResponse(false);
          return createEmptyMessage(threadId);
        }
        const contentParts = await convertToolResponse(toolCallResponse);
        const toolCallResponseParams = {
          ...params,
          // Exclude initialMessages from tool response since thread already exists
          initialMessages: void 0,
          ...toolName ? {
            toolCallCounts: {
              ...params.toolCallCounts ?? {},
              [toolName]: (((_a13 = params.toolCallCounts) == null ? void 0 : _a13[toolName]) ?? 0) + 1
            }
          } : {},
          messageToAppend: {
            content: contentParts,
            role: "tool",
            actionType: "tool_response",
            component: chunk.responseMessageDto.component,
            tool_call_id: chunk.responseMessageDto.tool_call_id,
            error: toolCallResponse.error
          }
        };
        await updateThreadMessage(chunk.responseMessageDto.id, {
          ...chunk.responseMessageDto,
          error: toolCallResponse.error
        }, false);
        await addThreadMessage({
          threadId: chunk.responseMessageDto.threadId,
          content: contentParts,
          role: "tool",
          id: crypto.randomUUID(),
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          componentState: {},
          actionType: "tool_response",
          tool_call_id: chunk.responseMessageDto.tool_call_id,
          error: toolCallResponse.error
        }, false);
        updateThreadStatus(chunk.responseMessageDto.threadId, GenerationStage.STREAMING_RESPONSE);
        const toolCallResponseStream = await advanceStream(client, toolCallResponseParams, chunk.responseMessageDto.threadId);
        return await handleAdvanceStream(toolCallResponseStream, toolCallResponseParams, chunk.responseMessageDto.threadId, contextKey2);
      } else {
        if (ignoreResponseRef.current) {
          setIgnoreResponse(false);
          return finalMessage ?? createEmptyMessage(threadId);
        }
        if (!hasSetThreadId && chunk.responseMessageDto.threadId && chunk.responseMessageDto.threadId !== (currentThread == null ? void 0 : currentThread.id)) {
          hasSetThreadId = true;
          const wasPlaceholderThread = currentThreadId === PLACEHOLDER_THREAD.id;
          await switchCurrentThread(chunk.responseMessageDto.threadId, false);
          if (wasPlaceholderThread) {
            await addThreadToCache(chunk.responseMessageDto.threadId, contextKey2);
            maybeAutoGenerateThreadName(chunk.responseMessageDto.threadId, contextKey2);
          }
        }
        if (!finalMessage) {
          finalMessage = ((_b = chunk.responseMessageDto.component) == null ? void 0 : _b.componentName) ? renderComponentIntoMessage(chunk.responseMessageDto, componentList) : chunk.responseMessageDto;
          await addThreadMessage(finalMessage, false);
        } else {
          if ((_c = chunk.responseMessageDto.component) == null ? void 0 : _c.toolCallRequest) {
            const { toolName } = chunk.responseMessageDto.component.toolCallRequest;
            const tool = toolName ? toolRegistry[toolName] : void 0;
            const isStreamable = ((_d = tool == null ? void 0 : tool.annotations) == null ? void 0 : _d.tamboStreamableHint) ?? false;
            if (isStreamable) {
              void await handleToolCall(chunk.responseMessageDto.component.toolCallRequest, toolRegistry, onCallUnregisteredTool);
            }
          }
          const previousMessageId = finalMessage.id;
          if ((_e = chunk.responseMessageDto.component) == null ? void 0 : _e.componentName) {
            finalMessage = renderComponentIntoMessage(chunk.responseMessageDto, componentList);
          } else {
            finalMessage = chunk.responseMessageDto;
          }
          const isNewMessage = chunk.responseMessageDto.id !== previousMessageId;
          if (isNewMessage) {
            await addThreadMessage(finalMessage, false);
          } else {
            await updateThreadMessage(finalMessage.id, finalMessage, false);
          }
        }
      }
    }
    const completedThreadId = (finalMessage == null ? void 0 : finalMessage.threadId) ?? threadId;
    updateThreadStatus(completedThreadId, GenerationStage.COMPLETE);
    maybeAutoGenerateThreadName(completedThreadId, contextKey2);
    return finalMessage ?? {
      ...createEmptyMessage(completedThreadId),
      content: [{ type: "text", text: "Error processing stream" }]
    };
  }, [
    addThreadMessage,
    addThreadToCache,
    maybeAutoGenerateThreadName,
    client,
    componentList,
    currentThread == null ? void 0 : currentThread.id,
    currentThreadId,
    onCallUnregisteredTool,
    switchCurrentThread,
    toolRegistry,
    updateThreadMessage,
    updateThreadStatus
  ]);
  const sendThreadMessage = (0, import_react13.useCallback)(async (message, options = {}) => {
    setIgnoreResponse(false);
    const { threadId = currentThreadId ?? placeholderThread.id, streamResponse = streaming, forceToolChoice, contextKey: contextKey2, additionalContext, content } = options;
    if (!streamResponse) {
      throw new Error("Non-streaming mode is deprecated. Use streaming mode instead.");
    }
    updateThreadStatus(threadId, GenerationStage.FETCHING_CONTEXT);
    const helperContexts = await getAdditionalContext();
    const combinedContext = {
      ...additionalContext ?? {}
    };
    for (const helperContext of helperContexts) {
      combinedContext[helperContext.name] = helperContext.context;
    }
    const optimiticMessageId = crypto.randomUUID();
    const messageContent = content ?? [
      { type: "text", text: message }
    ];
    await addThreadMessage({
      content: messageContent,
      renderedComponent: null,
      role: "user",
      threadId,
      id: optimiticMessageId,
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      componentState: {},
      additionalContext: combinedContext
    }, false);
    maybeAutoGenerateThreadName(threadId, contextKey2);
    const availableComponents = getAvailableComponents(componentList, toolRegistry, componentToolAssociations);
    const unassociatedTools = getUnassociatedTools(toolRegistry, componentToolAssociations);
    const toolCallCounts = {};
    const params = {
      messageToAppend: {
        content: messageContent,
        role: "user",
        additionalContext: combinedContext
      },
      contextKey: contextKey2,
      availableComponents,
      clientTools: unassociatedTools.map((tool) => mapTamboToolToContextTool(tool)),
      forceToolChoice,
      toolCallCounts,
      ...threadId === placeholderThread.id && initialMessages.length > 0 && {
        initialMessages: initialMessages.map((msg) => ({
          content: msg.content,
          role: msg.role,
          additionalContext: msg.additionalContext
        }))
      }
    };
    let advanceStreamResponse;
    try {
      advanceStreamResponse = await advanceStream(client, params, threadId === placeholderThread.id ? void 0 : threadId);
    } catch (error) {
      updateThreadStatus(threadId, GenerationStage.ERROR);
      setThreadMap((prev) => {
        const thread = prev[threadId];
        if (!thread)
          return prev;
        return {
          ...prev,
          [threadId]: {
            ...thread,
            messages: thread.messages.filter((msg) => msg.id !== optimiticMessageId)
          }
        };
      });
      throw error;
    }
    try {
      const result = await handleAdvanceStream(advanceStreamResponse, params, threadId, contextKey2);
      return result;
    } catch (error) {
      updateThreadStatus(threadId, GenerationStage.ERROR);
      setThreadMap((prev) => {
        const thread = prev[threadId];
        if (!thread)
          return prev;
        return {
          ...prev,
          [threadId]: {
            ...thread,
            messages: thread.messages.filter((msg) => msg.id !== optimiticMessageId)
          }
        };
      });
      throw error;
    }
  }, [
    componentList,
    toolRegistry,
    componentToolAssociations,
    currentThreadId,
    addThreadMessage,
    client,
    updateThreadStatus,
    handleAdvanceStream,
    streaming,
    getAdditionalContext,
    placeholderThread.id,
    initialMessages,
    maybeAutoGenerateThreadName
  ]);
  return import_react13.default.createElement(
    TamboThreadContext.Provider,
    { value: {
      thread: currentThread,
      currentThreadId,
      currentThread,
      threadMap,
      setThreadMap,
      switchCurrentThread,
      startNewThread,
      updateThreadName,
      generateThreadName,
      addThreadMessage,
      updateThreadMessage,
      streaming,
      cancel,
      sendThreadMessage,
      contextKey
    } },
    import_react13.default.createElement(TamboGenerationStageProvider, { generationStage: currentGenerationStage, statusMessage: currentStatusMessage }, children)
  );
};
var useTamboGenerationStage = () => {
  const generationStageContext = (0, import_react13.useContext)(TamboGenerationStageContext);
  if (generationStageContext === void 0) {
    throw new Error("useTamboGenerationStage must be used within a TamboThreadProvider");
  }
  return generationStageContext;
};
var useTamboThread = () => {
  const threadContext = (0, import_react13.useContext)(TamboThreadContext);
  const generationStageContext = (0, import_react13.useContext)(TamboGenerationStageContext);
  if (threadContext === void 0) {
    throw new Error("useTamboThread must be used within a TamboThreadProvider");
  }
  if (generationStageContext === void 0) {
    throw new Error("useTamboThread must be used within a TamboThreadProvider");
  }
  return {
    ...threadContext,
    ...generationStageContext
  };
};
async function convertToolResponse(toolCallResponse) {
  var _a13;
  if (toolCallResponse.error) {
    return [{ type: "text", text: toText(toolCallResponse.result) }];
  }
  if ((_a13 = toolCallResponse.tamboTool) == null ? void 0 : _a13.transformToContent) {
    return await toolCallResponse.tamboTool.transformToContent(
      // result shape is user-defined; let the transform decide how to handle it
      toolCallResponse.result
    );
  }
  return [{ type: "text", text: toText(toolCallResponse.result) }];
}
function createEmptyMessage(threadId) {
  return {
    threadId,
    content: [{ type: "text", text: "" }],
    role: "assistant",
    createdAt: (/* @__PURE__ */ new Date()).toISOString(),
    id: crypto.randomUUID(),
    componentState: {}
  };
}

// node_modules/@tambo-ai/react/esm/providers/tambo-mcp-token-provider.js
var TamboMcpTokenContext = (0, import_react14.createContext)(void 0);
var TamboMcpTokenProvider = ({ children }) => {
  const clientContext = (0, import_react14.useContext)(TamboClientContext);
  if (!clientContext) {
    throw new Error("TamboMcpTokenProvider must be used within a TamboClientProvider");
  }
  const { client } = clientContext;
  const tamboBaseUrl = client.baseURL;
  const threadContext = (0, import_react14.useContext)(TamboThreadContext);
  const currentThread = (threadContext == null ? void 0 : threadContext.currentThread) ?? null;
  const currentThreadId = (threadContext == null ? void 0 : threadContext.currentThreadId) ?? null;
  const setThreadMap = (0, import_react14.useMemo)(() => (threadContext == null ? void 0 : threadContext.setThreadMap) ?? (() => {
  }), [threadContext == null ? void 0 : threadContext.setThreadMap]);
  const previousThreadId = (0, import_react14.useRef)(null);
  const selectedToken = (0, import_react14.useMemo)(() => {
    return (currentThread == null ? void 0 : currentThread.mcpAccessToken) ?? null;
  }, [currentThread]);
  (0, import_react14.useEffect)(() => {
    const hasThreadChanged = previousThreadId.current !== currentThreadId;
    previousThreadId.current = currentThreadId;
    const isPlaceholderThread = currentThreadId === PLACEHOLDER_THREAD.id;
    const shouldFetchThreadToken = hasThreadChanged && currentThreadId && !isPlaceholderThread && currentThread && !currentThread.mcpAccessToken;
    if (shouldFetchThreadToken) {
      const fetchThreadToken = async () => {
        try {
          const response = await client.beta.auth.getMcpToken({
            threadId: currentThreadId
          });
          if (response.mcpAccessToken) {
            setThreadMap((prev) => {
              const thread = prev[currentThreadId];
              if (thread) {
                return {
                  ...prev,
                  [currentThreadId]: {
                    ...thread,
                    mcpAccessToken: response.mcpAccessToken
                  }
                };
              }
              return prev;
            });
          }
        } catch (error) {
          console.error(`Failed to fetch MCP token for thread ${currentThreadId}:`, error);
        }
      };
      void fetchThreadToken();
    }
  }, [currentThreadId, currentThread, client, setThreadMap]);
  const value = (0, import_react14.useMemo)(() => ({ mcpAccessToken: selectedToken, tamboBaseUrl }), [selectedToken, tamboBaseUrl]);
  return import_react14.default.createElement(TamboMcpTokenContext.Provider, { value }, children);
};
var useTamboMcpToken = (contextKey) => {
  const context = (0, import_react14.useContext)(TamboMcpTokenContext);
  if (context === void 0) {
    throw new Error("useTamboMcpToken must be used within a TamboMcpTokenProvider");
  }
  const clientContext = (0, import_react14.useContext)(TamboClientContext);
  if (!clientContext) {
    throw new Error("useTamboMcpToken must be used within a TamboClientProvider");
  }
  const { client } = clientContext;
  const threadContext = (0, import_react14.useContext)(TamboThreadContext);
  const currentThreadId = (threadContext == null ? void 0 : threadContext.currentThreadId) ?? null;
  const [threadlessToken, setThreadlessToken] = (0, import_react14.useState)(null);
  const hasAttemptedFetch = (0, import_react14.useRef)(false);
  const isPlaceholderThread = currentThreadId === PLACEHOLDER_THREAD.id;
  const shouldFetchThreadless = contextKey && (!currentThreadId || isPlaceholderThread) && !context.mcpAccessToken && !threadlessToken && !hasAttemptedFetch.current;
  (0, import_react14.useEffect)(() => {
    if (shouldFetchThreadless) {
      hasAttemptedFetch.current = true;
      const fetchThreadlessToken = async () => {
        try {
          const response = await client.beta.auth.getMcpToken({ contextKey });
          if (response.mcpAccessToken) {
            setThreadlessToken(response.mcpAccessToken);
          }
        } catch (error) {
          console.error("Failed to fetch threadless MCP token:", error);
        }
      };
      void fetchThreadlessToken();
    }
  }, [shouldFetchThreadless, client, contextKey]);
  (0, import_react14.useEffect)(() => {
    if (currentThreadId && currentThreadId !== PLACEHOLDER_THREAD.id) {
      setThreadlessToken(null);
      hasAttemptedFetch.current = false;
    }
  }, [currentThreadId]);
  const selectedToken = context.mcpAccessToken ?? threadlessToken;
  return {
    mcpAccessToken: selectedToken,
    tamboBaseUrl: context.tamboBaseUrl
  };
};

// node_modules/@tambo-ai/react/esm/mcp/elicitation.js
var import_react15 = __toESM(require_react());
function toElicitationRequestedSchema(value) {
  return value;
}
function hasRequestedSchema(params) {
  return "requestedSchema" in params;
}
function useElicitation() {
  const [elicitation, setElicitation] = (0, import_react15.useState)(null);
  const [resolveElicitation, setResolveElicitation] = (0, import_react15.useState)(null);
  const defaultElicitationHandler = (0, import_react15.useCallback)(async (request, extra) => {
    return await new Promise((resolve, reject) => {
      if (!hasRequestedSchema(request.params)) {
        const mode = "mode" in request.params ? String(request.params.mode) : "unknown";
        reject(new Error(`Unsupported MCP elicitation params: expected requestedSchema (form mode), got mode=${mode}`));
        return;
      }
      setElicitation({
        message: request.params.message,
        requestedSchema: toElicitationRequestedSchema(request.params.requestedSchema),
        signal: extra.signal
      });
      if (extra.signal.aborted) {
        setElicitation(null);
        reject(new Error("Request aborted"));
        return;
      }
      const handleAbort = () => {
        setElicitation(null);
        setResolveElicitation(null);
        reject(new Error("Request aborted"));
      };
      extra.signal.addEventListener("abort", handleAbort, { once: true });
      setResolveElicitation(() => (response) => {
        extra.signal.removeEventListener("abort", handleAbort);
        setElicitation(null);
        setResolveElicitation(null);
        resolve(response);
      });
    });
  }, []);
  return {
    elicitation,
    setElicitation,
    resolveElicitation,
    setResolveElicitation,
    defaultElicitationHandler
  };
}

// node_modules/zod/v4/mini/schemas.js
var ZodMiniType = $constructor("ZodMiniType", (inst, def) => {
  if (!inst._zod)
    throw new Error("Uninitialized schema in ZodMiniType.");
  $ZodType.init(inst, def);
  inst.def = def;
  inst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (_def, params) => clone(inst, _def, params);
  inst.brand = () => inst;
  inst.register = (reg, meta) => {
    reg.add(inst, meta);
    return inst;
  };
});
var ZodMiniString = $constructor("ZodMiniString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniStringFormat = $constructor("ZodMiniStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  ZodMiniString.init(inst, def);
});
var ZodMiniEmail = $constructor("ZodMiniEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniGUID = $constructor("ZodMiniGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniUUID = $constructor("ZodMiniUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniURL = $constructor("ZodMiniURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniEmoji = $constructor("ZodMiniEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniNanoID = $constructor("ZodMiniNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCUID = $constructor("ZodMiniCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCUID2 = $constructor("ZodMiniCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniULID = $constructor("ZodMiniULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniXID = $constructor("ZodMiniXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniKSUID = $constructor("ZodMiniKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniIPv4 = $constructor("ZodMiniIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniIPv6 = $constructor("ZodMiniIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCIDRv4 = $constructor("ZodMiniCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCIDRv6 = $constructor("ZodMiniCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniBase64 = $constructor("ZodMiniBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniBase64URL = $constructor("ZodMiniBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniE164 = $constructor("ZodMiniE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniJWT = $constructor("ZodMiniJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniCustomStringFormat = $constructor("ZodMiniCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
var ZodMiniNumber = $constructor("ZodMiniNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNumberFormat = $constructor("ZodMiniNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodMiniNumber.init(inst, def);
});
var ZodMiniBoolean = $constructor("ZodMiniBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniBigInt = $constructor("ZodMiniBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniBigIntFormat = $constructor("ZodMiniBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodMiniBigInt.init(inst, def);
});
var ZodMiniSymbol = $constructor("ZodMiniSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniUndefined = $constructor("ZodMiniUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNull = $constructor("ZodMiniNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniAny = $constructor("ZodMiniAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniUnknown = $constructor("ZodMiniUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNever = $constructor("ZodMiniNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniVoid = $constructor("ZodMiniVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniDate = $constructor("ZodMiniDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniArray = $constructor("ZodMiniArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniObject = $constructor("ZodMiniObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodMiniType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
});
var ZodMiniUnion = $constructor("ZodMiniUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniDiscriminatedUnion = $constructor("ZodMiniDiscriminatedUnion", (inst, def) => {
  $ZodDiscriminatedUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniIntersection = $constructor("ZodMiniIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTuple = $constructor("ZodMiniTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniRecord = $constructor("ZodMiniRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniMap = $constructor("ZodMiniMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniSet = $constructor("ZodMiniSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniEnum = $constructor("ZodMiniEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniLiteral = $constructor("ZodMiniLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniFile = $constructor("ZodMiniFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTransform = $constructor("ZodMiniTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniOptional = $constructor("ZodMiniOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNullable = $constructor("ZodMiniNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniDefault = $constructor("ZodMiniDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniPrefault = $constructor("ZodMiniPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNonOptional = $constructor("ZodMiniNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniSuccess = $constructor("ZodMiniSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniCatch = $constructor("ZodMiniCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniNaN = $constructor("ZodMiniNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniPipe = $constructor("ZodMiniPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniReadonly = $constructor("ZodMiniReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniTemplateLiteral = $constructor("ZodMiniTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniLazy = $constructor("ZodMiniLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniPromise = $constructor("ZodMiniPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodMiniType.init(inst, def);
});
var ZodMiniCustom = $constructor("ZodMiniCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodMiniType.init(inst, def);
});

// node_modules/zod/v4/mini/iso.js
var iso_exports2 = {};
__export(iso_exports2, {
  ZodMiniISODate: () => ZodMiniISODate,
  ZodMiniISODateTime: () => ZodMiniISODateTime,
  ZodMiniISODuration: () => ZodMiniISODuration,
  ZodMiniISOTime: () => ZodMiniISOTime,
  date: () => date4,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodMiniISODateTime = $constructor("$ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodMiniISODateTime, params);
}
var ZodMiniISODate = $constructor("$ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function date4(params) {
  return _isoDate(ZodMiniISODate, params);
}
var ZodMiniISOTime = $constructor("$ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodMiniISOTime, params);
}
var ZodMiniISODuration = $constructor("$ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodMiniISODuration, params);
}

// node_modules/zod/v4/mini/coerce.js
var coerce_exports2 = {};
__export(coerce_exports2, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date5,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodMiniString, params);
}
function number3(params) {
  return _coercedNumber(ZodMiniNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodMiniBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodMiniBigInt, params);
}
function date5(params) {
  return _coercedDate(ZodMiniDate, params);
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-compat.js
function isZ4Schema(s) {
  const schema = s;
  return !!schema._zod;
}
function safeParse3(schema, data) {
  if (isZ4Schema(schema)) {
    const result2 = safeParse(schema, data);
    return result2;
  }
  const v3Schema = schema;
  const result = v3Schema.safeParse(data);
  return result;
}
function getObjectShape(schema) {
  var _a13, _b;
  if (!schema)
    return void 0;
  let rawShape;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    rawShape = (_b = (_a13 = v4Schema._zod) == null ? void 0 : _a13.def) == null ? void 0 : _b.shape;
  } else {
    const v3Schema = schema;
    rawShape = v3Schema.shape;
  }
  if (!rawShape)
    return void 0;
  if (typeof rawShape === "function") {
    try {
      return rawShape();
    } catch {
      return void 0;
    }
  }
  return rawShape;
}
function getLiteralValue(schema) {
  var _a13;
  if (isZ4Schema(schema)) {
    const v4Schema = schema;
    const def2 = (_a13 = v4Schema._zod) == null ? void 0 : _a13.def;
    if (def2) {
      if (def2.value !== void 0)
        return def2.value;
      if (Array.isArray(def2.values) && def2.values.length > 0) {
        return def2.values[0];
      }
    }
  }
  const v3Schema = schema;
  const def = v3Schema._def;
  if (def) {
    if (def.value !== void 0)
      return def.value;
    if (Array.isArray(def.values) && def.values.length > 0) {
      return def.values[0];
    }
  }
  const directValue = schema.value;
  if (directValue !== void 0)
    return directValue;
  return void 0;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/types.js
var LATEST_PROTOCOL_VERSION = "2025-11-25";
var SUPPORTED_PROTOCOL_VERSIONS = [LATEST_PROTOCOL_VERSION, "2025-06-18", "2025-03-26", "2024-11-05", "2024-10-07"];
var RELATED_TASK_META_KEY = "io.modelcontextprotocol/related-task";
var JSONRPC_VERSION = "2.0";
var AssertObjectSchema = custom((v) => v !== null && (typeof v === "object" || typeof v === "function"));
var ProgressTokenSchema = union([string(), number().int()]);
var CursorSchema = string();
var TaskCreationParamsSchema = looseObject({
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number(), _null2()]).optional(),
  /**
   * Time in milliseconds to wait between task status requests.
   */
  pollInterval: number().optional()
});
var TaskMetadataSchema = object({
  ttl: number().optional()
});
var RelatedTaskMetadataSchema = object({
  taskId: string()
});
var RequestMetaSchema = looseObject({
  /**
   * If specified, the caller is requesting out-of-band progress notifications for this request (as represented by notifications/progress). The value of this parameter is an opaque token that will be attached to any subsequent notifications. The receiver is not obligated to provide these notifications.
   */
  progressToken: ProgressTokenSchema.optional(),
  /**
   * If specified, this request is related to the provided task.
   */
  [RELATED_TASK_META_KEY]: RelatedTaskMetadataSchema.optional()
});
var BaseRequestParamsSchema = object({
  /**
   * See [General fields: `_meta`](/specification/draft/basic/index#meta) for notes on `_meta` usage.
   */
  _meta: RequestMetaSchema.optional()
});
var TaskAugmentedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * If specified, the caller is requesting task-augmented execution for this request.
   * The request will return a CreateTaskResult immediately, and the actual result can be
   * retrieved later via tasks/result.
   *
   * Task augmentation is subject to capability negotiation - receivers MUST declare support
   * for task augmentation of specific request types in their capabilities.
   */
  task: TaskMetadataSchema.optional()
});
var isTaskAugmentedRequestParams = (value) => TaskAugmentedRequestParamsSchema.safeParse(value).success;
var RequestSchema = object({
  method: string(),
  params: BaseRequestParamsSchema.loose().optional()
});
var NotificationsParamsSchema = object({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
var NotificationSchema = object({
  method: string(),
  params: NotificationsParamsSchema.loose().optional()
});
var ResultSchema = looseObject({
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: RequestMetaSchema.optional()
});
var RequestIdSchema = union([string(), number().int()]);
var JSONRPCRequestSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  ...RequestSchema.shape
}).strict();
var isJSONRPCRequest = (value) => JSONRPCRequestSchema.safeParse(value).success;
var JSONRPCNotificationSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  ...NotificationSchema.shape
}).strict();
var isJSONRPCNotification = (value) => JSONRPCNotificationSchema.safeParse(value).success;
var JSONRPCResultResponseSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema,
  result: ResultSchema
}).strict();
var isJSONRPCResultResponse = (value) => JSONRPCResultResponseSchema.safeParse(value).success;
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["ConnectionClosed"] = -32e3] = "ConnectionClosed";
  ErrorCode2[ErrorCode2["RequestTimeout"] = -32001] = "RequestTimeout";
  ErrorCode2[ErrorCode2["ParseError"] = -32700] = "ParseError";
  ErrorCode2[ErrorCode2["InvalidRequest"] = -32600] = "InvalidRequest";
  ErrorCode2[ErrorCode2["MethodNotFound"] = -32601] = "MethodNotFound";
  ErrorCode2[ErrorCode2["InvalidParams"] = -32602] = "InvalidParams";
  ErrorCode2[ErrorCode2["InternalError"] = -32603] = "InternalError";
  ErrorCode2[ErrorCode2["UrlElicitationRequired"] = -32042] = "UrlElicitationRequired";
})(ErrorCode || (ErrorCode = {}));
var JSONRPCErrorResponseSchema = object({
  jsonrpc: literal(JSONRPC_VERSION),
  id: RequestIdSchema.optional(),
  error: object({
    /**
     * The error type that occurred.
     */
    code: number().int(),
    /**
     * A short description of the error. The message SHOULD be limited to a concise single sentence.
     */
    message: string(),
    /**
     * Additional information about the error. The value of this member is defined by the sender (e.g. detailed error information, nested errors etc.).
     */
    data: unknown().optional()
  })
}).strict();
var isJSONRPCErrorResponse = (value) => JSONRPCErrorResponseSchema.safeParse(value).success;
var JSONRPCMessageSchema = union([
  JSONRPCRequestSchema,
  JSONRPCNotificationSchema,
  JSONRPCResultResponseSchema,
  JSONRPCErrorResponseSchema
]);
var JSONRPCResponseSchema = union([JSONRPCResultResponseSchema, JSONRPCErrorResponseSchema]);
var EmptyResultSchema = ResultSchema.strict();
var CancelledNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the request to cancel.
   *
   * This MUST correspond to the ID of a request previously issued in the same direction.
   */
  requestId: RequestIdSchema.optional(),
  /**
   * An optional string describing the reason for the cancellation. This MAY be logged or presented to the user.
   */
  reason: string().optional()
});
var CancelledNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/cancelled"),
  params: CancelledNotificationParamsSchema
});
var IconSchema = object({
  /**
   * URL or data URI for the icon.
   */
  src: string(),
  /**
   * Optional MIME type for the icon.
   */
  mimeType: string().optional(),
  /**
   * Optional array of strings that specify sizes at which the icon can be used.
   * Each string should be in WxH format (e.g., `"48x48"`, `"96x96"`) or `"any"` for scalable formats like SVG.
   *
   * If not provided, the client should assume that the icon can be used at any size.
   */
  sizes: array(string()).optional(),
  /**
   * Optional specifier for the theme this icon is designed for. `light` indicates
   * the icon is designed to be used with a light background, and `dark` indicates
   * the icon is designed to be used with a dark background.
   *
   * If not provided, the client should assume the icon can be used with any theme.
   */
  theme: _enum(["light", "dark"]).optional()
});
var IconsSchema = object({
  /**
   * Optional set of sized icons that the client can display in a user interface.
   *
   * Clients that support rendering icons MUST support at least the following MIME types:
   * - `image/png` - PNG images (safe, universal compatibility)
   * - `image/jpeg` (and `image/jpg`) - JPEG images (safe, universal compatibility)
   *
   * Clients that support rendering icons SHOULD also support:
   * - `image/svg+xml` - SVG images (scalable but requires security precautions)
   * - `image/webp` - WebP images (modern, efficient format)
   */
  icons: array(IconSchema).optional()
});
var BaseMetadataSchema = object({
  /** Intended for programmatic or logical use, but used as a display name in past specs or fallback */
  name: string(),
  /**
   * Intended for UI and end-user contexts  optimized to be human-readable and easily understood,
   * even by those unfamiliar with domain-specific terminology.
   *
   * If not provided, the name should be used for display (except for Tool,
   * where `annotations.title` should be given precedence over using `name`,
   * if present).
   */
  title: string().optional()
});
var ImplementationSchema = BaseMetadataSchema.extend({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  version: string(),
  /**
   * An optional URL of the website for this implementation.
   */
  websiteUrl: string().optional(),
  /**
   * An optional human-readable description of what this implementation does.
   *
   * This can be used by clients or servers to provide context about their purpose
   * and capabilities. For example, a server might describe the types of resources
   * or tools it provides, while a client might describe its intended use case.
   */
  description: string().optional()
});
var FormElicitationCapabilitySchema = intersection(object({
  applyDefaults: boolean().optional()
}), record(string(), unknown()));
var ElicitationCapabilitySchema = preprocess((value) => {
  if (value && typeof value === "object" && !Array.isArray(value)) {
    if (Object.keys(value).length === 0) {
      return { form: {} };
    }
  }
  return value;
}, intersection(object({
  form: FormElicitationCapabilitySchema.optional(),
  url: AssertObjectSchema.optional()
}), record(string(), unknown()).optional()));
var ClientTasksCapabilitySchema = looseObject({
  /**
   * Present if the client supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the client supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for sampling requests.
     */
    sampling: looseObject({
      createMessage: AssertObjectSchema.optional()
    }).optional(),
    /**
     * Task support for elicitation requests.
     */
    elicitation: looseObject({
      create: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
var ServerTasksCapabilitySchema = looseObject({
  /**
   * Present if the server supports listing tasks.
   */
  list: AssertObjectSchema.optional(),
  /**
   * Present if the server supports cancelling tasks.
   */
  cancel: AssertObjectSchema.optional(),
  /**
   * Capabilities for task creation on specific request types.
   */
  requests: looseObject({
    /**
     * Task support for tool requests.
     */
    tools: looseObject({
      call: AssertObjectSchema.optional()
    }).optional()
  }).optional()
});
var ClientCapabilitiesSchema = object({
  /**
   * Experimental, non-standard capabilities that the client supports.
   */
  experimental: record(string(), AssertObjectSchema).optional(),
  /**
   * Present if the client supports sampling from an LLM.
   */
  sampling: object({
    /**
     * Present if the client supports context inclusion via includeContext parameter.
     * If not declared, servers SHOULD only use `includeContext: "none"` (or omit it).
     */
    context: AssertObjectSchema.optional(),
    /**
     * Present if the client supports tool use via tools and toolChoice parameters.
     */
    tools: AssertObjectSchema.optional()
  }).optional(),
  /**
   * Present if the client supports eliciting user input.
   */
  elicitation: ElicitationCapabilitySchema.optional(),
  /**
   * Present if the client supports listing roots.
   */
  roots: object({
    /**
     * Whether the client supports issuing notifications for changes to the roots list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the client supports task creation.
   */
  tasks: ClientTasksCapabilitySchema.optional()
});
var InitializeRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The latest version of the Model Context Protocol that the client supports. The client MAY decide to support older versions as well.
   */
  protocolVersion: string(),
  capabilities: ClientCapabilitiesSchema,
  clientInfo: ImplementationSchema
});
var InitializeRequestSchema = RequestSchema.extend({
  method: literal("initialize"),
  params: InitializeRequestParamsSchema
});
var ServerCapabilitiesSchema = object({
  /**
   * Experimental, non-standard capabilities that the server supports.
   */
  experimental: record(string(), AssertObjectSchema).optional(),
  /**
   * Present if the server supports sending log messages to the client.
   */
  logging: AssertObjectSchema.optional(),
  /**
   * Present if the server supports sending completions to the client.
   */
  completions: AssertObjectSchema.optional(),
  /**
   * Present if the server offers any prompt templates.
   */
  prompts: object({
    /**
     * Whether this server supports issuing notifications for changes to the prompt list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the server offers any resources to read.
   */
  resources: object({
    /**
     * Whether this server supports clients subscribing to resource updates.
     */
    subscribe: boolean().optional(),
    /**
     * Whether this server supports issuing notifications for changes to the resource list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the server offers any tools to call.
   */
  tools: object({
    /**
     * Whether this server supports issuing notifications for changes to the tool list.
     */
    listChanged: boolean().optional()
  }).optional(),
  /**
   * Present if the server supports task creation.
   */
  tasks: ServerTasksCapabilitySchema.optional()
});
var InitializeResultSchema = ResultSchema.extend({
  /**
   * The version of the Model Context Protocol that the server wants to use. This may not match the version that the client requested. If the client cannot support this version, it MUST disconnect.
   */
  protocolVersion: string(),
  capabilities: ServerCapabilitiesSchema,
  serverInfo: ImplementationSchema,
  /**
   * Instructions describing how to use the server and its features.
   *
   * This can be used by clients to improve the LLM's understanding of available tools, resources, etc. It can be thought of like a "hint" to the model. For example, this information MAY be added to the system prompt.
   */
  instructions: string().optional()
});
var InitializedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/initialized"),
  params: NotificationsParamsSchema.optional()
});
var isInitializedNotification = (value) => InitializedNotificationSchema.safeParse(value).success;
var PingRequestSchema = RequestSchema.extend({
  method: literal("ping"),
  params: BaseRequestParamsSchema.optional()
});
var ProgressSchema = object({
  /**
   * The progress thus far. This should increase every time progress is made, even if the total is unknown.
   */
  progress: number(),
  /**
   * Total number of items to process (or total progress required), if known.
   */
  total: optional(number()),
  /**
   * An optional message describing the current progress.
   */
  message: optional(string())
});
var ProgressNotificationParamsSchema = object({
  ...NotificationsParamsSchema.shape,
  ...ProgressSchema.shape,
  /**
   * The progress token which was given in the initial request, used to associate this notification with the request that is proceeding.
   */
  progressToken: ProgressTokenSchema
});
var ProgressNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/progress"),
  params: ProgressNotificationParamsSchema
});
var PaginatedRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * An opaque token representing the current pagination position.
   * If provided, the server should return results starting after this cursor.
   */
  cursor: CursorSchema.optional()
});
var PaginatedRequestSchema = RequestSchema.extend({
  params: PaginatedRequestParamsSchema.optional()
});
var PaginatedResultSchema = ResultSchema.extend({
  /**
   * An opaque token representing the pagination position after the last returned result.
   * If present, there may be more results available.
   */
  nextCursor: CursorSchema.optional()
});
var TaskStatusSchema = _enum(["working", "input_required", "completed", "failed", "cancelled"]);
var TaskSchema = object({
  taskId: string(),
  status: TaskStatusSchema,
  /**
   * Time in milliseconds to keep task results available after completion.
   * If null, the task has unlimited lifetime until manually cleaned up.
   */
  ttl: union([number(), _null2()]),
  /**
   * ISO 8601 timestamp when the task was created.
   */
  createdAt: string(),
  /**
   * ISO 8601 timestamp when the task was last updated.
   */
  lastUpdatedAt: string(),
  pollInterval: optional(number()),
  /**
   * Optional diagnostic message for failed tasks or other status information.
   */
  statusMessage: optional(string())
});
var CreateTaskResultSchema = ResultSchema.extend({
  task: TaskSchema
});
var TaskStatusNotificationParamsSchema = NotificationsParamsSchema.merge(TaskSchema);
var TaskStatusNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tasks/status"),
  params: TaskStatusNotificationParamsSchema
});
var GetTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/get"),
  params: BaseRequestParamsSchema.extend({
    taskId: string()
  })
});
var GetTaskResultSchema = ResultSchema.merge(TaskSchema);
var GetTaskPayloadRequestSchema = RequestSchema.extend({
  method: literal("tasks/result"),
  params: BaseRequestParamsSchema.extend({
    taskId: string()
  })
});
var GetTaskPayloadResultSchema = ResultSchema.loose();
var ListTasksRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tasks/list")
});
var ListTasksResultSchema = PaginatedResultSchema.extend({
  tasks: array(TaskSchema)
});
var CancelTaskRequestSchema = RequestSchema.extend({
  method: literal("tasks/cancel"),
  params: BaseRequestParamsSchema.extend({
    taskId: string()
  })
});
var CancelTaskResultSchema = ResultSchema.merge(TaskSchema);
var ResourceContentsSchema = object({
  /**
   * The URI of this resource.
   */
  uri: string(),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var TextResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * The text of the item. This must only be set if the item can actually be represented as text (not binary data).
   */
  text: string()
});
var Base64Schema = string().refine((val) => {
  try {
    atob(val);
    return true;
  } catch {
    return false;
  }
}, { message: "Invalid Base64 string" });
var BlobResourceContentsSchema = ResourceContentsSchema.extend({
  /**
   * A base64-encoded string representing the binary data of the item.
   */
  blob: Base64Schema
});
var RoleSchema = _enum(["user", "assistant"]);
var AnnotationsSchema = object({
  /**
   * Intended audience(s) for the resource.
   */
  audience: array(RoleSchema).optional(),
  /**
   * Importance hint for the resource, from 0 (least) to 1 (most).
   */
  priority: number().min(0).max(1).optional(),
  /**
   * ISO 8601 timestamp for the most recent modification.
   */
  lastModified: iso_exports.datetime({ offset: true }).optional()
});
var ResourceSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * The URI of this resource.
   */
  uri: string(),
  /**
   * A description of what this resource represents.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string()),
  /**
   * The MIME type of this resource, if known.
   */
  mimeType: optional(string()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ResourceTemplateSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A URI template (according to RFC 6570) that can be used to construct resource URIs.
   */
  uriTemplate: string(),
  /**
   * A description of what this template is for.
   *
   * This can be used by clients to improve the LLM's understanding of available resources. It can be thought of like a "hint" to the model.
   */
  description: optional(string()),
  /**
   * The MIME type for all resources that match this template. This should only be included if all resources matching this template have the same type.
   */
  mimeType: optional(string()),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ListResourcesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/list")
});
var ListResourcesResultSchema = PaginatedResultSchema.extend({
  resources: array(ResourceSchema)
});
var ListResourceTemplatesRequestSchema = PaginatedRequestSchema.extend({
  method: literal("resources/templates/list")
});
var ListResourceTemplatesResultSchema = PaginatedResultSchema.extend({
  resourceTemplates: array(ResourceTemplateSchema)
});
var ResourceRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The URI of the resource to read. The URI can use any protocol; it is up to the server how to interpret it.
   *
   * @format uri
   */
  uri: string()
});
var ReadResourceRequestParamsSchema = ResourceRequestParamsSchema;
var ReadResourceRequestSchema = RequestSchema.extend({
  method: literal("resources/read"),
  params: ReadResourceRequestParamsSchema
});
var ReadResourceResultSchema = ResultSchema.extend({
  contents: array(union([TextResourceContentsSchema, BlobResourceContentsSchema]))
});
var ResourceListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var SubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var SubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/subscribe"),
  params: SubscribeRequestParamsSchema
});
var UnsubscribeRequestParamsSchema = ResourceRequestParamsSchema;
var UnsubscribeRequestSchema = RequestSchema.extend({
  method: literal("resources/unsubscribe"),
  params: UnsubscribeRequestParamsSchema
});
var ResourceUpdatedNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The URI of the resource that has been updated. This might be a sub-resource of the one that the client actually subscribed to.
   */
  uri: string()
});
var ResourceUpdatedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/resources/updated"),
  params: ResourceUpdatedNotificationParamsSchema
});
var PromptArgumentSchema = object({
  /**
   * The name of the argument.
   */
  name: string(),
  /**
   * A human-readable description of the argument.
   */
  description: optional(string()),
  /**
   * Whether this argument must be provided.
   */
  required: optional(boolean())
});
var PromptSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * An optional description of what this prompt provides
   */
  description: optional(string()),
  /**
   * A list of arguments to use for templating the prompt.
   */
  arguments: optional(array(PromptArgumentSchema)),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: optional(looseObject({}))
});
var ListPromptsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("prompts/list")
});
var ListPromptsResultSchema = PaginatedResultSchema.extend({
  prompts: array(PromptSchema)
});
var GetPromptRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The name of the prompt or prompt template.
   */
  name: string(),
  /**
   * Arguments to use for templating the prompt.
   */
  arguments: record(string(), string()).optional()
});
var GetPromptRequestSchema = RequestSchema.extend({
  method: literal("prompts/get"),
  params: GetPromptRequestParamsSchema
});
var TextContentSchema = object({
  type: literal("text"),
  /**
   * The text content of the message.
   */
  text: string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var ImageContentSchema = object({
  type: literal("image"),
  /**
   * The base64-encoded image data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the image. Different providers may support different image types.
   */
  mimeType: string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var AudioContentSchema = object({
  type: literal("audio"),
  /**
   * The base64-encoded audio data.
   */
  data: Base64Schema,
  /**
   * The MIME type of the audio. Different providers may support different audio types.
   */
  mimeType: string(),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var ToolUseContentSchema = object({
  type: literal("tool_use"),
  /**
   * The name of the tool to invoke.
   * Must match a tool name from the request's tools array.
   */
  name: string(),
  /**
   * Unique identifier for this tool call.
   * Used to correlate with ToolResultContent in subsequent messages.
   */
  id: string(),
  /**
   * Arguments to pass to the tool.
   * Must conform to the tool's inputSchema.
   */
  input: record(string(), unknown()),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var EmbeddedResourceSchema = object({
  type: literal("resource"),
  resource: union([TextResourceContentsSchema, BlobResourceContentsSchema]),
  /**
   * Optional annotations for the client.
   */
  annotations: AnnotationsSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var ResourceLinkSchema = ResourceSchema.extend({
  type: literal("resource_link")
});
var ContentBlockSchema = union([
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ResourceLinkSchema,
  EmbeddedResourceSchema
]);
var PromptMessageSchema = object({
  role: RoleSchema,
  content: ContentBlockSchema
});
var GetPromptResultSchema = ResultSchema.extend({
  /**
   * An optional description for the prompt.
   */
  description: string().optional(),
  messages: array(PromptMessageSchema)
});
var PromptListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/prompts/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ToolAnnotationsSchema = object({
  /**
   * A human-readable title for the tool.
   */
  title: string().optional(),
  /**
   * If true, the tool does not modify its environment.
   *
   * Default: false
   */
  readOnlyHint: boolean().optional(),
  /**
   * If true, the tool may perform destructive updates to its environment.
   * If false, the tool performs only additive updates.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: true
   */
  destructiveHint: boolean().optional(),
  /**
   * If true, calling the tool repeatedly with the same arguments
   * will have no additional effect on the its environment.
   *
   * (This property is meaningful only when `readOnlyHint == false`)
   *
   * Default: false
   */
  idempotentHint: boolean().optional(),
  /**
   * If true, this tool may interact with an "open world" of external
   * entities. If false, the tool's domain of interaction is closed.
   * For example, the world of a web search tool is open, whereas that
   * of a memory tool is not.
   *
   * Default: true
   */
  openWorldHint: boolean().optional()
});
var ToolExecutionSchema = object({
  /**
   * Indicates the tool's preference for task-augmented execution.
   * - "required": Clients MUST invoke the tool as a task
   * - "optional": Clients MAY invoke the tool as a task or normal request
   * - "forbidden": Clients MUST NOT attempt to invoke the tool as a task
   *
   * If not present, defaults to "forbidden".
   */
  taskSupport: _enum(["required", "optional", "forbidden"]).optional()
});
var ToolSchema = object({
  ...BaseMetadataSchema.shape,
  ...IconsSchema.shape,
  /**
   * A human-readable description of the tool.
   */
  description: string().optional(),
  /**
   * A JSON Schema 2020-12 object defining the expected parameters for the tool.
   * Must have type: 'object' at the root level per MCP spec.
   */
  inputSchema: object({
    type: literal("object"),
    properties: record(string(), AssertObjectSchema).optional(),
    required: array(string()).optional()
  }).catchall(unknown()),
  /**
   * An optional JSON Schema 2020-12 object defining the structure of the tool's output
   * returned in the structuredContent field of a CallToolResult.
   * Must have type: 'object' at the root level per MCP spec.
   */
  outputSchema: object({
    type: literal("object"),
    properties: record(string(), AssertObjectSchema).optional(),
    required: array(string()).optional()
  }).catchall(unknown()).optional(),
  /**
   * Optional additional tool information.
   */
  annotations: ToolAnnotationsSchema.optional(),
  /**
   * Execution-related properties for this tool.
   */
  execution: ToolExecutionSchema.optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var ListToolsRequestSchema = PaginatedRequestSchema.extend({
  method: literal("tools/list")
});
var ListToolsResultSchema = PaginatedResultSchema.extend({
  tools: array(ToolSchema)
});
var CallToolResultSchema = ResultSchema.extend({
  /**
   * A list of content objects that represent the result of the tool call.
   *
   * If the Tool does not define an outputSchema, this field MUST be present in the result.
   * For backwards compatibility, this field is always present, but it may be empty.
   */
  content: array(ContentBlockSchema).default([]),
  /**
   * An object containing structured tool output.
   *
   * If the Tool defines an outputSchema, this field MUST be present in the result, and contain a JSON object that matches the schema.
   */
  structuredContent: record(string(), unknown()).optional(),
  /**
   * Whether the tool call ended in an error.
   *
   * If not set, this is assumed to be false (the call was successful).
   *
   * Any errors that originate from the tool SHOULD be reported inside the result
   * object, with `isError` set to true, _not_ as an MCP protocol-level error
   * response. Otherwise, the LLM would not be able to see that an error occurred
   * and self-correct.
   *
   * However, any errors in _finding_ the tool, an error indicating that the
   * server does not support tool calls, or any other exceptional conditions,
   * should be reported as an MCP error response.
   */
  isError: boolean().optional()
});
var CompatibilityCallToolResultSchema = CallToolResultSchema.or(ResultSchema.extend({
  toolResult: unknown()
}));
var CallToolRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The name of the tool to call.
   */
  name: string(),
  /**
   * Arguments to pass to the tool.
   */
  arguments: record(string(), unknown()).optional()
});
var CallToolRequestSchema = RequestSchema.extend({
  method: literal("tools/call"),
  params: CallToolRequestParamsSchema
});
var ToolListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/tools/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ListChangedOptionsBaseSchema = object({
  /**
   * If true, the list will be refreshed automatically when a list changed notification is received.
   * The callback will be called with the updated list.
   *
   * If false, the callback will be called with null items, allowing manual refresh.
   *
   * @default true
   */
  autoRefresh: boolean().default(true),
  /**
   * Debounce time in milliseconds for list changed notification processing.
   *
   * Multiple notifications received within this timeframe will only trigger one refresh.
   * Set to 0 to disable debouncing.
   *
   * @default 300
   */
  debounceMs: number().int().nonnegative().default(300)
});
var LoggingLevelSchema = _enum(["debug", "info", "notice", "warning", "error", "critical", "alert", "emergency"]);
var SetLevelRequestParamsSchema = BaseRequestParamsSchema.extend({
  /**
   * The level of logging that the client wants to receive from the server. The server should send all logs at this level and higher (i.e., more severe) to the client as notifications/logging/message.
   */
  level: LoggingLevelSchema
});
var SetLevelRequestSchema = RequestSchema.extend({
  method: literal("logging/setLevel"),
  params: SetLevelRequestParamsSchema
});
var LoggingMessageNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The severity of this log message.
   */
  level: LoggingLevelSchema,
  /**
   * An optional name of the logger issuing this message.
   */
  logger: string().optional(),
  /**
   * The data to be logged, such as a string message or an object. Any JSON serializable type is allowed here.
   */
  data: unknown()
});
var LoggingMessageNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/message"),
  params: LoggingMessageNotificationParamsSchema
});
var ModelHintSchema = object({
  /**
   * A hint for a model name.
   */
  name: string().optional()
});
var ModelPreferencesSchema = object({
  /**
   * Optional hints to use for model selection.
   */
  hints: array(ModelHintSchema).optional(),
  /**
   * How much to prioritize cost when selecting a model.
   */
  costPriority: number().min(0).max(1).optional(),
  /**
   * How much to prioritize sampling speed (latency) when selecting a model.
   */
  speedPriority: number().min(0).max(1).optional(),
  /**
   * How much to prioritize intelligence and capabilities when selecting a model.
   */
  intelligencePriority: number().min(0).max(1).optional()
});
var ToolChoiceSchema = object({
  /**
   * Controls when tools are used:
   * - "auto": Model decides whether to use tools (default)
   * - "required": Model MUST use at least one tool before completing
   * - "none": Model MUST NOT use any tools
   */
  mode: _enum(["auto", "required", "none"]).optional()
});
var ToolResultContentSchema = object({
  type: literal("tool_result"),
  toolUseId: string().describe("The unique identifier for the corresponding tool call."),
  content: array(ContentBlockSchema).default([]),
  structuredContent: object({}).loose().optional(),
  isError: boolean().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var SamplingContentSchema = discriminatedUnion("type", [TextContentSchema, ImageContentSchema, AudioContentSchema]);
var SamplingMessageContentBlockSchema = discriminatedUnion("type", [
  TextContentSchema,
  ImageContentSchema,
  AudioContentSchema,
  ToolUseContentSchema,
  ToolResultContentSchema
]);
var SamplingMessageSchema = object({
  role: RoleSchema,
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)]),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var CreateMessageRequestParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  messages: array(SamplingMessageSchema),
  /**
   * The server's preferences for which model to select. The client MAY modify or omit this request.
   */
  modelPreferences: ModelPreferencesSchema.optional(),
  /**
   * An optional system prompt the server wants to use for sampling. The client MAY modify or omit this prompt.
   */
  systemPrompt: string().optional(),
  /**
   * A request to include context from one or more MCP servers (including the caller), to be attached to the prompt.
   * The client MAY ignore this request.
   *
   * Default is "none". Values "thisServer" and "allServers" are soft-deprecated. Servers SHOULD only use these values if the client
   * declares ClientCapabilities.sampling.context. These values may be removed in future spec releases.
   */
  includeContext: _enum(["none", "thisServer", "allServers"]).optional(),
  temperature: number().optional(),
  /**
   * The requested maximum number of tokens to sample (to prevent runaway completions).
   *
   * The client MAY choose to sample fewer tokens than the requested maximum.
   */
  maxTokens: number().int(),
  stopSequences: array(string()).optional(),
  /**
   * Optional metadata to pass through to the LLM provider. The format of this metadata is provider-specific.
   */
  metadata: AssertObjectSchema.optional(),
  /**
   * Tools that the model may use during generation.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   */
  tools: array(ToolSchema).optional(),
  /**
   * Controls how the model uses tools.
   * The client MUST return an error if this field is provided but ClientCapabilities.sampling.tools is not declared.
   * Default is `{ mode: "auto" }`.
   */
  toolChoice: ToolChoiceSchema.optional()
});
var CreateMessageRequestSchema = RequestSchema.extend({
  method: literal("sampling/createMessage"),
  params: CreateMessageRequestParamsSchema
});
var CreateMessageResultSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens"]).or(string())),
  role: RoleSchema,
  /**
   * Response content. Single content block (text, image, or audio).
   */
  content: SamplingContentSchema
});
var CreateMessageResultWithToolsSchema = ResultSchema.extend({
  /**
   * The name of the model that generated the message.
   */
  model: string(),
  /**
   * The reason why sampling stopped, if known.
   *
   * Standard values:
   * - "endTurn": Natural end of the assistant's turn
   * - "stopSequence": A stop sequence was encountered
   * - "maxTokens": Maximum token limit was reached
   * - "toolUse": The model wants to use one or more tools
   *
   * This field is an open string to allow for provider-specific stop reasons.
   */
  stopReason: optional(_enum(["endTurn", "stopSequence", "maxTokens", "toolUse"]).or(string())),
  role: RoleSchema,
  /**
   * Response content. May be a single block or array. May include ToolUseContent if stopReason is "toolUse".
   */
  content: union([SamplingMessageContentBlockSchema, array(SamplingMessageContentBlockSchema)])
});
var BooleanSchemaSchema = object({
  type: literal("boolean"),
  title: string().optional(),
  description: string().optional(),
  default: boolean().optional()
});
var StringSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  minLength: number().optional(),
  maxLength: number().optional(),
  format: _enum(["email", "uri", "date", "date-time"]).optional(),
  default: string().optional()
});
var NumberSchemaSchema = object({
  type: _enum(["number", "integer"]),
  title: string().optional(),
  description: string().optional(),
  minimum: number().optional(),
  maximum: number().optional(),
  default: number().optional()
});
var UntitledSingleSelectEnumSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  enum: array(string()),
  default: string().optional()
});
var TitledSingleSelectEnumSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  oneOf: array(object({
    const: string(),
    title: string()
  })),
  default: string().optional()
});
var LegacyTitledEnumSchemaSchema = object({
  type: literal("string"),
  title: string().optional(),
  description: string().optional(),
  enum: array(string()),
  enumNames: array(string()).optional(),
  default: string().optional()
});
var SingleSelectEnumSchemaSchema = union([UntitledSingleSelectEnumSchemaSchema, TitledSingleSelectEnumSchemaSchema]);
var UntitledMultiSelectEnumSchemaSchema = object({
  type: literal("array"),
  title: string().optional(),
  description: string().optional(),
  minItems: number().optional(),
  maxItems: number().optional(),
  items: object({
    type: literal("string"),
    enum: array(string())
  }),
  default: array(string()).optional()
});
var TitledMultiSelectEnumSchemaSchema = object({
  type: literal("array"),
  title: string().optional(),
  description: string().optional(),
  minItems: number().optional(),
  maxItems: number().optional(),
  items: object({
    anyOf: array(object({
      const: string(),
      title: string()
    }))
  }),
  default: array(string()).optional()
});
var MultiSelectEnumSchemaSchema = union([UntitledMultiSelectEnumSchemaSchema, TitledMultiSelectEnumSchemaSchema]);
var EnumSchemaSchema = union([LegacyTitledEnumSchemaSchema, SingleSelectEnumSchemaSchema, MultiSelectEnumSchemaSchema]);
var PrimitiveSchemaDefinitionSchema = union([EnumSchemaSchema, BooleanSchemaSchema, StringSchemaSchema, NumberSchemaSchema]);
var ElicitRequestFormParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   *
   * Optional for backward compatibility. Clients MUST treat missing mode as "form".
   */
  mode: literal("form").optional(),
  /**
   * The message to present to the user describing what information is being requested.
   */
  message: string(),
  /**
   * A restricted subset of JSON Schema.
   * Only top-level properties are allowed, without nesting.
   */
  requestedSchema: object({
    type: literal("object"),
    properties: record(string(), PrimitiveSchemaDefinitionSchema),
    required: array(string()).optional()
  })
});
var ElicitRequestURLParamsSchema = TaskAugmentedRequestParamsSchema.extend({
  /**
   * The elicitation mode.
   */
  mode: literal("url"),
  /**
   * The message to present to the user explaining why the interaction is needed.
   */
  message: string(),
  /**
   * The ID of the elicitation, which must be unique within the context of the server.
   * The client MUST treat this ID as an opaque value.
   */
  elicitationId: string(),
  /**
   * The URL that the user should navigate to.
   */
  url: string().url()
});
var ElicitRequestParamsSchema = union([ElicitRequestFormParamsSchema, ElicitRequestURLParamsSchema]);
var ElicitRequestSchema = RequestSchema.extend({
  method: literal("elicitation/create"),
  params: ElicitRequestParamsSchema
});
var ElicitationCompleteNotificationParamsSchema = NotificationsParamsSchema.extend({
  /**
   * The ID of the elicitation that completed.
   */
  elicitationId: string()
});
var ElicitationCompleteNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/elicitation/complete"),
  params: ElicitationCompleteNotificationParamsSchema
});
var ElicitResultSchema = ResultSchema.extend({
  /**
   * The user action in response to the elicitation.
   * - "accept": User submitted the form/confirmed the action
   * - "decline": User explicitly decline the action
   * - "cancel": User dismissed without making an explicit choice
   */
  action: _enum(["accept", "decline", "cancel"]),
  /**
   * The submitted form data, only present when action is "accept".
   * Contains values matching the requested schema.
   * Per MCP spec, content is "typically omitted" for decline/cancel actions.
   * We normalize null to undefined for leniency while maintaining type compatibility.
   */
  content: preprocess((val) => val === null ? void 0 : val, record(string(), union([string(), number(), boolean(), array(string())])).optional())
});
var ResourceTemplateReferenceSchema = object({
  type: literal("ref/resource"),
  /**
   * The URI or URI template of the resource.
   */
  uri: string()
});
var PromptReferenceSchema = object({
  type: literal("ref/prompt"),
  /**
   * The name of the prompt or prompt template
   */
  name: string()
});
var CompleteRequestParamsSchema = BaseRequestParamsSchema.extend({
  ref: union([PromptReferenceSchema, ResourceTemplateReferenceSchema]),
  /**
   * The argument's information
   */
  argument: object({
    /**
     * The name of the argument
     */
    name: string(),
    /**
     * The value of the argument to use for completion matching.
     */
    value: string()
  }),
  context: object({
    /**
     * Previously-resolved variables in a URI template or prompt.
     */
    arguments: record(string(), string()).optional()
  }).optional()
});
var CompleteRequestSchema = RequestSchema.extend({
  method: literal("completion/complete"),
  params: CompleteRequestParamsSchema
});
var CompleteResultSchema = ResultSchema.extend({
  completion: looseObject({
    /**
     * An array of completion values. Must not exceed 100 items.
     */
    values: array(string()).max(100),
    /**
     * The total number of completion options available. This can exceed the number of values actually sent in the response.
     */
    total: optional(number().int()),
    /**
     * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.
     */
    hasMore: optional(boolean())
  })
});
var RootSchema = object({
  /**
   * The URI identifying the root. This *must* start with file:// for now.
   */
  uri: string().startsWith("file://"),
  /**
   * An optional name for the root.
   */
  name: string().optional(),
  /**
   * See [MCP specification](https://github.com/modelcontextprotocol/modelcontextprotocol/blob/47339c03c143bb4ec01a26e721a1b8fe66634ebe/docs/specification/draft/basic/index.mdx#general-fields)
   * for notes on _meta usage.
   */
  _meta: record(string(), unknown()).optional()
});
var ListRootsRequestSchema = RequestSchema.extend({
  method: literal("roots/list"),
  params: BaseRequestParamsSchema.optional()
});
var ListRootsResultSchema = ResultSchema.extend({
  roots: array(RootSchema)
});
var RootsListChangedNotificationSchema = NotificationSchema.extend({
  method: literal("notifications/roots/list_changed"),
  params: NotificationsParamsSchema.optional()
});
var ClientRequestSchema = union([
  PingRequestSchema,
  InitializeRequestSchema,
  CompleteRequestSchema,
  SetLevelRequestSchema,
  GetPromptRequestSchema,
  ListPromptsRequestSchema,
  ListResourcesRequestSchema,
  ListResourceTemplatesRequestSchema,
  ReadResourceRequestSchema,
  SubscribeRequestSchema,
  UnsubscribeRequestSchema,
  CallToolRequestSchema,
  ListToolsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
var ClientNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  InitializedNotificationSchema,
  RootsListChangedNotificationSchema,
  TaskStatusNotificationSchema
]);
var ClientResultSchema = union([
  EmptyResultSchema,
  CreateMessageResultSchema,
  CreateMessageResultWithToolsSchema,
  ElicitResultSchema,
  ListRootsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var ServerRequestSchema = union([
  PingRequestSchema,
  CreateMessageRequestSchema,
  ElicitRequestSchema,
  ListRootsRequestSchema,
  GetTaskRequestSchema,
  GetTaskPayloadRequestSchema,
  ListTasksRequestSchema,
  CancelTaskRequestSchema
]);
var ServerNotificationSchema = union([
  CancelledNotificationSchema,
  ProgressNotificationSchema,
  LoggingMessageNotificationSchema,
  ResourceUpdatedNotificationSchema,
  ResourceListChangedNotificationSchema,
  ToolListChangedNotificationSchema,
  PromptListChangedNotificationSchema,
  TaskStatusNotificationSchema,
  ElicitationCompleteNotificationSchema
]);
var ServerResultSchema = union([
  EmptyResultSchema,
  InitializeResultSchema,
  CompleteResultSchema,
  GetPromptResultSchema,
  ListPromptsResultSchema,
  ListResourcesResultSchema,
  ListResourceTemplatesResultSchema,
  ReadResourceResultSchema,
  CallToolResultSchema,
  ListToolsResultSchema,
  GetTaskResultSchema,
  ListTasksResultSchema,
  CreateTaskResultSchema
]);
var McpError = class _McpError extends Error {
  constructor(code, message, data) {
    super(`MCP error ${code}: ${message}`);
    this.code = code;
    this.data = data;
    this.name = "McpError";
  }
  /**
   * Factory method to create the appropriate error type based on the error code and data
   */
  static fromError(code, message, data) {
    if (code === ErrorCode.UrlElicitationRequired && data) {
      const errorData = data;
      if (errorData.elicitations) {
        return new UrlElicitationRequiredError(errorData.elicitations, message);
      }
    }
    return new _McpError(code, message, data);
  }
};
var UrlElicitationRequiredError = class extends McpError {
  constructor(elicitations, message = `URL elicitation${elicitations.length > 1 ? "s" : ""} required`) {
    super(ErrorCode.UrlElicitationRequired, message, {
      elicitations
    });
  }
  get elicitations() {
    var _a13;
    return ((_a13 = this.data) == null ? void 0 : _a13.elicitations) ?? [];
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/interfaces.js
function isTerminal(status) {
  return status === "completed" || status === "failed" || status === "cancelled";
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/zod-json-schema-compat.js
function getMethodLiteral(schema) {
  const shape = getObjectShape(schema);
  const methodSchema = shape == null ? void 0 : shape.method;
  if (!methodSchema) {
    throw new Error("Schema is missing a method literal");
  }
  const value = getLiteralValue(methodSchema);
  if (typeof value !== "string") {
    throw new Error("Schema method literal must be a string");
  }
  return value;
}
function parseWithCompat(schema, data) {
  const result = safeParse3(schema, data);
  if (!result.success) {
    throw result.error;
  }
  return result.data;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/protocol.js
var DEFAULT_REQUEST_TIMEOUT_MSEC = 6e4;
var Protocol = class {
  constructor(_options) {
    this._options = _options;
    this._requestMessageId = 0;
    this._requestHandlers = /* @__PURE__ */ new Map();
    this._requestHandlerAbortControllers = /* @__PURE__ */ new Map();
    this._notificationHandlers = /* @__PURE__ */ new Map();
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers = /* @__PURE__ */ new Map();
    this._timeoutInfo = /* @__PURE__ */ new Map();
    this._pendingDebouncedNotifications = /* @__PURE__ */ new Set();
    this._taskProgressTokens = /* @__PURE__ */ new Map();
    this._requestResolvers = /* @__PURE__ */ new Map();
    this.setNotificationHandler(CancelledNotificationSchema, (notification) => {
      this._oncancel(notification);
    });
    this.setNotificationHandler(ProgressNotificationSchema, (notification) => {
      this._onprogress(notification);
    });
    this.setRequestHandler(
      PingRequestSchema,
      // Automatic pong by default.
      (_request) => ({})
    );
    this._taskStore = _options == null ? void 0 : _options.taskStore;
    this._taskMessageQueue = _options == null ? void 0 : _options.taskMessageQueue;
    if (this._taskStore) {
      this.setRequestHandler(GetTaskRequestSchema, async (request, extra) => {
        const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return {
          ...task
        };
      });
      this.setRequestHandler(GetTaskPayloadRequestSchema, async (request, extra) => {
        const handleTaskResult = async () => {
          var _a13;
          const taskId = request.params.taskId;
          if (this._taskMessageQueue) {
            let queuedMessage;
            while (queuedMessage = await this._taskMessageQueue.dequeue(taskId, extra.sessionId)) {
              if (queuedMessage.type === "response" || queuedMessage.type === "error") {
                const message = queuedMessage.message;
                const requestId = message.id;
                const resolver = this._requestResolvers.get(requestId);
                if (resolver) {
                  this._requestResolvers.delete(requestId);
                  if (queuedMessage.type === "response") {
                    resolver(message);
                  } else {
                    const errorMessage = message;
                    const error = new McpError(errorMessage.error.code, errorMessage.error.message, errorMessage.error.data);
                    resolver(error);
                  }
                } else {
                  const messageType = queuedMessage.type === "response" ? "Response" : "Error";
                  this._onerror(new Error(`${messageType} handler missing for request ${requestId}`));
                }
                continue;
              }
              await ((_a13 = this._transport) == null ? void 0 : _a13.send(queuedMessage.message, { relatedRequestId: extra.requestId }));
            }
          }
          const task = await this._taskStore.getTask(taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${taskId}`);
          }
          if (!isTerminal(task.status)) {
            await this._waitForTaskUpdate(taskId, extra.signal);
            return await handleTaskResult();
          }
          if (isTerminal(task.status)) {
            const result = await this._taskStore.getTaskResult(taskId, extra.sessionId);
            this._clearTaskQueue(taskId);
            return {
              ...result,
              _meta: {
                ...result._meta,
                [RELATED_TASK_META_KEY]: {
                  taskId
                }
              }
            };
          }
          return await handleTaskResult();
        };
        return await handleTaskResult();
      });
      this.setRequestHandler(ListTasksRequestSchema, async (request, extra) => {
        var _a13;
        try {
          const { tasks, nextCursor } = await this._taskStore.listTasks((_a13 = request.params) == null ? void 0 : _a13.cursor, extra.sessionId);
          return {
            tasks,
            nextCursor,
            _meta: {}
          };
        } catch (error) {
          throw new McpError(ErrorCode.InvalidParams, `Failed to list tasks: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
      this.setRequestHandler(CancelTaskRequestSchema, async (request, extra) => {
        try {
          const task = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!task) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found: ${request.params.taskId}`);
          }
          if (isTerminal(task.status)) {
            throw new McpError(ErrorCode.InvalidParams, `Cannot cancel task in terminal status: ${task.status}`);
          }
          await this._taskStore.updateTaskStatus(request.params.taskId, "cancelled", "Client cancelled task execution.", extra.sessionId);
          this._clearTaskQueue(request.params.taskId);
          const cancelledTask = await this._taskStore.getTask(request.params.taskId, extra.sessionId);
          if (!cancelledTask) {
            throw new McpError(ErrorCode.InvalidParams, `Task not found after cancellation: ${request.params.taskId}`);
          }
          return {
            _meta: {},
            ...cancelledTask
          };
        } catch (error) {
          if (error instanceof McpError) {
            throw error;
          }
          throw new McpError(ErrorCode.InvalidRequest, `Failed to cancel task: ${error instanceof Error ? error.message : String(error)}`);
        }
      });
    }
  }
  async _oncancel(notification) {
    if (!notification.params.requestId) {
      return;
    }
    const controller = this._requestHandlerAbortControllers.get(notification.params.requestId);
    controller == null ? void 0 : controller.abort(notification.params.reason);
  }
  _setupTimeout(messageId, timeout, maxTotalTimeout, onTimeout, resetTimeoutOnProgress = false) {
    this._timeoutInfo.set(messageId, {
      timeoutId: setTimeout(onTimeout, timeout),
      startTime: Date.now(),
      timeout,
      maxTotalTimeout,
      resetTimeoutOnProgress,
      onTimeout
    });
  }
  _resetTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (!info)
      return false;
    const totalElapsed = Date.now() - info.startTime;
    if (info.maxTotalTimeout && totalElapsed >= info.maxTotalTimeout) {
      this._timeoutInfo.delete(messageId);
      throw McpError.fromError(ErrorCode.RequestTimeout, "Maximum total timeout exceeded", {
        maxTotalTimeout: info.maxTotalTimeout,
        totalElapsed
      });
    }
    clearTimeout(info.timeoutId);
    info.timeoutId = setTimeout(info.onTimeout, info.timeout);
    return true;
  }
  _cleanupTimeout(messageId) {
    const info = this._timeoutInfo.get(messageId);
    if (info) {
      clearTimeout(info.timeoutId);
      this._timeoutInfo.delete(messageId);
    }
  }
  /**
   * Attaches to the given transport, starts it, and starts listening for messages.
   *
   * The Protocol object assumes ownership of the Transport, replacing any callbacks that have already been set, and expects that it is the only user of the Transport instance going forward.
   */
  async connect(transport) {
    var _a13, _b, _c;
    this._transport = transport;
    const _onclose = (_a13 = this.transport) == null ? void 0 : _a13.onclose;
    this._transport.onclose = () => {
      _onclose == null ? void 0 : _onclose();
      this._onclose();
    };
    const _onerror = (_b = this.transport) == null ? void 0 : _b.onerror;
    this._transport.onerror = (error) => {
      _onerror == null ? void 0 : _onerror(error);
      this._onerror(error);
    };
    const _onmessage = (_c = this._transport) == null ? void 0 : _c.onmessage;
    this._transport.onmessage = (message, extra) => {
      _onmessage == null ? void 0 : _onmessage(message, extra);
      if (isJSONRPCResultResponse(message) || isJSONRPCErrorResponse(message)) {
        this._onresponse(message);
      } else if (isJSONRPCRequest(message)) {
        this._onrequest(message, extra);
      } else if (isJSONRPCNotification(message)) {
        this._onnotification(message);
      } else {
        this._onerror(new Error(`Unknown message type: ${JSON.stringify(message)}`));
      }
    };
    await this._transport.start();
  }
  _onclose() {
    var _a13;
    const responseHandlers = this._responseHandlers;
    this._responseHandlers = /* @__PURE__ */ new Map();
    this._progressHandlers.clear();
    this._taskProgressTokens.clear();
    this._pendingDebouncedNotifications.clear();
    const error = McpError.fromError(ErrorCode.ConnectionClosed, "Connection closed");
    this._transport = void 0;
    (_a13 = this.onclose) == null ? void 0 : _a13.call(this);
    for (const handler2 of responseHandlers.values()) {
      handler2(error);
    }
  }
  _onerror(error) {
    var _a13;
    (_a13 = this.onerror) == null ? void 0 : _a13.call(this, error);
  }
  _onnotification(notification) {
    const handler2 = this._notificationHandlers.get(notification.method) ?? this.fallbackNotificationHandler;
    if (handler2 === void 0) {
      return;
    }
    Promise.resolve().then(() => handler2(notification)).catch((error) => this._onerror(new Error(`Uncaught error in notification handler: ${error}`)));
  }
  _onrequest(request, extra) {
    var _a13, _b, _c, _d;
    const handler2 = this._requestHandlers.get(request.method) ?? this.fallbackRequestHandler;
    const capturedTransport = this._transport;
    const relatedTaskId = (_c = (_b = (_a13 = request.params) == null ? void 0 : _a13._meta) == null ? void 0 : _b[RELATED_TASK_META_KEY]) == null ? void 0 : _c.taskId;
    if (handler2 === void 0) {
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: ErrorCode.MethodNotFound,
          message: "Method not found"
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport == null ? void 0 : capturedTransport.sessionId).catch((error) => this._onerror(new Error(`Failed to enqueue error response: ${error}`)));
      } else {
        capturedTransport == null ? void 0 : capturedTransport.send(errorResponse).catch((error) => this._onerror(new Error(`Failed to send an error response: ${error}`)));
      }
      return;
    }
    const abortController = new AbortController();
    this._requestHandlerAbortControllers.set(request.id, abortController);
    const taskCreationParams = isTaskAugmentedRequestParams(request.params) ? request.params.task : void 0;
    const taskStore = this._taskStore ? this.requestTaskStore(request, capturedTransport == null ? void 0 : capturedTransport.sessionId) : void 0;
    const fullExtra = {
      signal: abortController.signal,
      sessionId: capturedTransport == null ? void 0 : capturedTransport.sessionId,
      _meta: (_d = request.params) == null ? void 0 : _d._meta,
      sendNotification: async (notification) => {
        const notificationOptions = { relatedRequestId: request.id };
        if (relatedTaskId) {
          notificationOptions.relatedTask = { taskId: relatedTaskId };
        }
        await this.notification(notification, notificationOptions);
      },
      sendRequest: async (r2, resultSchema, options) => {
        var _a14;
        const requestOptions = { ...options, relatedRequestId: request.id };
        if (relatedTaskId && !requestOptions.relatedTask) {
          requestOptions.relatedTask = { taskId: relatedTaskId };
        }
        const effectiveTaskId = ((_a14 = requestOptions.relatedTask) == null ? void 0 : _a14.taskId) ?? relatedTaskId;
        if (effectiveTaskId && taskStore) {
          await taskStore.updateTaskStatus(effectiveTaskId, "input_required");
        }
        return await this.request(r2, resultSchema, requestOptions);
      },
      authInfo: extra == null ? void 0 : extra.authInfo,
      requestId: request.id,
      requestInfo: extra == null ? void 0 : extra.requestInfo,
      taskId: relatedTaskId,
      taskStore,
      taskRequestedTtl: taskCreationParams == null ? void 0 : taskCreationParams.ttl,
      closeSSEStream: extra == null ? void 0 : extra.closeSSEStream,
      closeStandaloneSSEStream: extra == null ? void 0 : extra.closeStandaloneSSEStream
    };
    Promise.resolve().then(() => {
      if (taskCreationParams) {
        this.assertTaskHandlerCapability(request.method);
      }
    }).then(() => handler2(request, fullExtra)).then(async (result) => {
      if (abortController.signal.aborted) {
        return;
      }
      const response = {
        result,
        jsonrpc: "2.0",
        id: request.id
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "response",
          message: response,
          timestamp: Date.now()
        }, capturedTransport == null ? void 0 : capturedTransport.sessionId);
      } else {
        await (capturedTransport == null ? void 0 : capturedTransport.send(response));
      }
    }, async (error) => {
      if (abortController.signal.aborted) {
        return;
      }
      const errorResponse = {
        jsonrpc: "2.0",
        id: request.id,
        error: {
          code: Number.isSafeInteger(error["code"]) ? error["code"] : ErrorCode.InternalError,
          message: error.message ?? "Internal error",
          ...error["data"] !== void 0 && { data: error["data"] }
        }
      };
      if (relatedTaskId && this._taskMessageQueue) {
        await this._enqueueTaskMessage(relatedTaskId, {
          type: "error",
          message: errorResponse,
          timestamp: Date.now()
        }, capturedTransport == null ? void 0 : capturedTransport.sessionId);
      } else {
        await (capturedTransport == null ? void 0 : capturedTransport.send(errorResponse));
      }
    }).catch((error) => this._onerror(new Error(`Failed to send response: ${error}`))).finally(() => {
      this._requestHandlerAbortControllers.delete(request.id);
    });
  }
  _onprogress(notification) {
    const { progressToken, ...params } = notification.params;
    const messageId = Number(progressToken);
    const handler2 = this._progressHandlers.get(messageId);
    if (!handler2) {
      this._onerror(new Error(`Received a progress notification for an unknown token: ${JSON.stringify(notification)}`));
      return;
    }
    const responseHandler = this._responseHandlers.get(messageId);
    const timeoutInfo = this._timeoutInfo.get(messageId);
    if (timeoutInfo && responseHandler && timeoutInfo.resetTimeoutOnProgress) {
      try {
        this._resetTimeout(messageId);
      } catch (error) {
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        responseHandler(error);
        return;
      }
    }
    handler2(params);
  }
  _onresponse(response) {
    const messageId = Number(response.id);
    const resolver = this._requestResolvers.get(messageId);
    if (resolver) {
      this._requestResolvers.delete(messageId);
      if (isJSONRPCResultResponse(response)) {
        resolver(response);
      } else {
        const error = new McpError(response.error.code, response.error.message, response.error.data);
        resolver(error);
      }
      return;
    }
    const handler2 = this._responseHandlers.get(messageId);
    if (handler2 === void 0) {
      this._onerror(new Error(`Received a response for an unknown message ID: ${JSON.stringify(response)}`));
      return;
    }
    this._responseHandlers.delete(messageId);
    this._cleanupTimeout(messageId);
    let isTaskResponse = false;
    if (isJSONRPCResultResponse(response) && response.result && typeof response.result === "object") {
      const result = response.result;
      if (result.task && typeof result.task === "object") {
        const task = result.task;
        if (typeof task.taskId === "string") {
          isTaskResponse = true;
          this._taskProgressTokens.set(task.taskId, messageId);
        }
      }
    }
    if (!isTaskResponse) {
      this._progressHandlers.delete(messageId);
    }
    if (isJSONRPCResultResponse(response)) {
      handler2(response);
    } else {
      const error = McpError.fromError(response.error.code, response.error.message, response.error.data);
      handler2(error);
    }
  }
  get transport() {
    return this._transport;
  }
  /**
   * Closes the connection.
   */
  async close() {
    var _a13;
    await ((_a13 = this._transport) == null ? void 0 : _a13.close());
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * @example
   * ```typescript
   * const stream = protocol.requestStream(request, resultSchema, options);
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Task created:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Task status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Final result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @experimental Use `client.experimental.tasks.requestStream()` to access this method.
   */
  async *requestStream(request, resultSchema, options) {
    var _a13, _b;
    const { task } = options ?? {};
    if (!task) {
      try {
        const result = await this.request(request, resultSchema, options);
        yield { type: "result", result };
      } catch (error) {
        yield {
          type: "error",
          error: error instanceof McpError ? error : new McpError(ErrorCode.InternalError, String(error))
        };
      }
      return;
    }
    let taskId;
    try {
      const createResult = await this.request(request, CreateTaskResultSchema, options);
      if (createResult.task) {
        taskId = createResult.task.taskId;
        yield { type: "taskCreated", task: createResult.task };
      } else {
        throw new McpError(ErrorCode.InternalError, "Task creation did not return a task");
      }
      while (true) {
        const task2 = await this.getTask({ taskId }, options);
        yield { type: "taskStatus", task: task2 };
        if (isTerminal(task2.status)) {
          if (task2.status === "completed") {
            const result = await this.getTaskResult({ taskId }, resultSchema, options);
            yield { type: "result", result };
          } else if (task2.status === "failed") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} failed`)
            };
          } else if (task2.status === "cancelled") {
            yield {
              type: "error",
              error: new McpError(ErrorCode.InternalError, `Task ${taskId} was cancelled`)
            };
          }
          return;
        }
        if (task2.status === "input_required") {
          const result = await this.getTaskResult({ taskId }, resultSchema, options);
          yield { type: "result", result };
          return;
        }
        const pollInterval = task2.pollInterval ?? ((_a13 = this._options) == null ? void 0 : _a13.defaultTaskPollInterval) ?? 1e3;
        await new Promise((resolve) => setTimeout(resolve, pollInterval));
        (_b = options == null ? void 0 : options.signal) == null ? void 0 : _b.throwIfAborted();
      }
    } catch (error) {
      yield {
        type: "error",
        error: error instanceof McpError ? error : new McpError(ErrorCode.InternalError, String(error))
      };
    }
  }
  /**
   * Sends a request and waits for a response.
   *
   * Do not use this method to emit notifications! Use notification() instead.
   */
  request(request, resultSchema, options) {
    const { relatedRequestId, resumptionToken, onresumptiontoken, task, relatedTask } = options ?? {};
    return new Promise((resolve, reject) => {
      var _a13, _b, _c, _d, _e;
      const earlyReject = (error) => {
        reject(error);
      };
      if (!this._transport) {
        earlyReject(new Error("Not connected"));
        return;
      }
      if (((_a13 = this._options) == null ? void 0 : _a13.enforceStrictCapabilities) === true) {
        try {
          this.assertCapabilityForMethod(request.method);
          if (task) {
            this.assertTaskCapability(request.method);
          }
        } catch (e2) {
          earlyReject(e2);
          return;
        }
      }
      (_b = options == null ? void 0 : options.signal) == null ? void 0 : _b.throwIfAborted();
      const messageId = this._requestMessageId++;
      const jsonrpcRequest = {
        ...request,
        jsonrpc: "2.0",
        id: messageId
      };
      if (options == null ? void 0 : options.onprogress) {
        this._progressHandlers.set(messageId, options.onprogress);
        jsonrpcRequest.params = {
          ...request.params,
          _meta: {
            ...((_c = request.params) == null ? void 0 : _c._meta) || {},
            progressToken: messageId
          }
        };
      }
      if (task) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          task
        };
      }
      if (relatedTask) {
        jsonrpcRequest.params = {
          ...jsonrpcRequest.params,
          _meta: {
            ...((_d = jsonrpcRequest.params) == null ? void 0 : _d._meta) || {},
            [RELATED_TASK_META_KEY]: relatedTask
          }
        };
      }
      const cancel = (reason) => {
        var _a14;
        this._responseHandlers.delete(messageId);
        this._progressHandlers.delete(messageId);
        this._cleanupTimeout(messageId);
        (_a14 = this._transport) == null ? void 0 : _a14.send({
          jsonrpc: "2.0",
          method: "notifications/cancelled",
          params: {
            requestId: messageId,
            reason: String(reason)
          }
        }, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error2) => this._onerror(new Error(`Failed to send cancellation: ${error2}`)));
        const error = reason instanceof McpError ? reason : new McpError(ErrorCode.RequestTimeout, String(reason));
        reject(error);
      };
      this._responseHandlers.set(messageId, (response) => {
        var _a14;
        if ((_a14 = options == null ? void 0 : options.signal) == null ? void 0 : _a14.aborted) {
          return;
        }
        if (response instanceof Error) {
          return reject(response);
        }
        try {
          const parseResult = safeParse3(resultSchema, response.result);
          if (!parseResult.success) {
            reject(parseResult.error);
          } else {
            resolve(parseResult.data);
          }
        } catch (error) {
          reject(error);
        }
      });
      (_e = options == null ? void 0 : options.signal) == null ? void 0 : _e.addEventListener("abort", () => {
        var _a14;
        cancel((_a14 = options == null ? void 0 : options.signal) == null ? void 0 : _a14.reason);
      });
      const timeout = (options == null ? void 0 : options.timeout) ?? DEFAULT_REQUEST_TIMEOUT_MSEC;
      const timeoutHandler = () => cancel(McpError.fromError(ErrorCode.RequestTimeout, "Request timed out", { timeout }));
      this._setupTimeout(messageId, timeout, options == null ? void 0 : options.maxTotalTimeout, timeoutHandler, (options == null ? void 0 : options.resetTimeoutOnProgress) ?? false);
      const relatedTaskId = relatedTask == null ? void 0 : relatedTask.taskId;
      if (relatedTaskId) {
        const responseResolver = (response) => {
          const handler2 = this._responseHandlers.get(messageId);
          if (handler2) {
            handler2(response);
          } else {
            this._onerror(new Error(`Response handler missing for side-channeled request ${messageId}`));
          }
        };
        this._requestResolvers.set(messageId, responseResolver);
        this._enqueueTaskMessage(relatedTaskId, {
          type: "request",
          message: jsonrpcRequest,
          timestamp: Date.now()
        }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      } else {
        this._transport.send(jsonrpcRequest, { relatedRequestId, resumptionToken, onresumptiontoken }).catch((error) => {
          this._cleanupTimeout(messageId);
          reject(error);
        });
      }
    });
  }
  /**
   * Gets the current status of a task.
   *
   * @experimental Use `client.experimental.tasks.getTask()` to access this method.
   */
  async getTask(params, options) {
    return this.request({ method: "tasks/get", params }, GetTaskResultSchema, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @experimental Use `client.experimental.tasks.getTaskResult()` to access this method.
   */
  async getTaskResult(params, resultSchema, options) {
    return this.request({ method: "tasks/result", params }, resultSchema, options);
  }
  /**
   * Lists tasks, optionally starting from a pagination cursor.
   *
   * @experimental Use `client.experimental.tasks.listTasks()` to access this method.
   */
  async listTasks(params, options) {
    return this.request({ method: "tasks/list", params }, ListTasksResultSchema, options);
  }
  /**
   * Cancels a specific task.
   *
   * @experimental Use `client.experimental.tasks.cancelTask()` to access this method.
   */
  async cancelTask(params, options) {
    return this.request({ method: "tasks/cancel", params }, CancelTaskResultSchema, options);
  }
  /**
   * Emits a notification, which is a one-way message that does not expect a response.
   */
  async notification(notification, options) {
    var _a13, _b, _c, _d;
    if (!this._transport) {
      throw new Error("Not connected");
    }
    this.assertNotificationCapability(notification.method);
    const relatedTaskId = (_a13 = options == null ? void 0 : options.relatedTask) == null ? void 0 : _a13.taskId;
    if (relatedTaskId) {
      const jsonrpcNotification2 = {
        ...notification,
        jsonrpc: "2.0",
        params: {
          ...notification.params,
          _meta: {
            ...((_b = notification.params) == null ? void 0 : _b._meta) || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
      await this._enqueueTaskMessage(relatedTaskId, {
        type: "notification",
        message: jsonrpcNotification2,
        timestamp: Date.now()
      });
      return;
    }
    const debouncedMethods = ((_c = this._options) == null ? void 0 : _c.debouncedNotificationMethods) ?? [];
    const canDebounce = debouncedMethods.includes(notification.method) && !notification.params && !(options == null ? void 0 : options.relatedRequestId) && !(options == null ? void 0 : options.relatedTask);
    if (canDebounce) {
      if (this._pendingDebouncedNotifications.has(notification.method)) {
        return;
      }
      this._pendingDebouncedNotifications.add(notification.method);
      Promise.resolve().then(() => {
        var _a14, _b2;
        this._pendingDebouncedNotifications.delete(notification.method);
        if (!this._transport) {
          return;
        }
        let jsonrpcNotification2 = {
          ...notification,
          jsonrpc: "2.0"
        };
        if (options == null ? void 0 : options.relatedTask) {
          jsonrpcNotification2 = {
            ...jsonrpcNotification2,
            params: {
              ...jsonrpcNotification2.params,
              _meta: {
                ...((_a14 = jsonrpcNotification2.params) == null ? void 0 : _a14._meta) || {},
                [RELATED_TASK_META_KEY]: options.relatedTask
              }
            }
          };
        }
        (_b2 = this._transport) == null ? void 0 : _b2.send(jsonrpcNotification2, options).catch((error) => this._onerror(error));
      });
      return;
    }
    let jsonrpcNotification = {
      ...notification,
      jsonrpc: "2.0"
    };
    if (options == null ? void 0 : options.relatedTask) {
      jsonrpcNotification = {
        ...jsonrpcNotification,
        params: {
          ...jsonrpcNotification.params,
          _meta: {
            ...((_d = jsonrpcNotification.params) == null ? void 0 : _d._meta) || {},
            [RELATED_TASK_META_KEY]: options.relatedTask
          }
        }
      };
    }
    await this._transport.send(jsonrpcNotification, options);
  }
  /**
   * Registers a handler to invoke when this protocol object receives a request with the given method.
   *
   * Note that this will replace any previous request handler for the same method.
   */
  setRequestHandler(requestSchema, handler2) {
    const method = getMethodLiteral(requestSchema);
    this.assertRequestHandlerCapability(method);
    this._requestHandlers.set(method, (request, extra) => {
      const parsed = parseWithCompat(requestSchema, request);
      return Promise.resolve(handler2(parsed, extra));
    });
  }
  /**
   * Removes the request handler for the given method.
   */
  removeRequestHandler(method) {
    this._requestHandlers.delete(method);
  }
  /**
   * Asserts that a request handler has not already been set for the given method, in preparation for a new one being automatically installed.
   */
  assertCanSetRequestHandler(method) {
    if (this._requestHandlers.has(method)) {
      throw new Error(`A request handler for ${method} already exists, which would be overridden`);
    }
  }
  /**
   * Registers a handler to invoke when this protocol object receives a notification with the given method.
   *
   * Note that this will replace any previous notification handler for the same method.
   */
  setNotificationHandler(notificationSchema, handler2) {
    const method = getMethodLiteral(notificationSchema);
    this._notificationHandlers.set(method, (notification) => {
      const parsed = parseWithCompat(notificationSchema, notification);
      return Promise.resolve(handler2(parsed));
    });
  }
  /**
   * Removes the notification handler for the given method.
   */
  removeNotificationHandler(method) {
    this._notificationHandlers.delete(method);
  }
  /**
   * Cleans up the progress handler associated with a task.
   * This should be called when a task reaches a terminal status.
   */
  _cleanupTaskProgressHandler(taskId) {
    const progressToken = this._taskProgressTokens.get(taskId);
    if (progressToken !== void 0) {
      this._progressHandlers.delete(progressToken);
      this._taskProgressTokens.delete(taskId);
    }
  }
  /**
   * Enqueues a task-related message for side-channel delivery via tasks/result.
   * @param taskId The task ID to associate the message with
   * @param message The message to enqueue
   * @param sessionId Optional session ID for binding the operation to a specific session
   * @throws Error if taskStore is not configured or if enqueue fails (e.g., queue overflow)
   *
   * Note: If enqueue fails, it's the TaskMessageQueue implementation's responsibility to handle
   * the error appropriately (e.g., by failing the task, logging, etc.). The Protocol layer
   * simply propagates the error.
   */
  async _enqueueTaskMessage(taskId, message, sessionId) {
    var _a13;
    if (!this._taskStore || !this._taskMessageQueue) {
      throw new Error("Cannot enqueue task message: taskStore and taskMessageQueue are not configured");
    }
    const maxQueueSize = (_a13 = this._options) == null ? void 0 : _a13.maxTaskQueueSize;
    await this._taskMessageQueue.enqueue(taskId, message, sessionId, maxQueueSize);
  }
  /**
   * Clears the message queue for a task and rejects any pending request resolvers.
   * @param taskId The task ID whose queue should be cleared
   * @param sessionId Optional session ID for binding the operation to a specific session
   */
  async _clearTaskQueue(taskId, sessionId) {
    if (this._taskMessageQueue) {
      const messages = await this._taskMessageQueue.dequeueAll(taskId, sessionId);
      for (const message of messages) {
        if (message.type === "request" && isJSONRPCRequest(message.message)) {
          const requestId = message.message.id;
          const resolver = this._requestResolvers.get(requestId);
          if (resolver) {
            resolver(new McpError(ErrorCode.InternalError, "Task cancelled or completed"));
            this._requestResolvers.delete(requestId);
          } else {
            this._onerror(new Error(`Resolver missing for request ${requestId} during task ${taskId} cleanup`));
          }
        }
      }
    }
  }
  /**
   * Waits for a task update (new messages or status change) with abort signal support.
   * Uses polling to check for updates at the task's configured poll interval.
   * @param taskId The task ID to wait for
   * @param signal Abort signal to cancel the wait
   * @returns Promise that resolves when an update occurs or rejects if aborted
   */
  async _waitForTaskUpdate(taskId, signal) {
    var _a13, _b;
    let interval = ((_a13 = this._options) == null ? void 0 : _a13.defaultTaskPollInterval) ?? 1e3;
    try {
      const task = await ((_b = this._taskStore) == null ? void 0 : _b.getTask(taskId));
      if (task == null ? void 0 : task.pollInterval) {
        interval = task.pollInterval;
      }
    } catch {
    }
    return new Promise((resolve, reject) => {
      if (signal.aborted) {
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
        return;
      }
      const timeoutId = setTimeout(resolve, interval);
      signal.addEventListener("abort", () => {
        clearTimeout(timeoutId);
        reject(new McpError(ErrorCode.InvalidRequest, "Request cancelled"));
      }, { once: true });
    });
  }
  requestTaskStore(request, sessionId) {
    const taskStore = this._taskStore;
    if (!taskStore) {
      throw new Error("No task store configured");
    }
    return {
      createTask: async (taskParams) => {
        if (!request) {
          throw new Error("No request provided");
        }
        return await taskStore.createTask(taskParams, request.id, {
          method: request.method,
          params: request.params
        }, sessionId);
      },
      getTask: async (taskId) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, "Failed to retrieve task: Task not found");
        }
        return task;
      },
      storeTaskResult: async (taskId, status, result) => {
        await taskStore.storeTaskResult(taskId, status, result, sessionId);
        const task = await taskStore.getTask(taskId, sessionId);
        if (task) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: task
          });
          await this.notification(notification);
          if (isTerminal(task.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      getTaskResult: (taskId) => {
        return taskStore.getTaskResult(taskId, sessionId);
      },
      updateTaskStatus: async (taskId, status, statusMessage) => {
        const task = await taskStore.getTask(taskId, sessionId);
        if (!task) {
          throw new McpError(ErrorCode.InvalidParams, `Task "${taskId}" not found - it may have been cleaned up`);
        }
        if (isTerminal(task.status)) {
          throw new McpError(ErrorCode.InvalidParams, `Cannot update task "${taskId}" from terminal status "${task.status}" to "${status}". Terminal states (completed, failed, cancelled) cannot transition to other states.`);
        }
        await taskStore.updateTaskStatus(taskId, status, statusMessage, sessionId);
        const updatedTask = await taskStore.getTask(taskId, sessionId);
        if (updatedTask) {
          const notification = TaskStatusNotificationSchema.parse({
            method: "notifications/tasks/status",
            params: updatedTask
          });
          await this.notification(notification);
          if (isTerminal(updatedTask.status)) {
            this._cleanupTaskProgressHandler(taskId);
          }
        }
      },
      listTasks: (cursor) => {
        return taskStore.listTasks(cursor, sessionId);
      }
    };
  }
};
function isPlainObject2(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function mergeCapabilities(base, additional) {
  const result = { ...base };
  for (const key in additional) {
    const k = key;
    const addValue = additional[k];
    if (addValue === void 0)
      continue;
    const baseValue = result[k];
    if (isPlainObject2(baseValue) && isPlainObject2(addValue)) {
      result[k] = { ...baseValue, ...addValue };
    } else {
      result[k] = addValue;
    }
  }
  return result;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/validation/ajv-provider.js
var import_ajv = __toESM(require_ajv(), 1);
var import_ajv_formats = __toESM(require_dist2(), 1);
function createDefaultAjvInstance() {
  const ajv = new import_ajv.default({
    strict: false,
    validateFormats: true,
    validateSchema: false,
    allErrors: true
  });
  const addFormats = import_ajv_formats.default;
  addFormats(ajv);
  return ajv;
}
var AjvJsonSchemaValidator = class {
  /**
   * Create an AJV validator
   *
   * @param ajv - Optional pre-configured AJV instance. If not provided, a default instance will be created.
   *
   * @example
   * ```typescript
   * // Use default configuration (recommended for most cases)
   * import { AjvJsonSchemaValidator } from '@modelcontextprotocol/sdk/validation/ajv';
   * const validator = new AjvJsonSchemaValidator();
   *
   * // Or provide custom AJV instance for advanced configuration
   * import { Ajv } from 'ajv';
   * import addFormats from 'ajv-formats';
   *
   * const ajv = new Ajv({ validateFormats: true });
   * addFormats(ajv);
   * const validator = new AjvJsonSchemaValidator(ajv);
   * ```
   */
  constructor(ajv) {
    this._ajv = ajv ?? createDefaultAjvInstance();
  }
  /**
   * Create a validator for the given JSON Schema
   *
   * The validator is compiled once and can be reused multiple times.
   * If the schema has an $id, it will be cached by AJV automatically.
   *
   * @param schema - Standard JSON Schema object
   * @returns A validator function that validates input data
   */
  getValidator(schema) {
    const ajvValidator = "$id" in schema && typeof schema.$id === "string" ? this._ajv.getSchema(schema.$id) ?? this._ajv.compile(schema) : this._ajv.compile(schema);
    return (input) => {
      const valid = ajvValidator(input);
      if (valid) {
        return {
          valid: true,
          data: input,
          errorMessage: void 0
        };
      } else {
        return {
          valid: false,
          data: void 0,
          errorMessage: this._ajv.errorsText(ajvValidator.errors)
        };
      }
    };
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/client.js
var ExperimentalClientTasks = class {
  constructor(_client5) {
    this._client = _client5;
  }
  /**
   * Calls a tool and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to tool execution, allowing you to
   * observe intermediate task status updates for long-running tool calls.
   * Automatically validates structured output if the tool has an outputSchema.
   *
   * @example
   * ```typescript
   * const stream = client.experimental.tasks.callToolStream({ name: 'myTool', arguments: {} });
   * for await (const message of stream) {
   *   switch (message.type) {
   *     case 'taskCreated':
   *       console.log('Tool execution started:', message.task.taskId);
   *       break;
   *     case 'taskStatus':
   *       console.log('Tool status:', message.task.status);
   *       break;
   *     case 'result':
   *       console.log('Tool result:', message.result);
   *       break;
   *     case 'error':
   *       console.error('Tool error:', message.error);
   *       break;
   *   }
   * }
   * ```
   *
   * @param params - Tool call parameters (name and arguments)
   * @param resultSchema - Zod schema for validating the result (defaults to CallToolResultSchema)
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  async *callToolStream(params, resultSchema = CallToolResultSchema, options) {
    const clientInternal = this._client;
    const optionsWithTask = {
      ...options,
      // We check if the tool is known to be a task during auto-configuration, but assume
      // the caller knows what they're doing if they pass this explicitly
      task: (options == null ? void 0 : options.task) ?? (clientInternal.isToolTask(params.name) ? {} : void 0)
    };
    const stream = clientInternal.requestStream({ method: "tools/call", params }, resultSchema, optionsWithTask);
    const validator = clientInternal.getToolOutputValidator(params.name);
    for await (const message of stream) {
      if (message.type === "result" && validator) {
        const result = message.result;
        if (!result.structuredContent && !result.isError) {
          yield {
            type: "error",
            error: new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`)
          };
          return;
        }
        if (result.structuredContent) {
          try {
            const validationResult = validator(result.structuredContent);
            if (!validationResult.valid) {
              yield {
                type: "error",
                error: new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`)
              };
              return;
            }
          } catch (error) {
            if (error instanceof McpError) {
              yield { type: "error", error };
              return;
            }
            yield {
              type: "error",
              error: new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`)
            };
            return;
          }
        }
      }
      yield message;
    }
  }
  /**
   * Gets the current status of a task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   * @returns The task status
   *
   * @experimental
   */
  async getTask(taskId, options) {
    return this._client.getTask({ taskId }, options);
  }
  /**
   * Retrieves the result of a completed task.
   *
   * @param taskId - The task identifier
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options
   * @returns The task result
   *
   * @experimental
   */
  async getTaskResult(taskId, resultSchema, options) {
    return this._client.getTaskResult({ taskId }, resultSchema, options);
  }
  /**
   * Lists tasks with optional pagination.
   *
   * @param cursor - Optional pagination cursor
   * @param options - Optional request options
   * @returns List of tasks with optional next cursor
   *
   * @experimental
   */
  async listTasks(cursor, options) {
    return this._client.listTasks(cursor ? { cursor } : void 0, options);
  }
  /**
   * Cancels a running task.
   *
   * @param taskId - The task identifier
   * @param options - Optional request options
   *
   * @experimental
   */
  async cancelTask(taskId, options) {
    return this._client.cancelTask({ taskId }, options);
  }
  /**
   * Sends a request and returns an AsyncGenerator that yields response messages.
   * The generator is guaranteed to end with either a 'result' or 'error' message.
   *
   * This method provides streaming access to request processing, allowing you to
   * observe intermediate task status updates for task-augmented requests.
   *
   * @param request - The request to send
   * @param resultSchema - Zod schema for validating the result
   * @param options - Optional request options (timeout, signal, task creation params, etc.)
   * @returns AsyncGenerator that yields ResponseMessage objects
   *
   * @experimental
   */
  requestStream(request, resultSchema, options) {
    return this._client.requestStream(request, resultSchema, options);
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/experimental/tasks/helpers.js
function assertToolsCallTaskCapability(requests, method, entityName) {
  var _a13;
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "tools/call":
      if (!((_a13 = requests.tools) == null ? void 0 : _a13.call)) {
        throw new Error(`${entityName} does not support task creation for tools/call (required for ${method})`);
      }
      break;
    default:
      break;
  }
}
function assertClientRequestTaskCapability(requests, method, entityName) {
  var _a13, _b;
  if (!requests) {
    throw new Error(`${entityName} does not support task creation (required for ${method})`);
  }
  switch (method) {
    case "sampling/createMessage":
      if (!((_a13 = requests.sampling) == null ? void 0 : _a13.createMessage)) {
        throw new Error(`${entityName} does not support task creation for sampling/createMessage (required for ${method})`);
      }
      break;
    case "elicitation/create":
      if (!((_b = requests.elicitation) == null ? void 0 : _b.create)) {
        throw new Error(`${entityName} does not support task creation for elicitation/create (required for ${method})`);
      }
      break;
    default:
      break;
  }
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/index.js
function applyElicitationDefaults(schema, data) {
  if (!schema || data === null || typeof data !== "object")
    return;
  if (schema.type === "object" && schema.properties && typeof schema.properties === "object") {
    const obj = data;
    const props = schema.properties;
    for (const key of Object.keys(props)) {
      const propSchema = props[key];
      if (obj[key] === void 0 && Object.prototype.hasOwnProperty.call(propSchema, "default")) {
        obj[key] = propSchema.default;
      }
      if (obj[key] !== void 0) {
        applyElicitationDefaults(propSchema, obj[key]);
      }
    }
  }
  if (Array.isArray(schema.anyOf)) {
    for (const sub of schema.anyOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data);
      }
    }
  }
  if (Array.isArray(schema.oneOf)) {
    for (const sub of schema.oneOf) {
      if (typeof sub !== "boolean") {
        applyElicitationDefaults(sub, data);
      }
    }
  }
}
function getSupportedElicitationModes(capabilities) {
  if (!capabilities) {
    return { supportsFormMode: false, supportsUrlMode: false };
  }
  const hasFormCapability = capabilities.form !== void 0;
  const hasUrlCapability = capabilities.url !== void 0;
  const supportsFormMode = hasFormCapability || !hasFormCapability && !hasUrlCapability;
  const supportsUrlMode = hasUrlCapability;
  return { supportsFormMode, supportsUrlMode };
}
var Client = class extends Protocol {
  /**
   * Initializes this client with the given name and version information.
   */
  constructor(_clientInfo, options) {
    super(options);
    this._clientInfo = _clientInfo;
    this._cachedToolOutputValidators = /* @__PURE__ */ new Map();
    this._cachedKnownTaskTools = /* @__PURE__ */ new Set();
    this._cachedRequiredTaskTools = /* @__PURE__ */ new Set();
    this._listChangedDebounceTimers = /* @__PURE__ */ new Map();
    this._capabilities = (options == null ? void 0 : options.capabilities) ?? {};
    this._jsonSchemaValidator = (options == null ? void 0 : options.jsonSchemaValidator) ?? new AjvJsonSchemaValidator();
    if (options == null ? void 0 : options.listChanged) {
      this._pendingListChangedConfig = options.listChanged;
    }
  }
  /**
   * Set up handlers for list changed notifications based on config and server capabilities.
   * This should only be called after initialization when server capabilities are known.
   * Handlers are silently skipped if the server doesn't advertise the corresponding listChanged capability.
   * @internal
   */
  _setupListChangedHandlers(config2) {
    var _a13, _b, _c, _d, _e, _f;
    if (config2.tools && ((_b = (_a13 = this._serverCapabilities) == null ? void 0 : _a13.tools) == null ? void 0 : _b.listChanged)) {
      this._setupListChangedHandler("tools", ToolListChangedNotificationSchema, config2.tools, async () => {
        const result = await this.listTools();
        return result.tools;
      });
    }
    if (config2.prompts && ((_d = (_c = this._serverCapabilities) == null ? void 0 : _c.prompts) == null ? void 0 : _d.listChanged)) {
      this._setupListChangedHandler("prompts", PromptListChangedNotificationSchema, config2.prompts, async () => {
        const result = await this.listPrompts();
        return result.prompts;
      });
    }
    if (config2.resources && ((_f = (_e = this._serverCapabilities) == null ? void 0 : _e.resources) == null ? void 0 : _f.listChanged)) {
      this._setupListChangedHandler("resources", ResourceListChangedNotificationSchema, config2.resources, async () => {
        const result = await this.listResources();
        return result.resources;
      });
    }
  }
  /**
   * Access experimental features.
   *
   * WARNING: These APIs are experimental and may change without notice.
   *
   * @experimental
   */
  get experimental() {
    if (!this._experimental) {
      this._experimental = {
        tasks: new ExperimentalClientTasks(this)
      };
    }
    return this._experimental;
  }
  /**
   * Registers new capabilities. This can only be called before connecting to a transport.
   *
   * The new capabilities will be merged with any existing capabilities previously given (e.g., at initialization).
   */
  registerCapabilities(capabilities) {
    if (this.transport) {
      throw new Error("Cannot register capabilities after connecting to transport");
    }
    this._capabilities = mergeCapabilities(this._capabilities, capabilities);
  }
  /**
   * Override request handler registration to enforce client-side validation for elicitation.
   */
  setRequestHandler(requestSchema, handler2) {
    var _a13;
    const shape = getObjectShape(requestSchema);
    const methodSchema = shape == null ? void 0 : shape.method;
    if (!methodSchema) {
      throw new Error("Schema is missing a method literal");
    }
    let methodValue;
    if (isZ4Schema(methodSchema)) {
      const v4Schema = methodSchema;
      const v4Def = (_a13 = v4Schema._zod) == null ? void 0 : _a13.def;
      methodValue = (v4Def == null ? void 0 : v4Def.value) ?? v4Schema.value;
    } else {
      const v3Schema = methodSchema;
      const legacyDef = v3Schema._def;
      methodValue = (legacyDef == null ? void 0 : legacyDef.value) ?? v3Schema.value;
    }
    if (typeof methodValue !== "string") {
      throw new Error("Schema method literal must be a string");
    }
    const method = methodValue;
    if (method === "elicitation/create") {
      const wrappedHandler = async (request, extra) => {
        var _a14, _b;
        const validatedRequest = safeParse3(ElicitRequestSchema, request);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        params.mode = params.mode ?? "form";
        const { supportsFormMode, supportsUrlMode } = getSupportedElicitationModes(this._capabilities.elicitation);
        if (params.mode === "form" && !supportsFormMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support form-mode elicitation requests");
        }
        if (params.mode === "url" && !supportsUrlMode) {
          throw new McpError(ErrorCode.InvalidParams, "Client does not support URL-mode elicitation requests");
        }
        const result = await Promise.resolve(handler2(request, extra));
        if (params.task) {
          const taskValidationResult = safeParse3(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const validationResult = safeParse3(ElicitResultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid elicitation result: ${errorMessage}`);
        }
        const validatedResult = validationResult.data;
        const requestedSchema = params.mode === "form" ? params.requestedSchema : void 0;
        if (params.mode === "form" && validatedResult.action === "accept" && validatedResult.content && requestedSchema) {
          if ((_b = (_a14 = this._capabilities.elicitation) == null ? void 0 : _a14.form) == null ? void 0 : _b.applyDefaults) {
            try {
              applyElicitationDefaults(requestedSchema, validatedResult.content);
            } catch {
            }
          }
        }
        return validatedResult;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    if (method === "sampling/createMessage") {
      const wrappedHandler = async (request, extra) => {
        const validatedRequest = safeParse3(CreateMessageRequestSchema, request);
        if (!validatedRequest.success) {
          const errorMessage = validatedRequest.error instanceof Error ? validatedRequest.error.message : String(validatedRequest.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling request: ${errorMessage}`);
        }
        const { params } = validatedRequest.data;
        const result = await Promise.resolve(handler2(request, extra));
        if (params.task) {
          const taskValidationResult = safeParse3(CreateTaskResultSchema, result);
          if (!taskValidationResult.success) {
            const errorMessage = taskValidationResult.error instanceof Error ? taskValidationResult.error.message : String(taskValidationResult.error);
            throw new McpError(ErrorCode.InvalidParams, `Invalid task creation result: ${errorMessage}`);
          }
          return taskValidationResult.data;
        }
        const hasTools = params.tools || params.toolChoice;
        const resultSchema = hasTools ? CreateMessageResultWithToolsSchema : CreateMessageResultSchema;
        const validationResult = safeParse3(resultSchema, result);
        if (!validationResult.success) {
          const errorMessage = validationResult.error instanceof Error ? validationResult.error.message : String(validationResult.error);
          throw new McpError(ErrorCode.InvalidParams, `Invalid sampling result: ${errorMessage}`);
        }
        return validationResult.data;
      };
      return super.setRequestHandler(requestSchema, wrappedHandler);
    }
    return super.setRequestHandler(requestSchema, handler2);
  }
  assertCapability(capability, method) {
    var _a13;
    if (!((_a13 = this._serverCapabilities) == null ? void 0 : _a13[capability])) {
      throw new Error(`Server does not support ${capability} (required for ${method})`);
    }
  }
  async connect(transport, options) {
    await super.connect(transport);
    if (transport.sessionId !== void 0) {
      return;
    }
    try {
      const result = await this.request({
        method: "initialize",
        params: {
          protocolVersion: LATEST_PROTOCOL_VERSION,
          capabilities: this._capabilities,
          clientInfo: this._clientInfo
        }
      }, InitializeResultSchema, options);
      if (result === void 0) {
        throw new Error(`Server sent invalid initialize result: ${result}`);
      }
      if (!SUPPORTED_PROTOCOL_VERSIONS.includes(result.protocolVersion)) {
        throw new Error(`Server's protocol version is not supported: ${result.protocolVersion}`);
      }
      this._serverCapabilities = result.capabilities;
      this._serverVersion = result.serverInfo;
      if (transport.setProtocolVersion) {
        transport.setProtocolVersion(result.protocolVersion);
      }
      this._instructions = result.instructions;
      await this.notification({
        method: "notifications/initialized"
      });
      if (this._pendingListChangedConfig) {
        this._setupListChangedHandlers(this._pendingListChangedConfig);
        this._pendingListChangedConfig = void 0;
      }
    } catch (error) {
      void this.close();
      throw error;
    }
  }
  /**
   * After initialization has completed, this will be populated with the server's reported capabilities.
   */
  getServerCapabilities() {
    return this._serverCapabilities;
  }
  /**
   * After initialization has completed, this will be populated with information about the server's name and version.
   */
  getServerVersion() {
    return this._serverVersion;
  }
  /**
   * After initialization has completed, this may be populated with information about the server's instructions.
   */
  getInstructions() {
    return this._instructions;
  }
  assertCapabilityForMethod(method) {
    var _a13, _b, _c, _d, _e;
    switch (method) {
      case "logging/setLevel":
        if (!((_a13 = this._serverCapabilities) == null ? void 0 : _a13.logging)) {
          throw new Error(`Server does not support logging (required for ${method})`);
        }
        break;
      case "prompts/get":
      case "prompts/list":
        if (!((_b = this._serverCapabilities) == null ? void 0 : _b.prompts)) {
          throw new Error(`Server does not support prompts (required for ${method})`);
        }
        break;
      case "resources/list":
      case "resources/templates/list":
      case "resources/read":
      case "resources/subscribe":
      case "resources/unsubscribe":
        if (!((_c = this._serverCapabilities) == null ? void 0 : _c.resources)) {
          throw new Error(`Server does not support resources (required for ${method})`);
        }
        if (method === "resources/subscribe" && !this._serverCapabilities.resources.subscribe) {
          throw new Error(`Server does not support resource subscriptions (required for ${method})`);
        }
        break;
      case "tools/call":
      case "tools/list":
        if (!((_d = this._serverCapabilities) == null ? void 0 : _d.tools)) {
          throw new Error(`Server does not support tools (required for ${method})`);
        }
        break;
      case "completion/complete":
        if (!((_e = this._serverCapabilities) == null ? void 0 : _e.completions)) {
          throw new Error(`Server does not support completions (required for ${method})`);
        }
        break;
      case "initialize":
        break;
      case "ping":
        break;
    }
  }
  assertNotificationCapability(method) {
    var _a13;
    switch (method) {
      case "notifications/roots/list_changed":
        if (!((_a13 = this._capabilities.roots) == null ? void 0 : _a13.listChanged)) {
          throw new Error(`Client does not support roots list changed notifications (required for ${method})`);
        }
        break;
      case "notifications/initialized":
        break;
      case "notifications/cancelled":
        break;
      case "notifications/progress":
        break;
    }
  }
  assertRequestHandlerCapability(method) {
    if (!this._capabilities) {
      return;
    }
    switch (method) {
      case "sampling/createMessage":
        if (!this._capabilities.sampling) {
          throw new Error(`Client does not support sampling capability (required for ${method})`);
        }
        break;
      case "elicitation/create":
        if (!this._capabilities.elicitation) {
          throw new Error(`Client does not support elicitation capability (required for ${method})`);
        }
        break;
      case "roots/list":
        if (!this._capabilities.roots) {
          throw new Error(`Client does not support roots capability (required for ${method})`);
        }
        break;
      case "tasks/get":
      case "tasks/list":
      case "tasks/result":
      case "tasks/cancel":
        if (!this._capabilities.tasks) {
          throw new Error(`Client does not support tasks capability (required for ${method})`);
        }
        break;
      case "ping":
        break;
    }
  }
  assertTaskCapability(method) {
    var _a13, _b;
    assertToolsCallTaskCapability((_b = (_a13 = this._serverCapabilities) == null ? void 0 : _a13.tasks) == null ? void 0 : _b.requests, method, "Server");
  }
  assertTaskHandlerCapability(method) {
    var _a13;
    if (!this._capabilities) {
      return;
    }
    assertClientRequestTaskCapability((_a13 = this._capabilities.tasks) == null ? void 0 : _a13.requests, method, "Client");
  }
  async ping(options) {
    return this.request({ method: "ping" }, EmptyResultSchema, options);
  }
  async complete(params, options) {
    return this.request({ method: "completion/complete", params }, CompleteResultSchema, options);
  }
  async setLoggingLevel(level, options) {
    return this.request({ method: "logging/setLevel", params: { level } }, EmptyResultSchema, options);
  }
  async getPrompt(params, options) {
    return this.request({ method: "prompts/get", params }, GetPromptResultSchema, options);
  }
  async listPrompts(params, options) {
    return this.request({ method: "prompts/list", params }, ListPromptsResultSchema, options);
  }
  async listResources(params, options) {
    return this.request({ method: "resources/list", params }, ListResourcesResultSchema, options);
  }
  async listResourceTemplates(params, options) {
    return this.request({ method: "resources/templates/list", params }, ListResourceTemplatesResultSchema, options);
  }
  async readResource(params, options) {
    return this.request({ method: "resources/read", params }, ReadResourceResultSchema, options);
  }
  async subscribeResource(params, options) {
    return this.request({ method: "resources/subscribe", params }, EmptyResultSchema, options);
  }
  async unsubscribeResource(params, options) {
    return this.request({ method: "resources/unsubscribe", params }, EmptyResultSchema, options);
  }
  /**
   * Calls a tool and waits for the result. Automatically validates structured output if the tool has an outputSchema.
   *
   * For task-based execution with streaming behavior, use client.experimental.tasks.callToolStream() instead.
   */
  async callTool(params, resultSchema = CallToolResultSchema, options) {
    if (this.isToolTaskRequired(params.name)) {
      throw new McpError(ErrorCode.InvalidRequest, `Tool "${params.name}" requires task-based execution. Use client.experimental.tasks.callToolStream() instead.`);
    }
    const result = await this.request({ method: "tools/call", params }, resultSchema, options);
    const validator = this.getToolOutputValidator(params.name);
    if (validator) {
      if (!result.structuredContent && !result.isError) {
        throw new McpError(ErrorCode.InvalidRequest, `Tool ${params.name} has an output schema but did not return structured content`);
      }
      if (result.structuredContent) {
        try {
          const validationResult = validator(result.structuredContent);
          if (!validationResult.valid) {
            throw new McpError(ErrorCode.InvalidParams, `Structured content does not match the tool's output schema: ${validationResult.errorMessage}`);
          }
        } catch (error) {
          if (error instanceof McpError) {
            throw error;
          }
          throw new McpError(ErrorCode.InvalidParams, `Failed to validate structured content: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
    }
    return result;
  }
  isToolTask(toolName) {
    var _a13, _b, _c, _d;
    if (!((_d = (_c = (_b = (_a13 = this._serverCapabilities) == null ? void 0 : _a13.tasks) == null ? void 0 : _b.requests) == null ? void 0 : _c.tools) == null ? void 0 : _d.call)) {
      return false;
    }
    return this._cachedKnownTaskTools.has(toolName);
  }
  /**
   * Check if a tool requires task-based execution.
   * Unlike isToolTask which includes 'optional' tools, this only checks for 'required'.
   */
  isToolTaskRequired(toolName) {
    return this._cachedRequiredTaskTools.has(toolName);
  }
  /**
   * Cache validators for tool output schemas.
   * Called after listTools() to pre-compile validators for better performance.
   */
  cacheToolMetadata(tools) {
    var _a13;
    this._cachedToolOutputValidators.clear();
    this._cachedKnownTaskTools.clear();
    this._cachedRequiredTaskTools.clear();
    for (const tool of tools) {
      if (tool.outputSchema) {
        const toolValidator = this._jsonSchemaValidator.getValidator(tool.outputSchema);
        this._cachedToolOutputValidators.set(tool.name, toolValidator);
      }
      const taskSupport = (_a13 = tool.execution) == null ? void 0 : _a13.taskSupport;
      if (taskSupport === "required" || taskSupport === "optional") {
        this._cachedKnownTaskTools.add(tool.name);
      }
      if (taskSupport === "required") {
        this._cachedRequiredTaskTools.add(tool.name);
      }
    }
  }
  /**
   * Get cached validator for a tool
   */
  getToolOutputValidator(toolName) {
    return this._cachedToolOutputValidators.get(toolName);
  }
  async listTools(params, options) {
    const result = await this.request({ method: "tools/list", params }, ListToolsResultSchema, options);
    this.cacheToolMetadata(result.tools);
    return result;
  }
  /**
   * Set up a single list changed handler.
   * @internal
   */
  _setupListChangedHandler(listType, notificationSchema, options, fetcher) {
    const parseResult = ListChangedOptionsBaseSchema.safeParse(options);
    if (!parseResult.success) {
      throw new Error(`Invalid ${listType} listChanged options: ${parseResult.error.message}`);
    }
    if (typeof options.onChanged !== "function") {
      throw new Error(`Invalid ${listType} listChanged options: onChanged must be a function`);
    }
    const { autoRefresh, debounceMs } = parseResult.data;
    const { onChanged } = options;
    const refresh = async () => {
      if (!autoRefresh) {
        onChanged(null, null);
        return;
      }
      try {
        const items = await fetcher();
        onChanged(null, items);
      } catch (e2) {
        const error = e2 instanceof Error ? e2 : new Error(String(e2));
        onChanged(error, null);
      }
    };
    const handler2 = () => {
      if (debounceMs) {
        const existingTimer = this._listChangedDebounceTimers.get(listType);
        if (existingTimer) {
          clearTimeout(existingTimer);
        }
        const timer = setTimeout(refresh, debounceMs);
        this._listChangedDebounceTimers.set(listType, timer);
      } else {
        refresh();
      }
    };
    this.setNotificationHandler(notificationSchema, handler2);
  }
  async sendRootsListChanged() {
    return this.notification({ method: "notifications/roots/list_changed" });
  }
};

// node_modules/eventsource-parser/dist/index.js
var ParseError = class extends Error {
  constructor(message, options) {
    super(message), this.name = "ParseError", this.type = options.type, this.field = options.field, this.value = options.value, this.line = options.line;
  }
};
function noop3(_arg) {
}
function createParser(callbacks) {
  if (typeof callbacks == "function")
    throw new TypeError(
      "`callbacks` must be an object, got a function instead. Did you mean `{onEvent: fn}`?"
    );
  const { onEvent = noop3, onError = noop3, onRetry = noop3, onComment } = callbacks;
  let incompleteLine = "", isFirstChunk = true, id, data = "", eventType = "";
  function feed(newChunk) {
    const chunk = isFirstChunk ? newChunk.replace(/^\xEF\xBB\xBF/, "") : newChunk, [complete, incomplete] = splitLines(`${incompleteLine}${chunk}`);
    for (const line of complete)
      parseLine(line);
    incompleteLine = incomplete, isFirstChunk = false;
  }
  function parseLine(line) {
    if (line === "") {
      dispatchEvent();
      return;
    }
    if (line.startsWith(":")) {
      onComment && onComment(line.slice(line.startsWith(": ") ? 2 : 1));
      return;
    }
    const fieldSeparatorIndex = line.indexOf(":");
    if (fieldSeparatorIndex !== -1) {
      const field = line.slice(0, fieldSeparatorIndex), offset = line[fieldSeparatorIndex + 1] === " " ? 2 : 1, value = line.slice(fieldSeparatorIndex + offset);
      processField(field, value, line);
      return;
    }
    processField(line, "", line);
  }
  function processField(field, value, line) {
    switch (field) {
      case "event":
        eventType = value;
        break;
      case "data":
        data = `${data}${value}
`;
        break;
      case "id":
        id = value.includes("\0") ? void 0 : value;
        break;
      case "retry":
        /^\d+$/.test(value) ? onRetry(parseInt(value, 10)) : onError(
          new ParseError(`Invalid \`retry\` value: "${value}"`, {
            type: "invalid-retry",
            value,
            line
          })
        );
        break;
      default:
        onError(
          new ParseError(
            `Unknown field "${field.length > 20 ? `${field.slice(0, 20)}` : field}"`,
            { type: "unknown-field", field, value, line }
          )
        );
        break;
    }
  }
  function dispatchEvent() {
    data.length > 0 && onEvent({
      id,
      event: eventType || void 0,
      // If the data buffer's last character is a U+000A LINE FEED (LF) character,
      // then remove the last character from the data buffer.
      data: data.endsWith(`
`) ? data.slice(0, -1) : data
    }), id = void 0, data = "", eventType = "";
  }
  function reset(options = {}) {
    incompleteLine && options.consume && parseLine(incompleteLine), isFirstChunk = true, id = void 0, data = "", eventType = "", incompleteLine = "";
  }
  return { feed, reset };
}
function splitLines(chunk) {
  const lines = [];
  let incompleteLine = "", searchIndex = 0;
  for (; searchIndex < chunk.length; ) {
    const crIndex = chunk.indexOf("\r", searchIndex), lfIndex = chunk.indexOf(`
`, searchIndex);
    let lineEnd = -1;
    if (crIndex !== -1 && lfIndex !== -1 ? lineEnd = Math.min(crIndex, lfIndex) : crIndex !== -1 ? crIndex === chunk.length - 1 ? lineEnd = -1 : lineEnd = crIndex : lfIndex !== -1 && (lineEnd = lfIndex), lineEnd === -1) {
      incompleteLine = chunk.slice(searchIndex);
      break;
    } else {
      const line = chunk.slice(searchIndex, lineEnd);
      lines.push(line), searchIndex = lineEnd + 1, chunk[searchIndex - 1] === "\r" && chunk[searchIndex] === `
` && searchIndex++;
    }
  }
  return [lines, incompleteLine];
}

// node_modules/eventsource/dist/index.js
var ErrorEvent2 = class extends Event {
  /**
   * Constructs a new `ErrorEvent` instance. This is typically not called directly,
   * but rather emitted by the `EventSource` object when an error occurs.
   *
   * @param type - The type of the event (should be "error")
   * @param errorEventInitDict - Optional properties to include in the error event
   */
  constructor(type, errorEventInitDict) {
    var _a13, _b;
    super(type), this.code = (_a13 = errorEventInitDict == null ? void 0 : errorEventInitDict.code) != null ? _a13 : void 0, this.message = (_b = errorEventInitDict == null ? void 0 : errorEventInitDict.message) != null ? _b : void 0;
  }
  /**
   * Node.js "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Node.js when you `console.log` an instance of this class.
   *
   * @param _depth - The current depth
   * @param options - The options passed to `util.inspect`
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @returns A string representation of the error
   */
  [Symbol.for("nodejs.util.inspect.custom")](_depth, options, inspect) {
    return inspect(inspectableError(this), options);
  }
  /**
   * Deno "hides" the `message` and `code` properties of the `ErrorEvent` instance,
   * when it is `console.log`'ed. This makes it harder to debug errors. To ease debugging,
   * we explicitly include the properties in the `inspect` method.
   *
   * This is automatically called by Deno when you `console.log` an instance of this class.
   *
   * @param inspect - The inspect function to use (prevents having to import it from `util`)
   * @param options - The options passed to `Deno.inspect`
   * @returns A string representation of the error
   */
  [Symbol.for("Deno.customInspect")](inspect, options) {
    return inspect(inspectableError(this), options);
  }
};
function syntaxError(message) {
  const DomException = globalThis.DOMException;
  return typeof DomException == "function" ? new DomException(message, "SyntaxError") : new SyntaxError(message);
}
function flattenError2(err) {
  return err instanceof Error ? "errors" in err && Array.isArray(err.errors) ? err.errors.map(flattenError2).join(", ") : "cause" in err && err.cause instanceof Error ? `${err}: ${flattenError2(err.cause)}` : err.message : `${err}`;
}
function inspectableError(err) {
  return {
    type: err.type,
    message: err.message,
    code: err.code,
    defaultPrevented: err.defaultPrevented,
    cancelable: err.cancelable,
    timeStamp: err.timeStamp
  };
}
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet2 = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd2 = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet2 = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var __privateMethod2 = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
var _readyState;
var _url2;
var _redirectUrl;
var _withCredentials;
var _fetch;
var _reconnectInterval;
var _reconnectTimer;
var _lastEventId;
var _controller;
var _parser;
var _onError;
var _onMessage;
var _onOpen;
var _EventSource_instances;
var connect_fn;
var _onFetchResponse;
var _onFetchError;
var getRequestOptions_fn;
var _onEvent;
var _onRetryChange;
var failConnection_fn;
var scheduleReconnect_fn;
var _reconnect;
var EventSource = class extends EventTarget {
  constructor(url4, eventSourceInitDict) {
    var _a13, _b;
    super(), __privateAdd2(this, _EventSource_instances), this.CONNECTING = 0, this.OPEN = 1, this.CLOSED = 2, __privateAdd2(this, _readyState), __privateAdd2(this, _url2), __privateAdd2(this, _redirectUrl), __privateAdd2(this, _withCredentials), __privateAdd2(this, _fetch), __privateAdd2(this, _reconnectInterval), __privateAdd2(this, _reconnectTimer), __privateAdd2(this, _lastEventId, null), __privateAdd2(this, _controller), __privateAdd2(this, _parser), __privateAdd2(this, _onError, null), __privateAdd2(this, _onMessage, null), __privateAdd2(this, _onOpen, null), __privateAdd2(this, _onFetchResponse, async (response) => {
      var _a22;
      __privateGet2(this, _parser).reset();
      const { body, redirected, status, headers } = response;
      if (status === 204) {
        __privateMethod2(this, _EventSource_instances, failConnection_fn).call(this, "Server sent HTTP 204, not reconnecting", 204), this.close();
        return;
      }
      if (redirected ? __privateSet2(this, _redirectUrl, new URL(response.url)) : __privateSet2(this, _redirectUrl, void 0), status !== 200) {
        __privateMethod2(this, _EventSource_instances, failConnection_fn).call(this, `Non-200 status code (${status})`, status);
        return;
      }
      if (!(headers.get("content-type") || "").startsWith("text/event-stream")) {
        __privateMethod2(this, _EventSource_instances, failConnection_fn).call(this, 'Invalid content type, expected "text/event-stream"', status);
        return;
      }
      if (__privateGet2(this, _readyState) === this.CLOSED)
        return;
      __privateSet2(this, _readyState, this.OPEN);
      const openEvent = new Event("open");
      if ((_a22 = __privateGet2(this, _onOpen)) == null || _a22.call(this, openEvent), this.dispatchEvent(openEvent), typeof body != "object" || !body || !("getReader" in body)) {
        __privateMethod2(this, _EventSource_instances, failConnection_fn).call(this, "Invalid response body, expected a web ReadableStream", status), this.close();
        return;
      }
      const decoder = new TextDecoder(), reader = body.getReader();
      let open = true;
      do {
        const { done, value } = await reader.read();
        value && __privateGet2(this, _parser).feed(decoder.decode(value, { stream: !done })), done && (open = false, __privateGet2(this, _parser).reset(), __privateMethod2(this, _EventSource_instances, scheduleReconnect_fn).call(this));
      } while (open);
    }), __privateAdd2(this, _onFetchError, (err) => {
      __privateSet2(this, _controller, void 0), !(err.name === "AbortError" || err.type === "aborted") && __privateMethod2(this, _EventSource_instances, scheduleReconnect_fn).call(this, flattenError2(err));
    }), __privateAdd2(this, _onEvent, (event) => {
      typeof event.id == "string" && __privateSet2(this, _lastEventId, event.id);
      const messageEvent = new MessageEvent(event.event || "message", {
        data: event.data,
        origin: __privateGet2(this, _redirectUrl) ? __privateGet2(this, _redirectUrl).origin : __privateGet2(this, _url2).origin,
        lastEventId: event.id || ""
      });
      __privateGet2(this, _onMessage) && (!event.event || event.event === "message") && __privateGet2(this, _onMessage).call(this, messageEvent), this.dispatchEvent(messageEvent);
    }), __privateAdd2(this, _onRetryChange, (value) => {
      __privateSet2(this, _reconnectInterval, value);
    }), __privateAdd2(this, _reconnect, () => {
      __privateSet2(this, _reconnectTimer, void 0), __privateGet2(this, _readyState) === this.CONNECTING && __privateMethod2(this, _EventSource_instances, connect_fn).call(this);
    });
    try {
      if (url4 instanceof URL)
        __privateSet2(this, _url2, url4);
      else if (typeof url4 == "string")
        __privateSet2(this, _url2, new URL(url4, getBaseURL()));
      else
        throw new Error("Invalid URL");
    } catch {
      throw syntaxError("An invalid or illegal string was specified");
    }
    __privateSet2(this, _parser, createParser({
      onEvent: __privateGet2(this, _onEvent),
      onRetry: __privateGet2(this, _onRetryChange)
    })), __privateSet2(this, _readyState, this.CONNECTING), __privateSet2(this, _reconnectInterval, 3e3), __privateSet2(this, _fetch, (_a13 = eventSourceInitDict == null ? void 0 : eventSourceInitDict.fetch) != null ? _a13 : globalThis.fetch), __privateSet2(this, _withCredentials, (_b = eventSourceInitDict == null ? void 0 : eventSourceInitDict.withCredentials) != null ? _b : false), __privateMethod2(this, _EventSource_instances, connect_fn).call(this);
  }
  /**
   * Returns the state of this EventSource object's connection. It can have the values described below.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/readyState)
   *
   * Note: typed as `number` instead of `0 | 1 | 2` for compatibility with the `EventSource` interface,
   * defined in the TypeScript `dom` library.
   *
   * @public
   */
  get readyState() {
    return __privateGet2(this, _readyState);
  }
  /**
   * Returns the URL providing the event stream.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/url)
   *
   * @public
   */
  get url() {
    return __privateGet2(this, _url2).href;
  }
  /**
   * Returns true if the credentials mode for connection requests to the URL providing the event stream is set to "include", and false otherwise.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/withCredentials)
   */
  get withCredentials() {
    return __privateGet2(this, _withCredentials);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/error_event) */
  get onerror() {
    return __privateGet2(this, _onError);
  }
  set onerror(value) {
    __privateSet2(this, _onError, value);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/message_event) */
  get onmessage() {
    return __privateGet2(this, _onMessage);
  }
  set onmessage(value) {
    __privateSet2(this, _onMessage, value);
  }
  /** [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/open_event) */
  get onopen() {
    return __privateGet2(this, _onOpen);
  }
  set onopen(value) {
    __privateSet2(this, _onOpen, value);
  }
  addEventListener(type, listener, options) {
    const listen = listener;
    super.addEventListener(type, listen, options);
  }
  removeEventListener(type, listener, options) {
    const listen = listener;
    super.removeEventListener(type, listen, options);
  }
  /**
   * Aborts any instances of the fetch algorithm started for this EventSource object, and sets the readyState attribute to CLOSED.
   *
   * [MDN Reference](https://developer.mozilla.org/docs/Web/API/EventSource/close)
   *
   * @public
   */
  close() {
    __privateGet2(this, _reconnectTimer) && clearTimeout(__privateGet2(this, _reconnectTimer)), __privateGet2(this, _readyState) !== this.CLOSED && (__privateGet2(this, _controller) && __privateGet2(this, _controller).abort(), __privateSet2(this, _readyState, this.CLOSED), __privateSet2(this, _controller, void 0));
  }
};
_readyState = /* @__PURE__ */ new WeakMap(), _url2 = /* @__PURE__ */ new WeakMap(), _redirectUrl = /* @__PURE__ */ new WeakMap(), _withCredentials = /* @__PURE__ */ new WeakMap(), _fetch = /* @__PURE__ */ new WeakMap(), _reconnectInterval = /* @__PURE__ */ new WeakMap(), _reconnectTimer = /* @__PURE__ */ new WeakMap(), _lastEventId = /* @__PURE__ */ new WeakMap(), _controller = /* @__PURE__ */ new WeakMap(), _parser = /* @__PURE__ */ new WeakMap(), _onError = /* @__PURE__ */ new WeakMap(), _onMessage = /* @__PURE__ */ new WeakMap(), _onOpen = /* @__PURE__ */ new WeakMap(), _EventSource_instances = /* @__PURE__ */ new WeakSet(), /**
* Connect to the given URL and start receiving events
*
* @internal
*/
connect_fn = function() {
  __privateSet2(this, _readyState, this.CONNECTING), __privateSet2(this, _controller, new AbortController()), __privateGet2(this, _fetch)(__privateGet2(this, _url2), __privateMethod2(this, _EventSource_instances, getRequestOptions_fn).call(this)).then(__privateGet2(this, _onFetchResponse)).catch(__privateGet2(this, _onFetchError));
}, _onFetchResponse = /* @__PURE__ */ new WeakMap(), _onFetchError = /* @__PURE__ */ new WeakMap(), /**
* Get request options for the `fetch()` request
*
* @returns The request options
* @internal
*/
getRequestOptions_fn = function() {
  var _a13;
  const init = {
    // [spec] Let `corsAttributeState` be `Anonymous`
    // [spec] will have their mode set to "cors"
    mode: "cors",
    redirect: "follow",
    headers: { Accept: "text/event-stream", ...__privateGet2(this, _lastEventId) ? { "Last-Event-ID": __privateGet2(this, _lastEventId) } : void 0 },
    cache: "no-store",
    signal: (_a13 = __privateGet2(this, _controller)) == null ? void 0 : _a13.signal
  };
  return "window" in globalThis && (init.credentials = this.withCredentials ? "include" : "same-origin"), init;
}, _onEvent = /* @__PURE__ */ new WeakMap(), _onRetryChange = /* @__PURE__ */ new WeakMap(), /**
* Handles the process referred to in the EventSource specification as "failing a connection".
*
* @param error - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
failConnection_fn = function(message, code) {
  var _a13;
  __privateGet2(this, _readyState) !== this.CLOSED && __privateSet2(this, _readyState, this.CLOSED);
  const errorEvent = new ErrorEvent2("error", { code, message });
  (_a13 = __privateGet2(this, _onError)) == null || _a13.call(this, errorEvent), this.dispatchEvent(errorEvent);
}, /**
* Schedules a reconnection attempt against the EventSource endpoint.
*
* @param message - The error causing the connection to fail
* @param code - The HTTP status code, if available
* @internal
*/
scheduleReconnect_fn = function(message, code) {
  var _a13;
  if (__privateGet2(this, _readyState) === this.CLOSED)
    return;
  __privateSet2(this, _readyState, this.CONNECTING);
  const errorEvent = new ErrorEvent2("error", { code, message });
  (_a13 = __privateGet2(this, _onError)) == null || _a13.call(this, errorEvent), this.dispatchEvent(errorEvent), __privateSet2(this, _reconnectTimer, setTimeout(__privateGet2(this, _reconnect), __privateGet2(this, _reconnectInterval)));
}, _reconnect = /* @__PURE__ */ new WeakMap(), /**
* ReadyState representing an EventSource currently trying to connect
*
* @public
*/
EventSource.CONNECTING = 0, /**
* ReadyState representing an EventSource connection that is open (eg connected)
*
* @public
*/
EventSource.OPEN = 1, /**
* ReadyState representing an EventSource connection that is closed (eg disconnected)
*
* @public
*/
EventSource.CLOSED = 2;
function getBaseURL() {
  const doc = "document" in globalThis ? globalThis.document : void 0;
  return doc && typeof doc == "object" && "baseURI" in doc && typeof doc.baseURI == "string" ? doc.baseURI : void 0;
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/transport.js
function normalizeHeaders(headers) {
  if (!headers)
    return {};
  if (headers instanceof Headers) {
    return Object.fromEntries(headers.entries());
  }
  if (Array.isArray(headers)) {
    return Object.fromEntries(headers);
  }
  return { ...headers };
}
function createFetchWithInit(baseFetch = fetch, baseInit) {
  if (!baseInit) {
    return baseFetch;
  }
  return async (url4, init) => {
    const mergedInit = {
      ...baseInit,
      ...init,
      // Headers need special handling - merge instead of replace
      headers: (init == null ? void 0 : init.headers) ? { ...normalizeHeaders(baseInit.headers), ...normalizeHeaders(init.headers) } : baseInit.headers
    };
    return baseFetch(url4, mergedInit);
  };
}

// node_modules/pkce-challenge/dist/index.browser.js
var crypto2;
crypto2 = globalThis.crypto;
async function getRandomValues(size) {
  return (await crypto2).getRandomValues(new Uint8Array(size));
}
async function random(size) {
  const mask = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._~";
  const evenDistCutoff = Math.pow(2, 8) - Math.pow(2, 8) % mask.length;
  let result = "";
  while (result.length < size) {
    const randomBytes = await getRandomValues(size - result.length);
    for (const randomByte of randomBytes) {
      if (randomByte < evenDistCutoff) {
        result += mask[randomByte % mask.length];
      }
    }
  }
  return result;
}
async function generateVerifier(length) {
  return await random(length);
}
async function generateChallenge(code_verifier) {
  const buffer = await (await crypto2).subtle.digest("SHA-256", new TextEncoder().encode(code_verifier));
  return btoa(String.fromCharCode(...new Uint8Array(buffer))).replace(/\//g, "_").replace(/\+/g, "-").replace(/=/g, "");
}
async function pkceChallenge(length) {
  if (!length)
    length = 43;
  if (length < 43 || length > 128) {
    throw `Expected a length between 43 and 128. Received ${length}.`;
  }
  const verifier = await generateVerifier(length);
  const challenge = await generateChallenge(verifier);
  return {
    code_verifier: verifier,
    code_challenge: challenge
  };
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth.js
var SafeUrlSchema = url().superRefine((val, ctx) => {
  if (!URL.canParse(val)) {
    ctx.addIssue({
      code: ZodIssueCode.custom,
      message: "URL must be parseable",
      fatal: true
    });
    return NEVER;
  }
}).refine((url4) => {
  const u2 = new URL(url4);
  return u2.protocol !== "javascript:" && u2.protocol !== "data:" && u2.protocol !== "vbscript:";
}, { message: "URL cannot use javascript:, data:, or vbscript: scheme" });
var OAuthProtectedResourceMetadataSchema = looseObject({
  resource: string().url(),
  authorization_servers: array(SafeUrlSchema).optional(),
  jwks_uri: string().url().optional(),
  scopes_supported: array(string()).optional(),
  bearer_methods_supported: array(string()).optional(),
  resource_signing_alg_values_supported: array(string()).optional(),
  resource_name: string().optional(),
  resource_documentation: string().optional(),
  resource_policy_uri: string().url().optional(),
  resource_tos_uri: string().url().optional(),
  tls_client_certificate_bound_access_tokens: boolean().optional(),
  authorization_details_types_supported: array(string()).optional(),
  dpop_signing_alg_values_supported: array(string()).optional(),
  dpop_bound_access_tokens_required: boolean().optional()
});
var OAuthMetadataSchema = looseObject({
  issuer: string(),
  authorization_endpoint: SafeUrlSchema,
  token_endpoint: SafeUrlSchema,
  registration_endpoint: SafeUrlSchema.optional(),
  scopes_supported: array(string()).optional(),
  response_types_supported: array(string()),
  response_modes_supported: array(string()).optional(),
  grant_types_supported: array(string()).optional(),
  token_endpoint_auth_methods_supported: array(string()).optional(),
  token_endpoint_auth_signing_alg_values_supported: array(string()).optional(),
  service_documentation: SafeUrlSchema.optional(),
  revocation_endpoint: SafeUrlSchema.optional(),
  revocation_endpoint_auth_methods_supported: array(string()).optional(),
  revocation_endpoint_auth_signing_alg_values_supported: array(string()).optional(),
  introspection_endpoint: string().optional(),
  introspection_endpoint_auth_methods_supported: array(string()).optional(),
  introspection_endpoint_auth_signing_alg_values_supported: array(string()).optional(),
  code_challenge_methods_supported: array(string()).optional(),
  client_id_metadata_document_supported: boolean().optional()
});
var OpenIdProviderMetadataSchema = looseObject({
  issuer: string(),
  authorization_endpoint: SafeUrlSchema,
  token_endpoint: SafeUrlSchema,
  userinfo_endpoint: SafeUrlSchema.optional(),
  jwks_uri: SafeUrlSchema,
  registration_endpoint: SafeUrlSchema.optional(),
  scopes_supported: array(string()).optional(),
  response_types_supported: array(string()),
  response_modes_supported: array(string()).optional(),
  grant_types_supported: array(string()).optional(),
  acr_values_supported: array(string()).optional(),
  subject_types_supported: array(string()),
  id_token_signing_alg_values_supported: array(string()),
  id_token_encryption_alg_values_supported: array(string()).optional(),
  id_token_encryption_enc_values_supported: array(string()).optional(),
  userinfo_signing_alg_values_supported: array(string()).optional(),
  userinfo_encryption_alg_values_supported: array(string()).optional(),
  userinfo_encryption_enc_values_supported: array(string()).optional(),
  request_object_signing_alg_values_supported: array(string()).optional(),
  request_object_encryption_alg_values_supported: array(string()).optional(),
  request_object_encryption_enc_values_supported: array(string()).optional(),
  token_endpoint_auth_methods_supported: array(string()).optional(),
  token_endpoint_auth_signing_alg_values_supported: array(string()).optional(),
  display_values_supported: array(string()).optional(),
  claim_types_supported: array(string()).optional(),
  claims_supported: array(string()).optional(),
  service_documentation: string().optional(),
  claims_locales_supported: array(string()).optional(),
  ui_locales_supported: array(string()).optional(),
  claims_parameter_supported: boolean().optional(),
  request_parameter_supported: boolean().optional(),
  request_uri_parameter_supported: boolean().optional(),
  require_request_uri_registration: boolean().optional(),
  op_policy_uri: SafeUrlSchema.optional(),
  op_tos_uri: SafeUrlSchema.optional(),
  client_id_metadata_document_supported: boolean().optional()
});
var OpenIdProviderDiscoveryMetadataSchema = object({
  ...OpenIdProviderMetadataSchema.shape,
  ...OAuthMetadataSchema.pick({
    code_challenge_methods_supported: true
  }).shape
});
var OAuthTokensSchema = object({
  access_token: string(),
  id_token: string().optional(),
  // Optional for OAuth 2.1, but necessary in OpenID Connect
  token_type: string(),
  expires_in: coerce_exports.number().optional(),
  scope: string().optional(),
  refresh_token: string().optional()
}).strip();
var OAuthErrorResponseSchema = object({
  error: string(),
  error_description: string().optional(),
  error_uri: string().optional()
});
var OptionalSafeUrlSchema = SafeUrlSchema.optional().or(literal("").transform(() => void 0));
var OAuthClientMetadataSchema = object({
  redirect_uris: array(SafeUrlSchema),
  token_endpoint_auth_method: string().optional(),
  grant_types: array(string()).optional(),
  response_types: array(string()).optional(),
  client_name: string().optional(),
  client_uri: SafeUrlSchema.optional(),
  logo_uri: OptionalSafeUrlSchema,
  scope: string().optional(),
  contacts: array(string()).optional(),
  tos_uri: OptionalSafeUrlSchema,
  policy_uri: string().optional(),
  jwks_uri: SafeUrlSchema.optional(),
  jwks: any().optional(),
  software_id: string().optional(),
  software_version: string().optional(),
  software_statement: string().optional()
}).strip();
var OAuthClientInformationSchema = object({
  client_id: string(),
  client_secret: string().optional(),
  client_id_issued_at: number().optional(),
  client_secret_expires_at: number().optional()
}).strip();
var OAuthClientInformationFullSchema = OAuthClientMetadataSchema.merge(OAuthClientInformationSchema);
var OAuthClientRegistrationErrorSchema = object({
  error: string(),
  error_description: string().optional()
}).strip();
var OAuthTokenRevocationRequestSchema = object({
  token: string(),
  token_type_hint: string().optional()
}).strip();

// node_modules/@modelcontextprotocol/sdk/dist/esm/shared/auth-utils.js
function resourceUrlFromServerUrl(url4) {
  const resourceURL = typeof url4 === "string" ? new URL(url4) : new URL(url4.href);
  resourceURL.hash = "";
  return resourceURL;
}
function checkResourceAllowed({ requestedResource, configuredResource }) {
  const requested = typeof requestedResource === "string" ? new URL(requestedResource) : new URL(requestedResource.href);
  const configured = typeof configuredResource === "string" ? new URL(configuredResource) : new URL(configuredResource.href);
  if (requested.origin !== configured.origin) {
    return false;
  }
  if (requested.pathname.length < configured.pathname.length) {
    return false;
  }
  const requestedPath = requested.pathname.endsWith("/") ? requested.pathname : requested.pathname + "/";
  const configuredPath = configured.pathname.endsWith("/") ? configured.pathname : configured.pathname + "/";
  return requestedPath.startsWith(configuredPath);
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/server/auth/errors.js
var OAuthError = class extends Error {
  constructor(message, errorUri) {
    super(message);
    this.errorUri = errorUri;
    this.name = this.constructor.name;
  }
  /**
   * Converts the error to a standard OAuth error response object
   */
  toResponseObject() {
    const response = {
      error: this.errorCode,
      error_description: this.message
    };
    if (this.errorUri) {
      response.error_uri = this.errorUri;
    }
    return response;
  }
  get errorCode() {
    return this.constructor.errorCode;
  }
};
var InvalidRequestError = class extends OAuthError {
};
InvalidRequestError.errorCode = "invalid_request";
var InvalidClientError = class extends OAuthError {
};
InvalidClientError.errorCode = "invalid_client";
var InvalidGrantError = class extends OAuthError {
};
InvalidGrantError.errorCode = "invalid_grant";
var UnauthorizedClientError = class extends OAuthError {
};
UnauthorizedClientError.errorCode = "unauthorized_client";
var UnsupportedGrantTypeError = class extends OAuthError {
};
UnsupportedGrantTypeError.errorCode = "unsupported_grant_type";
var InvalidScopeError = class extends OAuthError {
};
InvalidScopeError.errorCode = "invalid_scope";
var AccessDeniedError = class extends OAuthError {
};
AccessDeniedError.errorCode = "access_denied";
var ServerError = class extends OAuthError {
};
ServerError.errorCode = "server_error";
var TemporarilyUnavailableError = class extends OAuthError {
};
TemporarilyUnavailableError.errorCode = "temporarily_unavailable";
var UnsupportedResponseTypeError = class extends OAuthError {
};
UnsupportedResponseTypeError.errorCode = "unsupported_response_type";
var UnsupportedTokenTypeError = class extends OAuthError {
};
UnsupportedTokenTypeError.errorCode = "unsupported_token_type";
var InvalidTokenError = class extends OAuthError {
};
InvalidTokenError.errorCode = "invalid_token";
var MethodNotAllowedError = class extends OAuthError {
};
MethodNotAllowedError.errorCode = "method_not_allowed";
var TooManyRequestsError = class extends OAuthError {
};
TooManyRequestsError.errorCode = "too_many_requests";
var InvalidClientMetadataError = class extends OAuthError {
};
InvalidClientMetadataError.errorCode = "invalid_client_metadata";
var InsufficientScopeError = class extends OAuthError {
};
InsufficientScopeError.errorCode = "insufficient_scope";
var InvalidTargetError = class extends OAuthError {
};
InvalidTargetError.errorCode = "invalid_target";
var OAUTH_ERRORS = {
  [InvalidRequestError.errorCode]: InvalidRequestError,
  [InvalidClientError.errorCode]: InvalidClientError,
  [InvalidGrantError.errorCode]: InvalidGrantError,
  [UnauthorizedClientError.errorCode]: UnauthorizedClientError,
  [UnsupportedGrantTypeError.errorCode]: UnsupportedGrantTypeError,
  [InvalidScopeError.errorCode]: InvalidScopeError,
  [AccessDeniedError.errorCode]: AccessDeniedError,
  [ServerError.errorCode]: ServerError,
  [TemporarilyUnavailableError.errorCode]: TemporarilyUnavailableError,
  [UnsupportedResponseTypeError.errorCode]: UnsupportedResponseTypeError,
  [UnsupportedTokenTypeError.errorCode]: UnsupportedTokenTypeError,
  [InvalidTokenError.errorCode]: InvalidTokenError,
  [MethodNotAllowedError.errorCode]: MethodNotAllowedError,
  [TooManyRequestsError.errorCode]: TooManyRequestsError,
  [InvalidClientMetadataError.errorCode]: InvalidClientMetadataError,
  [InsufficientScopeError.errorCode]: InsufficientScopeError,
  [InvalidTargetError.errorCode]: InvalidTargetError
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/auth.js
var UnauthorizedError = class extends Error {
  constructor(message) {
    super(message ?? "Unauthorized");
  }
};
function isClientAuthMethod(method) {
  return ["client_secret_basic", "client_secret_post", "none"].includes(method);
}
var AUTHORIZATION_CODE_RESPONSE_TYPE = "code";
var AUTHORIZATION_CODE_CHALLENGE_METHOD = "S256";
function selectClientAuthMethod(clientInformation, supportedMethods) {
  const hasClientSecret = clientInformation.client_secret !== void 0;
  if (supportedMethods.length === 0) {
    return hasClientSecret ? "client_secret_post" : "none";
  }
  if ("token_endpoint_auth_method" in clientInformation && clientInformation.token_endpoint_auth_method && isClientAuthMethod(clientInformation.token_endpoint_auth_method) && supportedMethods.includes(clientInformation.token_endpoint_auth_method)) {
    return clientInformation.token_endpoint_auth_method;
  }
  if (hasClientSecret && supportedMethods.includes("client_secret_basic")) {
    return "client_secret_basic";
  }
  if (hasClientSecret && supportedMethods.includes("client_secret_post")) {
    return "client_secret_post";
  }
  if (supportedMethods.includes("none")) {
    return "none";
  }
  return hasClientSecret ? "client_secret_post" : "none";
}
function applyClientAuthentication(method, clientInformation, headers, params) {
  const { client_id, client_secret } = clientInformation;
  switch (method) {
    case "client_secret_basic":
      applyBasicAuth(client_id, client_secret, headers);
      return;
    case "client_secret_post":
      applyPostAuth(client_id, client_secret, params);
      return;
    case "none":
      applyPublicAuth(client_id, params);
      return;
    default:
      throw new Error(`Unsupported client authentication method: ${method}`);
  }
}
function applyBasicAuth(clientId, clientSecret, headers) {
  if (!clientSecret) {
    throw new Error("client_secret_basic authentication requires a client_secret");
  }
  const credentials = btoa(`${clientId}:${clientSecret}`);
  headers.set("Authorization", `Basic ${credentials}`);
}
function applyPostAuth(clientId, clientSecret, params) {
  params.set("client_id", clientId);
  if (clientSecret) {
    params.set("client_secret", clientSecret);
  }
}
function applyPublicAuth(clientId, params) {
  params.set("client_id", clientId);
}
async function parseErrorResponse(input) {
  const statusCode = input instanceof Response ? input.status : void 0;
  const body = input instanceof Response ? await input.text() : input;
  try {
    const result = OAuthErrorResponseSchema.parse(JSON.parse(body));
    const { error, error_description, error_uri } = result;
    const errorClass = OAUTH_ERRORS[error] || ServerError;
    return new errorClass(error_description || "", error_uri);
  } catch (error) {
    const errorMessage = `${statusCode ? `HTTP ${statusCode}: ` : ""}Invalid OAuth error response: ${error}. Raw body: ${body}`;
    return new ServerError(errorMessage);
  }
}
async function auth(provider, options) {
  var _a13, _b;
  try {
    return await authInternal(provider, options);
  } catch (error) {
    if (error instanceof InvalidClientError || error instanceof UnauthorizedClientError) {
      await ((_a13 = provider.invalidateCredentials) == null ? void 0 : _a13.call(provider, "all"));
      return await authInternal(provider, options);
    } else if (error instanceof InvalidGrantError) {
      await ((_b = provider.invalidateCredentials) == null ? void 0 : _b.call(provider, "tokens"));
      return await authInternal(provider, options);
    }
    throw error;
  }
}
async function authInternal(provider, { serverUrl, authorizationCode, scope, resourceMetadataUrl, fetchFn }) {
  var _a13, _b;
  let resourceMetadata;
  let authorizationServerUrl;
  try {
    resourceMetadata = await discoverOAuthProtectedResourceMetadata(serverUrl, { resourceMetadataUrl }, fetchFn);
    if (resourceMetadata.authorization_servers && resourceMetadata.authorization_servers.length > 0) {
      authorizationServerUrl = resourceMetadata.authorization_servers[0];
    }
  } catch {
  }
  if (!authorizationServerUrl) {
    authorizationServerUrl = new URL("/", serverUrl);
  }
  const resource = await selectResourceURL(serverUrl, provider, resourceMetadata);
  const metadata = await discoverAuthorizationServerMetadata(authorizationServerUrl, {
    fetchFn
  });
  let clientInformation = await Promise.resolve(provider.clientInformation());
  if (!clientInformation) {
    if (authorizationCode !== void 0) {
      throw new Error("Existing OAuth client information is required when exchanging an authorization code");
    }
    const supportsUrlBasedClientId = (metadata == null ? void 0 : metadata.client_id_metadata_document_supported) === true;
    const clientMetadataUrl = provider.clientMetadataUrl;
    if (clientMetadataUrl && !isHttpsUrl(clientMetadataUrl)) {
      throw new InvalidClientMetadataError(`clientMetadataUrl must be a valid HTTPS URL with a non-root pathname, got: ${clientMetadataUrl}`);
    }
    const shouldUseUrlBasedClientId = supportsUrlBasedClientId && clientMetadataUrl;
    if (shouldUseUrlBasedClientId) {
      clientInformation = {
        client_id: clientMetadataUrl
      };
      await ((_a13 = provider.saveClientInformation) == null ? void 0 : _a13.call(provider, clientInformation));
    } else {
      if (!provider.saveClientInformation) {
        throw new Error("OAuth client information must be saveable for dynamic registration");
      }
      const fullInformation = await registerClient(authorizationServerUrl, {
        metadata,
        clientMetadata: provider.clientMetadata,
        fetchFn
      });
      await provider.saveClientInformation(fullInformation);
      clientInformation = fullInformation;
    }
  }
  const nonInteractiveFlow = !provider.redirectUrl;
  if (authorizationCode !== void 0 || nonInteractiveFlow) {
    const tokens2 = await fetchToken(provider, authorizationServerUrl, {
      metadata,
      resource,
      authorizationCode,
      fetchFn
    });
    await provider.saveTokens(tokens2);
    return "AUTHORIZED";
  }
  const tokens = await provider.tokens();
  if (tokens == null ? void 0 : tokens.refresh_token) {
    try {
      const newTokens = await refreshAuthorization(authorizationServerUrl, {
        metadata,
        clientInformation,
        refreshToken: tokens.refresh_token,
        resource,
        addClientAuthentication: provider.addClientAuthentication,
        fetchFn
      });
      await provider.saveTokens(newTokens);
      return "AUTHORIZED";
    } catch (error) {
      if (!(error instanceof OAuthError) || error instanceof ServerError) {
      } else {
        throw error;
      }
    }
  }
  const state = provider.state ? await provider.state() : void 0;
  const { authorizationUrl, codeVerifier } = await startAuthorization(authorizationServerUrl, {
    metadata,
    clientInformation,
    state,
    redirectUrl: provider.redirectUrl,
    scope: scope || ((_b = resourceMetadata == null ? void 0 : resourceMetadata.scopes_supported) == null ? void 0 : _b.join(" ")) || provider.clientMetadata.scope,
    resource
  });
  await provider.saveCodeVerifier(codeVerifier);
  await provider.redirectToAuthorization(authorizationUrl);
  return "REDIRECT";
}
function isHttpsUrl(value) {
  if (!value)
    return false;
  try {
    const url4 = new URL(value);
    return url4.protocol === "https:" && url4.pathname !== "/";
  } catch {
    return false;
  }
}
async function selectResourceURL(serverUrl, provider, resourceMetadata) {
  const defaultResource = resourceUrlFromServerUrl(serverUrl);
  if (provider.validateResourceURL) {
    return await provider.validateResourceURL(defaultResource, resourceMetadata == null ? void 0 : resourceMetadata.resource);
  }
  if (!resourceMetadata) {
    return void 0;
  }
  if (!checkResourceAllowed({ requestedResource: defaultResource, configuredResource: resourceMetadata.resource })) {
    throw new Error(`Protected resource ${resourceMetadata.resource} does not match expected ${defaultResource} (or origin)`);
  }
  return new URL(resourceMetadata.resource);
}
function extractWWWAuthenticateParams(res) {
  const authenticateHeader = res.headers.get("WWW-Authenticate");
  if (!authenticateHeader) {
    return {};
  }
  const [type, scheme] = authenticateHeader.split(" ");
  if (type.toLowerCase() !== "bearer" || !scheme) {
    return {};
  }
  const resourceMetadataMatch = extractFieldFromWwwAuth(res, "resource_metadata") || void 0;
  let resourceMetadataUrl;
  if (resourceMetadataMatch) {
    try {
      resourceMetadataUrl = new URL(resourceMetadataMatch);
    } catch {
    }
  }
  const scope = extractFieldFromWwwAuth(res, "scope") || void 0;
  const error = extractFieldFromWwwAuth(res, "error") || void 0;
  return {
    resourceMetadataUrl,
    scope,
    error
  };
}
function extractFieldFromWwwAuth(response, fieldName) {
  const wwwAuthHeader = response.headers.get("WWW-Authenticate");
  if (!wwwAuthHeader) {
    return null;
  }
  const pattern = new RegExp(`${fieldName}=(?:"([^"]+)"|([^\\s,]+))`);
  const match = wwwAuthHeader.match(pattern);
  if (match) {
    return match[1] || match[2];
  }
  return null;
}
async function discoverOAuthProtectedResourceMetadata(serverUrl, opts, fetchFn = fetch) {
  var _a13, _b;
  const response = await discoverMetadataWithFallback(serverUrl, "oauth-protected-resource", fetchFn, {
    protocolVersion: opts == null ? void 0 : opts.protocolVersion,
    metadataUrl: opts == null ? void 0 : opts.resourceMetadataUrl
  });
  if (!response || response.status === 404) {
    await ((_a13 = response == null ? void 0 : response.body) == null ? void 0 : _a13.cancel());
    throw new Error(`Resource server does not implement OAuth 2.0 Protected Resource Metadata.`);
  }
  if (!response.ok) {
    await ((_b = response.body) == null ? void 0 : _b.cancel());
    throw new Error(`HTTP ${response.status} trying to load well-known OAuth protected resource metadata.`);
  }
  return OAuthProtectedResourceMetadataSchema.parse(await response.json());
}
async function fetchWithCorsRetry(url4, headers, fetchFn = fetch) {
  try {
    return await fetchFn(url4, { headers });
  } catch (error) {
    if (error instanceof TypeError) {
      if (headers) {
        return fetchWithCorsRetry(url4, void 0, fetchFn);
      } else {
        return void 0;
      }
    }
    throw error;
  }
}
function buildWellKnownPath(wellKnownPrefix, pathname = "", options = {}) {
  if (pathname.endsWith("/")) {
    pathname = pathname.slice(0, -1);
  }
  return options.prependPathname ? `${pathname}/.well-known/${wellKnownPrefix}` : `/.well-known/${wellKnownPrefix}${pathname}`;
}
async function tryMetadataDiscovery(url4, protocolVersion, fetchFn = fetch) {
  const headers = {
    "MCP-Protocol-Version": protocolVersion
  };
  return await fetchWithCorsRetry(url4, headers, fetchFn);
}
function shouldAttemptFallback(response, pathname) {
  return !response || response.status >= 400 && response.status < 500 && pathname !== "/";
}
async function discoverMetadataWithFallback(serverUrl, wellKnownType, fetchFn, opts) {
  const issuer = new URL(serverUrl);
  const protocolVersion = (opts == null ? void 0 : opts.protocolVersion) ?? LATEST_PROTOCOL_VERSION;
  let url4;
  if (opts == null ? void 0 : opts.metadataUrl) {
    url4 = new URL(opts.metadataUrl);
  } else {
    const wellKnownPath = buildWellKnownPath(wellKnownType, issuer.pathname);
    url4 = new URL(wellKnownPath, (opts == null ? void 0 : opts.metadataServerUrl) ?? issuer);
    url4.search = issuer.search;
  }
  let response = await tryMetadataDiscovery(url4, protocolVersion, fetchFn);
  if (!(opts == null ? void 0 : opts.metadataUrl) && shouldAttemptFallback(response, issuer.pathname)) {
    const rootUrl = new URL(`/.well-known/${wellKnownType}`, issuer);
    response = await tryMetadataDiscovery(rootUrl, protocolVersion, fetchFn);
  }
  return response;
}
function buildDiscoveryUrls(authorizationServerUrl) {
  const url4 = typeof authorizationServerUrl === "string" ? new URL(authorizationServerUrl) : authorizationServerUrl;
  const hasPath = url4.pathname !== "/";
  const urlsToTry = [];
  if (!hasPath) {
    urlsToTry.push({
      url: new URL("/.well-known/oauth-authorization-server", url4.origin),
      type: "oauth"
    });
    urlsToTry.push({
      url: new URL(`/.well-known/openid-configuration`, url4.origin),
      type: "oidc"
    });
    return urlsToTry;
  }
  let pathname = url4.pathname;
  if (pathname.endsWith("/")) {
    pathname = pathname.slice(0, -1);
  }
  urlsToTry.push({
    url: new URL(`/.well-known/oauth-authorization-server${pathname}`, url4.origin),
    type: "oauth"
  });
  urlsToTry.push({
    url: new URL(`/.well-known/openid-configuration${pathname}`, url4.origin),
    type: "oidc"
  });
  urlsToTry.push({
    url: new URL(`${pathname}/.well-known/openid-configuration`, url4.origin),
    type: "oidc"
  });
  return urlsToTry;
}
async function discoverAuthorizationServerMetadata(authorizationServerUrl, { fetchFn = fetch, protocolVersion = LATEST_PROTOCOL_VERSION } = {}) {
  var _a13;
  const headers = {
    "MCP-Protocol-Version": protocolVersion,
    Accept: "application/json"
  };
  const urlsToTry = buildDiscoveryUrls(authorizationServerUrl);
  for (const { url: endpointUrl, type } of urlsToTry) {
    const response = await fetchWithCorsRetry(endpointUrl, headers, fetchFn);
    if (!response) {
      continue;
    }
    if (!response.ok) {
      await ((_a13 = response.body) == null ? void 0 : _a13.cancel());
      if (response.status >= 400 && response.status < 500) {
        continue;
      }
      throw new Error(`HTTP ${response.status} trying to load ${type === "oauth" ? "OAuth" : "OpenID provider"} metadata from ${endpointUrl}`);
    }
    if (type === "oauth") {
      return OAuthMetadataSchema.parse(await response.json());
    } else {
      return OpenIdProviderDiscoveryMetadataSchema.parse(await response.json());
    }
  }
  return void 0;
}
async function startAuthorization(authorizationServerUrl, { metadata, clientInformation, redirectUrl, scope, state, resource }) {
  let authorizationUrl;
  if (metadata) {
    authorizationUrl = new URL(metadata.authorization_endpoint);
    if (!metadata.response_types_supported.includes(AUTHORIZATION_CODE_RESPONSE_TYPE)) {
      throw new Error(`Incompatible auth server: does not support response type ${AUTHORIZATION_CODE_RESPONSE_TYPE}`);
    }
    if (metadata.code_challenge_methods_supported && !metadata.code_challenge_methods_supported.includes(AUTHORIZATION_CODE_CHALLENGE_METHOD)) {
      throw new Error(`Incompatible auth server: does not support code challenge method ${AUTHORIZATION_CODE_CHALLENGE_METHOD}`);
    }
  } else {
    authorizationUrl = new URL("/authorize", authorizationServerUrl);
  }
  const challenge = await pkceChallenge();
  const codeVerifier = challenge.code_verifier;
  const codeChallenge = challenge.code_challenge;
  authorizationUrl.searchParams.set("response_type", AUTHORIZATION_CODE_RESPONSE_TYPE);
  authorizationUrl.searchParams.set("client_id", clientInformation.client_id);
  authorizationUrl.searchParams.set("code_challenge", codeChallenge);
  authorizationUrl.searchParams.set("code_challenge_method", AUTHORIZATION_CODE_CHALLENGE_METHOD);
  authorizationUrl.searchParams.set("redirect_uri", String(redirectUrl));
  if (state) {
    authorizationUrl.searchParams.set("state", state);
  }
  if (scope) {
    authorizationUrl.searchParams.set("scope", scope);
  }
  if (scope == null ? void 0 : scope.includes("offline_access")) {
    authorizationUrl.searchParams.append("prompt", "consent");
  }
  if (resource) {
    authorizationUrl.searchParams.set("resource", resource.href);
  }
  return { authorizationUrl, codeVerifier };
}
function prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, redirectUri) {
  return new URLSearchParams({
    grant_type: "authorization_code",
    code: authorizationCode,
    code_verifier: codeVerifier,
    redirect_uri: String(redirectUri)
  });
}
async function executeTokenRequest(authorizationServerUrl, { metadata, tokenRequestParams, clientInformation, addClientAuthentication, resource, fetchFn }) {
  const tokenUrl = (metadata == null ? void 0 : metadata.token_endpoint) ? new URL(metadata.token_endpoint) : new URL("/token", authorizationServerUrl);
  const headers = new Headers({
    "Content-Type": "application/x-www-form-urlencoded",
    Accept: "application/json"
  });
  if (resource) {
    tokenRequestParams.set("resource", resource.href);
  }
  if (addClientAuthentication) {
    await addClientAuthentication(headers, tokenRequestParams, tokenUrl, metadata);
  } else if (clientInformation) {
    const supportedMethods = (metadata == null ? void 0 : metadata.token_endpoint_auth_methods_supported) ?? [];
    const authMethod = selectClientAuthMethod(clientInformation, supportedMethods);
    applyClientAuthentication(authMethod, clientInformation, headers, tokenRequestParams);
  }
  const response = await (fetchFn ?? fetch)(tokenUrl, {
    method: "POST",
    headers,
    body: tokenRequestParams
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthTokensSchema.parse(await response.json());
}
async function refreshAuthorization(authorizationServerUrl, { metadata, clientInformation, refreshToken, resource, addClientAuthentication, fetchFn }) {
  const tokenRequestParams = new URLSearchParams({
    grant_type: "refresh_token",
    refresh_token: refreshToken
  });
  const tokens = await executeTokenRequest(authorizationServerUrl, {
    metadata,
    tokenRequestParams,
    clientInformation,
    addClientAuthentication,
    resource,
    fetchFn
  });
  return { refresh_token: refreshToken, ...tokens };
}
async function fetchToken(provider, authorizationServerUrl, { metadata, resource, authorizationCode, fetchFn } = {}) {
  const scope = provider.clientMetadata.scope;
  let tokenRequestParams;
  if (provider.prepareTokenRequest) {
    tokenRequestParams = await provider.prepareTokenRequest(scope);
  }
  if (!tokenRequestParams) {
    if (!authorizationCode) {
      throw new Error("Either provider.prepareTokenRequest() or authorizationCode is required");
    }
    if (!provider.redirectUrl) {
      throw new Error("redirectUrl is required for authorization_code flow");
    }
    const codeVerifier = await provider.codeVerifier();
    tokenRequestParams = prepareAuthorizationCodeRequest(authorizationCode, codeVerifier, provider.redirectUrl);
  }
  const clientInformation = await provider.clientInformation();
  return executeTokenRequest(authorizationServerUrl, {
    metadata,
    tokenRequestParams,
    clientInformation: clientInformation ?? void 0,
    addClientAuthentication: provider.addClientAuthentication,
    resource,
    fetchFn
  });
}
async function registerClient(authorizationServerUrl, { metadata, clientMetadata, fetchFn }) {
  let registrationUrl;
  if (metadata) {
    if (!metadata.registration_endpoint) {
      throw new Error("Incompatible auth server: does not support dynamic client registration");
    }
    registrationUrl = new URL(metadata.registration_endpoint);
  } else {
    registrationUrl = new URL("/register", authorizationServerUrl);
  }
  const response = await (fetchFn ?? fetch)(registrationUrl, {
    method: "POST",
    headers: {
      "Content-Type": "application/json"
    },
    body: JSON.stringify(clientMetadata)
  });
  if (!response.ok) {
    throw await parseErrorResponse(response);
  }
  return OAuthClientInformationFullSchema.parse(await response.json());
}

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/sse.js
var SseError = class extends Error {
  constructor(code, message, event) {
    super(`SSE error: ${message}`);
    this.code = code;
    this.event = event;
  }
};
var SSEClientTransport = class {
  constructor(url4, opts) {
    this._url = url4;
    this._resourceMetadataUrl = void 0;
    this._scope = void 0;
    this._eventSourceInit = opts == null ? void 0 : opts.eventSourceInit;
    this._requestInit = opts == null ? void 0 : opts.requestInit;
    this._authProvider = opts == null ? void 0 : opts.authProvider;
    this._fetch = opts == null ? void 0 : opts.fetch;
    this._fetchWithInit = createFetchWithInit(opts == null ? void 0 : opts.fetch, opts == null ? void 0 : opts.requestInit);
  }
  async _authThenStart() {
    var _a13;
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    let result;
    try {
      result = await auth(this._authProvider, {
        serverUrl: this._url,
        resourceMetadataUrl: this._resourceMetadataUrl,
        scope: this._scope,
        fetchFn: this._fetchWithInit
      });
    } catch (error) {
      (_a13 = this.onerror) == null ? void 0 : _a13.call(this, error);
      throw error;
    }
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError();
    }
    return await this._startOrAuth();
  }
  async _commonHeaders() {
    var _a13;
    const headers = {};
    if (this._authProvider) {
      const tokens = await this._authProvider.tokens();
      if (tokens) {
        headers["Authorization"] = `Bearer ${tokens.access_token}`;
      }
    }
    if (this._protocolVersion) {
      headers["mcp-protocol-version"] = this._protocolVersion;
    }
    const extraHeaders = normalizeHeaders((_a13 = this._requestInit) == null ? void 0 : _a13.headers);
    return new Headers({
      ...headers,
      ...extraHeaders
    });
  }
  _startOrAuth() {
    var _a13;
    const fetchImpl = ((_a13 = this == null ? void 0 : this._eventSourceInit) == null ? void 0 : _a13.fetch) ?? this._fetch ?? fetch;
    return new Promise((resolve, reject) => {
      this._eventSource = new EventSource(this._url.href, {
        ...this._eventSourceInit,
        fetch: async (url4, init) => {
          const headers = await this._commonHeaders();
          headers.set("Accept", "text/event-stream");
          const response = await fetchImpl(url4, {
            ...init,
            headers
          });
          if (response.status === 401 && response.headers.has("www-authenticate")) {
            const { resourceMetadataUrl, scope } = extractWWWAuthenticateParams(response);
            this._resourceMetadataUrl = resourceMetadataUrl;
            this._scope = scope;
          }
          return response;
        }
      });
      this._abortController = new AbortController();
      this._eventSource.onerror = (event) => {
        var _a14;
        if (event.code === 401 && this._authProvider) {
          this._authThenStart().then(resolve, reject);
          return;
        }
        const error = new SseError(event.code, event.message, event);
        reject(error);
        (_a14 = this.onerror) == null ? void 0 : _a14.call(this, error);
      };
      this._eventSource.onopen = () => {
      };
      this._eventSource.addEventListener("endpoint", (event) => {
        var _a14;
        const messageEvent = event;
        try {
          this._endpoint = new URL(messageEvent.data, this._url);
          if (this._endpoint.origin !== this._url.origin) {
            throw new Error(`Endpoint origin does not match connection origin: ${this._endpoint.origin}`);
          }
        } catch (error) {
          reject(error);
          (_a14 = this.onerror) == null ? void 0 : _a14.call(this, error);
          void this.close();
          return;
        }
        resolve();
      });
      this._eventSource.onmessage = (event) => {
        var _a14, _b;
        const messageEvent = event;
        let message;
        try {
          message = JSONRPCMessageSchema.parse(JSON.parse(messageEvent.data));
        } catch (error) {
          (_a14 = this.onerror) == null ? void 0 : _a14.call(this, error);
          return;
        }
        (_b = this.onmessage) == null ? void 0 : _b.call(this, message);
      };
    });
  }
  async start() {
    if (this._eventSource) {
      throw new Error("SSEClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    return await this._startOrAuth();
  }
  /**
   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
   */
  async finishAuth(authorizationCode) {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    const result = await auth(this._authProvider, {
      serverUrl: this._url,
      authorizationCode,
      resourceMetadataUrl: this._resourceMetadataUrl,
      scope: this._scope,
      fetchFn: this._fetchWithInit
    });
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError("Failed to authorize");
    }
  }
  async close() {
    var _a13, _b, _c;
    (_a13 = this._abortController) == null ? void 0 : _a13.abort();
    (_b = this._eventSource) == null ? void 0 : _b.close();
    (_c = this.onclose) == null ? void 0 : _c.call(this);
  }
  async send(message) {
    var _a13, _b, _c;
    if (!this._endpoint) {
      throw new Error("Not connected");
    }
    try {
      const headers = await this._commonHeaders();
      headers.set("content-type", "application/json");
      const init = {
        ...this._requestInit,
        method: "POST",
        headers,
        body: JSON.stringify(message),
        signal: (_a13 = this._abortController) == null ? void 0 : _a13.signal
      };
      const response = await (this._fetch ?? fetch)(this._endpoint, init);
      if (!response.ok) {
        const text = await response.text().catch(() => null);
        if (response.status === 401 && this._authProvider) {
          const { resourceMetadataUrl, scope } = extractWWWAuthenticateParams(response);
          this._resourceMetadataUrl = resourceMetadataUrl;
          this._scope = scope;
          const result = await auth(this._authProvider, {
            serverUrl: this._url,
            resourceMetadataUrl: this._resourceMetadataUrl,
            scope: this._scope,
            fetchFn: this._fetchWithInit
          });
          if (result !== "AUTHORIZED") {
            throw new UnauthorizedError();
          }
          return this.send(message);
        }
        throw new Error(`Error POSTing to endpoint (HTTP ${response.status}): ${text}`);
      }
      await ((_b = response.body) == null ? void 0 : _b.cancel());
    } catch (error) {
      (_c = this.onerror) == null ? void 0 : _c.call(this, error);
      throw error;
    }
  }
  setProtocolVersion(version) {
    this._protocolVersion = version;
  }
};

// node_modules/eventsource-parser/dist/stream.js
var EventSourceParserStream = class extends TransformStream {
  constructor({ onError, onRetry, onComment } = {}) {
    let parser;
    super({
      start(controller) {
        parser = createParser({
          onEvent: (event) => {
            controller.enqueue(event);
          },
          onError(error) {
            onError === "terminate" ? controller.error(error) : typeof onError == "function" && onError(error);
          },
          onRetry,
          onComment
        });
      },
      transform(chunk) {
        parser.feed(chunk);
      }
    });
  }
};

// node_modules/@modelcontextprotocol/sdk/dist/esm/client/streamableHttp.js
var DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS = {
  initialReconnectionDelay: 1e3,
  maxReconnectionDelay: 3e4,
  reconnectionDelayGrowFactor: 1.5,
  maxRetries: 2
};
var StreamableHTTPError = class extends Error {
  constructor(code, message) {
    super(`Streamable HTTP error: ${message}`);
    this.code = code;
  }
};
var StreamableHTTPClientTransport = class {
  constructor(url4, opts) {
    this._hasCompletedAuthFlow = false;
    this._url = url4;
    this._resourceMetadataUrl = void 0;
    this._scope = void 0;
    this._requestInit = opts == null ? void 0 : opts.requestInit;
    this._authProvider = opts == null ? void 0 : opts.authProvider;
    this._fetch = opts == null ? void 0 : opts.fetch;
    this._fetchWithInit = createFetchWithInit(opts == null ? void 0 : opts.fetch, opts == null ? void 0 : opts.requestInit);
    this._sessionId = opts == null ? void 0 : opts.sessionId;
    this._reconnectionOptions = (opts == null ? void 0 : opts.reconnectionOptions) ?? DEFAULT_STREAMABLE_HTTP_RECONNECTION_OPTIONS;
  }
  async _authThenStart() {
    var _a13;
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    let result;
    try {
      result = await auth(this._authProvider, {
        serverUrl: this._url,
        resourceMetadataUrl: this._resourceMetadataUrl,
        scope: this._scope,
        fetchFn: this._fetchWithInit
      });
    } catch (error) {
      (_a13 = this.onerror) == null ? void 0 : _a13.call(this, error);
      throw error;
    }
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError();
    }
    return await this._startOrAuthSse({ resumptionToken: void 0 });
  }
  async _commonHeaders() {
    var _a13;
    const headers = {};
    if (this._authProvider) {
      const tokens = await this._authProvider.tokens();
      if (tokens) {
        headers["Authorization"] = `Bearer ${tokens.access_token}`;
      }
    }
    if (this._sessionId) {
      headers["mcp-session-id"] = this._sessionId;
    }
    if (this._protocolVersion) {
      headers["mcp-protocol-version"] = this._protocolVersion;
    }
    const extraHeaders = normalizeHeaders((_a13 = this._requestInit) == null ? void 0 : _a13.headers);
    return new Headers({
      ...headers,
      ...extraHeaders
    });
  }
  async _startOrAuthSse(options) {
    var _a13, _b, _c;
    const { resumptionToken } = options;
    try {
      const headers = await this._commonHeaders();
      headers.set("Accept", "text/event-stream");
      if (resumptionToken) {
        headers.set("last-event-id", resumptionToken);
      }
      const response = await (this._fetch ?? fetch)(this._url, {
        method: "GET",
        headers,
        signal: (_a13 = this._abortController) == null ? void 0 : _a13.signal
      });
      if (!response.ok) {
        await ((_b = response.body) == null ? void 0 : _b.cancel());
        if (response.status === 401 && this._authProvider) {
          return await this._authThenStart();
        }
        if (response.status === 405) {
          return;
        }
        throw new StreamableHTTPError(response.status, `Failed to open SSE stream: ${response.statusText}`);
      }
      this._handleSseStream(response.body, options, true);
    } catch (error) {
      (_c = this.onerror) == null ? void 0 : _c.call(this, error);
      throw error;
    }
  }
  /**
   * Calculates the next reconnection delay using  backoff algorithm
   *
   * @param attempt Current reconnection attempt count for the specific stream
   * @returns Time to wait in milliseconds before next reconnection attempt
   */
  _getNextReconnectionDelay(attempt) {
    if (this._serverRetryMs !== void 0) {
      return this._serverRetryMs;
    }
    const initialDelay = this._reconnectionOptions.initialReconnectionDelay;
    const growFactor = this._reconnectionOptions.reconnectionDelayGrowFactor;
    const maxDelay = this._reconnectionOptions.maxReconnectionDelay;
    return Math.min(initialDelay * Math.pow(growFactor, attempt), maxDelay);
  }
  /**
   * Schedule a reconnection attempt using server-provided retry interval or backoff
   *
   * @param lastEventId The ID of the last received event for resumability
   * @param attemptCount Current reconnection attempt count for this specific stream
   */
  _scheduleReconnection(options, attemptCount = 0) {
    var _a13;
    const maxRetries = this._reconnectionOptions.maxRetries;
    if (attemptCount >= maxRetries) {
      (_a13 = this.onerror) == null ? void 0 : _a13.call(this, new Error(`Maximum reconnection attempts (${maxRetries}) exceeded.`));
      return;
    }
    const delay = this._getNextReconnectionDelay(attemptCount);
    this._reconnectionTimeout = setTimeout(() => {
      this._startOrAuthSse(options).catch((error) => {
        var _a14;
        (_a14 = this.onerror) == null ? void 0 : _a14.call(this, new Error(`Failed to reconnect SSE stream: ${error instanceof Error ? error.message : String(error)}`));
        this._scheduleReconnection(options, attemptCount + 1);
      });
    }, delay);
  }
  _handleSseStream(stream, options, isReconnectable) {
    if (!stream) {
      return;
    }
    const { onresumptiontoken, replayMessageId } = options;
    let lastEventId;
    let hasPrimingEvent = false;
    let receivedResponse = false;
    const processStream = async () => {
      var _a13, _b, _c, _d;
      try {
        const reader = stream.pipeThrough(new TextDecoderStream()).pipeThrough(new EventSourceParserStream({
          onRetry: (retryMs) => {
            this._serverRetryMs = retryMs;
          }
        })).getReader();
        while (true) {
          const { value: event, done } = await reader.read();
          if (done) {
            break;
          }
          if (event.id) {
            lastEventId = event.id;
            hasPrimingEvent = true;
            onresumptiontoken == null ? void 0 : onresumptiontoken(event.id);
          }
          if (!event.data) {
            continue;
          }
          if (!event.event || event.event === "message") {
            try {
              const message = JSONRPCMessageSchema.parse(JSON.parse(event.data));
              if (isJSONRPCResultResponse(message)) {
                receivedResponse = true;
                if (replayMessageId !== void 0) {
                  message.id = replayMessageId;
                }
              }
              (_a13 = this.onmessage) == null ? void 0 : _a13.call(this, message);
            } catch (error) {
              (_b = this.onerror) == null ? void 0 : _b.call(this, error);
            }
          }
        }
        const canResume = isReconnectable || hasPrimingEvent;
        const needsReconnect = canResume && !receivedResponse;
        if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {
          this._scheduleReconnection({
            resumptionToken: lastEventId,
            onresumptiontoken,
            replayMessageId
          }, 0);
        }
      } catch (error) {
        (_c = this.onerror) == null ? void 0 : _c.call(this, new Error(`SSE stream disconnected: ${error}`));
        const canResume = isReconnectable || hasPrimingEvent;
        const needsReconnect = canResume && !receivedResponse;
        if (needsReconnect && this._abortController && !this._abortController.signal.aborted) {
          try {
            this._scheduleReconnection({
              resumptionToken: lastEventId,
              onresumptiontoken,
              replayMessageId
            }, 0);
          } catch (error2) {
            (_d = this.onerror) == null ? void 0 : _d.call(this, new Error(`Failed to reconnect: ${error2 instanceof Error ? error2.message : String(error2)}`));
          }
        }
      }
    };
    processStream();
  }
  async start() {
    if (this._abortController) {
      throw new Error("StreamableHTTPClientTransport already started! If using Client class, note that connect() calls start() automatically.");
    }
    this._abortController = new AbortController();
  }
  /**
   * Call this method after the user has finished authorizing via their user agent and is redirected back to the MCP client application. This will exchange the authorization code for an access token, enabling the next connection attempt to successfully auth.
   */
  async finishAuth(authorizationCode) {
    if (!this._authProvider) {
      throw new UnauthorizedError("No auth provider");
    }
    const result = await auth(this._authProvider, {
      serverUrl: this._url,
      authorizationCode,
      resourceMetadataUrl: this._resourceMetadataUrl,
      scope: this._scope,
      fetchFn: this._fetchWithInit
    });
    if (result !== "AUTHORIZED") {
      throw new UnauthorizedError("Failed to authorize");
    }
  }
  async close() {
    var _a13, _b;
    if (this._reconnectionTimeout) {
      clearTimeout(this._reconnectionTimeout);
      this._reconnectionTimeout = void 0;
    }
    (_a13 = this._abortController) == null ? void 0 : _a13.abort();
    (_b = this.onclose) == null ? void 0 : _b.call(this);
  }
  async send(message, options) {
    var _a13, _b, _c, _d, _e, _f;
    try {
      const { resumptionToken, onresumptiontoken } = options || {};
      if (resumptionToken) {
        this._startOrAuthSse({ resumptionToken, replayMessageId: isJSONRPCRequest(message) ? message.id : void 0 }).catch((err) => {
          var _a14;
          return (_a14 = this.onerror) == null ? void 0 : _a14.call(this, err);
        });
        return;
      }
      const headers = await this._commonHeaders();
      headers.set("content-type", "application/json");
      headers.set("accept", "application/json, text/event-stream");
      const init = {
        ...this._requestInit,
        method: "POST",
        headers,
        body: JSON.stringify(message),
        signal: (_a13 = this._abortController) == null ? void 0 : _a13.signal
      };
      const response = await (this._fetch ?? fetch)(this._url, init);
      const sessionId = response.headers.get("mcp-session-id");
      if (sessionId) {
        this._sessionId = sessionId;
      }
      if (!response.ok) {
        const text = await response.text().catch(() => null);
        if (response.status === 401 && this._authProvider) {
          if (this._hasCompletedAuthFlow) {
            throw new StreamableHTTPError(401, "Server returned 401 after successful authentication");
          }
          const { resourceMetadataUrl, scope } = extractWWWAuthenticateParams(response);
          this._resourceMetadataUrl = resourceMetadataUrl;
          this._scope = scope;
          const result = await auth(this._authProvider, {
            serverUrl: this._url,
            resourceMetadataUrl: this._resourceMetadataUrl,
            scope: this._scope,
            fetchFn: this._fetchWithInit
          });
          if (result !== "AUTHORIZED") {
            throw new UnauthorizedError();
          }
          this._hasCompletedAuthFlow = true;
          return this.send(message);
        }
        if (response.status === 403 && this._authProvider) {
          const { resourceMetadataUrl, scope, error } = extractWWWAuthenticateParams(response);
          if (error === "insufficient_scope") {
            const wwwAuthHeader = response.headers.get("WWW-Authenticate");
            if (this._lastUpscopingHeader === wwwAuthHeader) {
              throw new StreamableHTTPError(403, "Server returned 403 after trying upscoping");
            }
            if (scope) {
              this._scope = scope;
            }
            if (resourceMetadataUrl) {
              this._resourceMetadataUrl = resourceMetadataUrl;
            }
            this._lastUpscopingHeader = wwwAuthHeader ?? void 0;
            const result = await auth(this._authProvider, {
              serverUrl: this._url,
              resourceMetadataUrl: this._resourceMetadataUrl,
              scope: this._scope,
              fetchFn: this._fetch
            });
            if (result !== "AUTHORIZED") {
              throw new UnauthorizedError();
            }
            return this.send(message);
          }
        }
        throw new StreamableHTTPError(response.status, `Error POSTing to endpoint: ${text}`);
      }
      this._hasCompletedAuthFlow = false;
      this._lastUpscopingHeader = void 0;
      if (response.status === 202) {
        await ((_b = response.body) == null ? void 0 : _b.cancel());
        if (isInitializedNotification(message)) {
          this._startOrAuthSse({ resumptionToken: void 0 }).catch((err) => {
            var _a14;
            return (_a14 = this.onerror) == null ? void 0 : _a14.call(this, err);
          });
        }
        return;
      }
      const messages = Array.isArray(message) ? message : [message];
      const hasRequests = messages.filter((msg) => "method" in msg && "id" in msg && msg.id !== void 0).length > 0;
      const contentType = response.headers.get("content-type");
      if (hasRequests) {
        if (contentType == null ? void 0 : contentType.includes("text/event-stream")) {
          this._handleSseStream(response.body, { onresumptiontoken }, false);
        } else if (contentType == null ? void 0 : contentType.includes("application/json")) {
          const data = await response.json();
          const responseMessages = Array.isArray(data) ? data.map((msg) => JSONRPCMessageSchema.parse(msg)) : [JSONRPCMessageSchema.parse(data)];
          for (const msg of responseMessages) {
            (_c = this.onmessage) == null ? void 0 : _c.call(this, msg);
          }
        } else {
          await ((_d = response.body) == null ? void 0 : _d.cancel());
          throw new StreamableHTTPError(-1, `Unexpected content type: ${contentType}`);
        }
      } else {
        await ((_e = response.body) == null ? void 0 : _e.cancel());
      }
    } catch (error) {
      (_f = this.onerror) == null ? void 0 : _f.call(this, error);
      throw error;
    }
  }
  get sessionId() {
    return this._sessionId;
  }
  /**
   * Terminates the current session by sending a DELETE request to the server.
   *
   * Clients that no longer need a particular session
   * (e.g., because the user is leaving the client application) SHOULD send an
   * HTTP DELETE to the MCP endpoint with the Mcp-Session-Id header to explicitly
   * terminate the session.
   *
   * The server MAY respond with HTTP 405 Method Not Allowed, indicating that
   * the server does not allow clients to terminate sessions.
   */
  async terminateSession() {
    var _a13, _b, _c;
    if (!this._sessionId) {
      return;
    }
    try {
      const headers = await this._commonHeaders();
      const init = {
        ...this._requestInit,
        method: "DELETE",
        headers,
        signal: (_a13 = this._abortController) == null ? void 0 : _a13.signal
      };
      const response = await (this._fetch ?? fetch)(this._url, init);
      await ((_b = response.body) == null ? void 0 : _b.cancel());
      if (!response.ok && response.status !== 405) {
        throw new StreamableHTTPError(response.status, `Failed to terminate session: ${response.statusText}`);
      }
      this._sessionId = void 0;
    } catch (error) {
      (_c = this.onerror) == null ? void 0 : _c.call(this, error);
      throw error;
    }
  }
  setProtocolVersion(version) {
    this._protocolVersion = version;
  }
  get protocolVersion() {
    return this._protocolVersion;
  }
  /**
   * Resume an SSE stream from a previous event ID.
   * Opens a GET SSE connection with Last-Event-ID header to replay missed events.
   *
   * @param lastEventId The event ID to resume from
   * @param options Optional callback to receive new resumption tokens
   */
  async resumeStream(lastEventId, options) {
    await this._startOrAuthSse({
      resumptionToken: lastEventId,
      onresumptiontoken: options == null ? void 0 : options.onresumptiontoken
    });
  }
};

// node_modules/@tambo-ai/react/esm/mcp/mcp-client.js
var MCPClient = class _MCPClient {
  /**
   * Private constructor to enforce using the static create method.
   * @param endpoint - The URL of the MCP server to connect to
   * @param transportType - The transport to use for the MCP client
   * @param headers - Optional custom headers to include in requests
   */
  constructor(endpoint, transportType, headers, authProvider, sessionId, handlers = {}) {
    /**
     * The underlying MCP client
     *
     * Be careful not to mutate the client directly, use the methods provided instead.
     */
    __publicField(this, "client");
    __publicField(this, "transport");
    __publicField(this, "transportType");
    __publicField(this, "sessionId");
    __publicField(this, "endpoint");
    __publicField(this, "headers");
    __publicField(this, "authProvider");
    __publicField(this, "handlers");
    this.endpoint = endpoint;
    this.headers = headers ?? {};
    this.authProvider = authProvider;
    this.transportType = transportType;
    this.handlers = handlers;
    this.transport = this.initializeTransport(sessionId);
    this.client = this.initializeClient();
  }
  /**
   * Creates and initializes a new MCPClient instance. This is the recommended
   * way to create an MCPClient as it handles both instantiation and connection
   * setup.
   * @param endpoint - The URL of the MCP server to connect to
   * @param transportType - The transport type to use for the MCP client. Defaults to HTTP.
   * @param headers - Optional custom headers to include in requests
   * @param authProvider - Optional auth provider to use for authentication
   * @param sessionId - Optional session id to use for the MCP client - if not
   *   provided, a new session will be created
   * @returns A connected MCPClient instance ready for use
   * @throws {Error} Will throw an error if connection fails
   */
  static async create(endpoint, transportType = MCPTransport.HTTP, headers, authProvider, sessionId, handlers = {}) {
    const mcpClient = new _MCPClient(endpoint, transportType, headers, authProvider, sessionId, handlers);
    await mcpClient.client.connect(mcpClient.transport);
    if ("sessionId" in mcpClient.transport) {
      mcpClient.sessionId = mcpClient.transport.sessionId;
    }
    return mcpClient;
  }
  initializeTransport(sessionId) {
    if (this.transportType === MCPTransport.SSE) {
      return new SSEClientTransport(new URL(this.endpoint), {
        authProvider: this.authProvider,
        requestInit: { headers: this.headers }
      });
    } else {
      return new StreamableHTTPClientTransport(new URL(this.endpoint), {
        authProvider: this.authProvider,
        requestInit: { headers: this.headers },
        sessionId
      });
    }
  }
  /**
   * Initializes the MCP client with the appropriate capabilities and handlers
   * @returns The initialized MCP client
   */
  initializeClient() {
    const elicitationCapability = this.handlers.elicitation ? { elicitation: {} } : {};
    const samplingCapability = this.handlers.sampling ? { sampling: {} } : {};
    const client = new Client({
      name: "tambo-mcp-client",
      version: "1.0.0"
    }, {
      capabilities: {
        ...elicitationCapability,
        ...samplingCapability
      }
    });
    if (this.handlers.elicitation) {
      client.setRequestHandler(ElicitRequestSchema, this.handlers.elicitation);
    }
    if (this.handlers.sampling) {
      client.setRequestHandler(CreateMessageRequestSchema, this.handlers.sampling);
    }
    return client;
  }
  /**
   * Retrieves a complete list of all available tools from the MCP server.
   * Handles pagination automatically by following cursors until all tools are fetched.
   * @returns A complete list of all available tools and their descriptions
   * @throws {Error} Will throw an error if any server request fails during pagination
   */
  async listTools() {
    const allTools = [];
    let hasMore = true;
    let cursor = void 0;
    while (hasMore) {
      const response = await this.client.listTools({ cursor }, {});
      allTools.push(...response.tools.map((tool) => {
        const inputSchemaType = tool.inputSchema.type;
        if (inputSchemaType !== "object") {
          throw new Error(`Input schema for tool ${tool.name} is not an object`);
        }
        return {
          name: tool.name,
          description: tool.description,
          inputSchema: tool.inputSchema
        };
      }));
      if (response.nextCursor) {
        cursor = response.nextCursor;
      } else {
        hasMore = false;
      }
    }
    return allTools;
  }
  getServerCapabilities() {
    return this.client.getServerCapabilities();
  }
  getServerVersion() {
    return this.client.getServerVersion();
  }
  getInstructions() {
    return this.client.getInstructions();
  }
  /**
   * Calls a specific tool on the MCP server with the provided arguments.
   * @param name - The name of the tool to call
   * @param args - Arguments to pass to the tool, must match the tool's expected schema
   * @returns The result from the tool execution
   * @throws {Error} Will throw an error if the tool call fails or if arguments are invalid
   */
  async callTool(name, args, _meta) {
    const result = await this.client.callTool({
      name,
      arguments: args,
      _meta
    });
    return result;
  }
  updateElicitationHandler(handler2) {
    if (handler2 === this.handlers.elicitation) {
      return;
    }
    if (handler2 && !this.handlers.elicitation) {
      throw new Error("Elicitation handler must be set on create");
    }
    this.handlers = {
      ...this.handlers,
      elicitation: handler2
    };
    if (!handler2) {
      const method = ElicitRequestSchema.shape.method.value;
      this.client.removeRequestHandler(method);
      return;
    }
    this.client.setRequestHandler(ElicitRequestSchema, handler2);
  }
  updateSamplingHandler(handler2) {
    if (handler2 === this.handlers.sampling) {
      return;
    }
    if (handler2 && !this.handlers.sampling) {
      throw new Error("Sampling handler must be set on create");
    }
    this.handlers = {
      ...this.handlers,
      sampling: handler2
    };
    if (!handler2) {
      const method = CreateMessageRequestSchema.shape.method.value;
      this.client.removeRequestHandler(method);
      return;
    }
    this.client.setRequestHandler(CreateMessageRequestSchema, handler2);
  }
  async close() {
    await this.transport.close();
    await this.client.close();
  }
};

// node_modules/@tambo-ai/react/esm/mcp/tambo-mcp-provider.js
function extractErrorMessage(content) {
  if (content === void 0 || content === null) {
    return "Unknown error occurred";
  }
  if (Array.isArray(content)) {
    const textItems = content.filter((item) => (item == null ? void 0 : item.type) === "text" && typeof item.text === "string").map((item) => item.text);
    return textItems.length > 0 ? textItems.join(" ") : "Error occurred but no details provided";
  }
  if (typeof content === "object") {
    return JSON.stringify(content);
  }
  return `${content}`;
}
var McpProviderContext = (0, import_react16.createContext)({
  servers: [],
  elicitation: null,
  resolveElicitation: null
});
var TAMBO_INTERNAL_MCP_SERVER_NAME = "__tambo_internal_mcp_server__";
function hashString(input) {
  let hash = 0;
  for (let i = 0; i < input.length; i++) {
    hash = Math.imul(31, hash) + input.charCodeAt(i) | 0;
  }
  return (hash >>> 0).toString(36);
}
function closeClientSafely(server) {
  var _a13;
  if (!((_a13 = server == null ? void 0 : server.client) == null ? void 0 : _a13.close))
    return;
  try {
    const closeResult = server.client.close();
    if (closeResult && typeof closeResult.catch === "function") {
      void closeResult.catch((error) => {
        const url4 = server.url ?? "(unknown url)";
        console.error(`Error closing MCP client for ${url4}:`, error);
      });
    }
  } catch (error) {
    const url4 = server.url ?? "(unknown url)";
    console.error(`Error closing MCP client for ${url4}:`, error);
  }
}
function buildEffectiveHandlers(serverInfo, providerElicitationHandler, providerSamplingHandler) {
  var _a13, _b;
  const effectiveHandlers = {};
  if ((_a13 = serverInfo.handlers) == null ? void 0 : _a13.elicitation) {
    effectiveHandlers.elicitation = serverInfo.handlers.elicitation;
  } else if (providerElicitationHandler) {
    effectiveHandlers.elicitation = async (request, extra) => await providerElicitationHandler(request, extra, serverInfo);
  }
  if ((_b = serverInfo.handlers) == null ? void 0 : _b.sampling) {
    effectiveHandlers.sampling = serverInfo.handlers.sampling;
  } else if (providerSamplingHandler) {
    effectiveHandlers.sampling = async (request, extra) => await providerSamplingHandler(request, extra, serverInfo);
  }
  return effectiveHandlers;
}
function useServerConfigs(mcpServers, mcpAccessToken, tamboBaseUrl) {
  return (0, import_react16.useMemo)(() => {
    const serverMap = /* @__PURE__ */ new Map();
    mcpServers.forEach((server) => {
      const serverInfo = normalizeServerInfo2(server, ServerType.BROWSER_SIDE);
      serverMap.set(serverInfo.key, serverInfo);
    });
    if (mcpAccessToken && tamboBaseUrl) {
      const base = new URL(tamboBaseUrl);
      base.pathname = `${base.pathname.replace(/\/+$/, "")}/mcp`;
      const tamboMcpUrl = base.toString();
      const tokenHash = hashString(mcpAccessToken);
      const internalServer = {
        name: TAMBO_INTERNAL_MCP_SERVER_NAME,
        url: tamboMcpUrl,
        transport: MCPTransport.HTTP,
        serverKey: `tambo-${tokenHash}`,
        customHeaders: {
          Authorization: `Bearer ${mcpAccessToken}`
        }
      };
      const serverInfo = normalizeServerInfo2(internalServer, ServerType.TAMBO_INTERNAL);
      serverMap.set(serverInfo.key, serverInfo);
    }
    return serverMap;
  }, [mcpServers, mcpAccessToken, tamboBaseUrl]);
}
async function registerServerTools(client, serverInfo, key, shouldPrefix, clientMap, ownershipRefs, registerTool) {
  const { toolOwnerRef, keyToToolsRef } = ownershipRefs;
  try {
    const tools = await client.listTools();
    tools.forEach((tool) => {
      const toolName = shouldPrefix ? `${serverInfo.serverKey}__${tool.name}` : tool.name;
      const currentOwner = toolOwnerRef.current.get(toolName);
      if (currentOwner && currentOwner !== key) {
        return;
      }
      if (!currentOwner) {
        toolOwnerRef.current.set(toolName, key);
        if (!keyToToolsRef.current.has(key)) {
          keyToToolsRef.current.set(key, /* @__PURE__ */ new Set());
        }
        keyToToolsRef.current.get(key).add(toolName);
      }
      registerTool({
        description: tool.description ?? "",
        name: toolName,
        tool: async (args = {}) => {
          const server = clientMap.get(key);
          if (!(server == null ? void 0 : server.client)) {
            throw new Error(`MCP server for tool ${tool.name} is not connected`);
          }
          const result = await server.client.callTool(tool.name, args);
          if (result.isError) {
            const errorMessage = extractErrorMessage(result.content);
            throw new Error(errorMessage);
          }
          return result.content;
        },
        inputSchema: tool.inputSchema ?? {},
        outputSchema: {},
        transformToContent: (content) => {
          if (isContentPartArray(content)) {
            return content;
          }
          return [{ type: "text", text: toText(content) }];
        },
        ..."maxCalls" in tool && tool.maxCalls !== void 0 ? { maxCalls: tool.maxCalls } : {}
      });
    });
  } catch (error) {
    console.error(`Failed to register tools from MCP server ${serverInfo.url}:`, error);
  }
}
function releaseToolOwnership(key, ownershipRefs) {
  const { toolOwnerRef, keyToToolsRef } = ownershipRefs;
  const owned = keyToToolsRef.current.get(key);
  if (owned) {
    for (const name of owned) {
      toolOwnerRef.current.delete(name);
    }
    keyToToolsRef.current.delete(key);
  }
}
var TamboMcpProvider = ({ handlers, contextKey, children }) => {
  const { registerTool } = useTamboRegistry();
  const { mcpAccessToken, tamboBaseUrl } = useTamboMcpToken(contextKey);
  const mcpServers = useTamboMcpServerInfos();
  const providerSamplingHandler = handlers == null ? void 0 : handlers.sampling;
  const { elicitation, resolveElicitation, defaultElicitationHandler } = useElicitation();
  const providerElicitationHandler = (handlers == null ? void 0 : handlers.elicitation) ?? defaultElicitationHandler;
  const clientMapRef = (0, import_react16.useRef)(/* @__PURE__ */ new Map());
  const toolOwnerRef = (0, import_react16.useRef)(/* @__PURE__ */ new Map());
  const keyToToolsRef = (0, import_react16.useRef)(/* @__PURE__ */ new Map());
  const ownershipRefs = { toolOwnerRef, keyToToolsRef };
  const [connectedMcpServers, setConnectedMcpServers] = (0, import_react16.useState)([]);
  const currentServersMap = useServerConfigs(mcpServers, mcpAccessToken, tamboBaseUrl);
  useClientLifecycle(currentServersMap, clientMapRef, ownershipRefs, providerElicitationHandler, providerSamplingHandler, registerTool, setConnectedMcpServers);
  useHandlerUpdates(currentServersMap, clientMapRef, providerElicitationHandler, providerSamplingHandler);
  useCleanupOnUnmount(clientMapRef, ownershipRefs);
  const contextValue = (0, import_react16.useMemo)(() => ({
    servers: connectedMcpServers,
    elicitation,
    resolveElicitation
  }), [connectedMcpServers, elicitation, resolveElicitation]);
  return import_react16.default.createElement(McpProviderContext.Provider, { value: contextValue }, children);
};
function useClientLifecycle(currentServersMap, clientMapRef, ownershipRefs, providerElicitationHandler, providerSamplingHandler, registerTool, setConnectedMcpServers) {
  (0, import_react16.useEffect)(() => {
    const clientMap = clientMapRef.current;
    const currentKeys = new Set(currentServersMap.keys());
    const existingKeys = new Set(clientMap.keys());
    const keysToRemove = Array.from(existingKeys).filter((key) => !currentKeys.has(key));
    keysToRemove.forEach((key) => {
      const server = clientMap.get(key);
      if (server) {
        closeClientSafely(server);
      }
      releaseToolOwnership(key, ownershipRefs);
      clientMap.delete(key);
    });
    const keysToAdd = Array.from(currentKeys).filter((key) => !existingKeys.has(key));
    async function addClients(keys2) {
      await Promise.allSettled(keys2.map(async (key) => {
        const serverInfo = currentServersMap.get(key);
        try {
          const effectiveHandlers = buildEffectiveHandlers(serverInfo, providerElicitationHandler, providerSamplingHandler);
          const client = await MCPClient.create(serverInfo.url, serverInfo.transport, serverInfo.customHeaders, void 0, void 0, effectiveHandlers);
          const connectedServer = {
            ...serverInfo,
            client
          };
          clientMap.set(key, connectedServer);
          setConnectedMcpServers(Array.from(clientMap.values()));
          const shouldPrefix = currentServersMap.size > 1;
          await registerServerTools(client, serverInfo, key, shouldPrefix, clientMap, ownershipRefs, registerTool);
        } catch (error) {
          const failedServer = {
            ...serverInfo,
            connectionError: error
          };
          clientMap.set(key, failedServer);
          setConnectedMcpServers(Array.from(clientMap.values()));
          console.error(`Failed to connect to MCP server ${serverInfo.url}:`, error);
        }
      }));
    }
    if (keysToAdd.length > 0) {
      addClients(keysToAdd).catch((err) => {
        console.error("Unexpected error in addClients:", err);
      });
    }
    if (keysToRemove.length > 0) {
      setConnectedMcpServers(Array.from(clientMap.values()));
    }
  }, [
    currentServersMap,
    providerElicitationHandler,
    providerSamplingHandler,
    registerTool
  ]);
}
function useHandlerUpdates(currentServersMap, clientMapRef, providerElicitationHandler, providerSamplingHandler) {
  (0, import_react16.useEffect)(() => {
    const clientMap = clientMapRef.current;
    clientMap.forEach((server, key) => {
      var _a13, _b, _c, _d, _e, _f;
      if (!server.client) {
        return;
      }
      const serverInfo = currentServersMap.get(key);
      if (!serverInfo) {
        return;
      }
      const effectiveElicitationHandler = ((_a13 = serverInfo.handlers) == null ? void 0 : _a13.elicitation) ?? (providerElicitationHandler ? async (request, extra) => await providerElicitationHandler(request, extra, serverInfo) : void 0);
      const effectiveSamplingHandler = ((_b = serverInfo.handlers) == null ? void 0 : _b.sampling) ?? (providerSamplingHandler ? async (request, extra) => await providerSamplingHandler(request, extra, serverInfo) : void 0);
      (_d = (_c = server.client).updateElicitationHandler) == null ? void 0 : _d.call(_c, effectiveElicitationHandler);
      (_f = (_e = server.client).updateSamplingHandler) == null ? void 0 : _f.call(_e, effectiveSamplingHandler);
    });
  }, [currentServersMap, providerElicitationHandler, providerSamplingHandler]);
}
function useCleanupOnUnmount(clientMapRef, ownershipRefs) {
  (0, import_react16.useEffect)(() => {
    const clientMap = clientMapRef.current;
    const { toolOwnerRef, keyToToolsRef } = ownershipRefs;
    return () => {
      clientMap.forEach((server) => {
        closeClientSafely(server);
      });
      clientMap.clear();
      toolOwnerRef.current.clear();
      keyToToolsRef.current.clear();
    };
  }, []);
}
var useTamboMcpServers = () => {
  return (0, import_react16.useContext)(McpProviderContext).servers;
};
function normalizeServerInfo2(server, serverType) {
  const key = getMcpServerUniqueKey(server);
  const handlers = server.handlers;
  return {
    ...server,
    handlers,
    key,
    serverType
  };
}

// node_modules/@tambo-ai/react/esm/providers/tambo-context-attachment-provider.js
var import_react17 = __toESM(require_react());
var ContextAttachmentContext = (0, import_react17.createContext)(null);
var CONTEXT_ATTACHMENTS_HELPER_KEY = "contextAttachments";
function TamboContextAttachmentProvider({ children }) {
  const { addContextHelper, removeContextHelper } = useTamboContextHelpers();
  const [attachments, setAttachments] = (0, import_react17.useState)([]);
  (0, import_react17.useEffect)(() => {
    addContextHelper(CONTEXT_ATTACHMENTS_HELPER_KEY, () => {
      if (attachments.length === 0) {
        return null;
      }
      return attachments.map((attachment) => ({
        id: attachment.id,
        displayName: attachment.displayName,
        context: attachment.context,
        type: attachment.type
      }));
    });
    return () => {
      removeContextHelper(CONTEXT_ATTACHMENTS_HELPER_KEY);
    };
  }, [attachments, addContextHelper, removeContextHelper]);
  const addContextAttachment = (0, import_react17.useCallback)((contextAttachment) => {
    const id = crypto.randomUUID();
    const attachment = {
      id,
      displayName: contextAttachment.displayName,
      context: contextAttachment.context,
      type: contextAttachment.type
    };
    setAttachments((prev) => [...prev, attachment]);
    return attachment;
  }, []);
  const removeContextAttachment = (0, import_react17.useCallback)((id) => {
    setAttachments((prev) => prev.filter((c2) => c2.id !== id));
  }, []);
  const clearContextAttachments = (0, import_react17.useCallback)(() => {
    setAttachments([]);
  }, []);
  const value = (0, import_react17.useMemo)(() => ({
    attachments,
    addContextAttachment,
    removeContextAttachment,
    clearContextAttachments
  }), [
    attachments,
    addContextAttachment,
    removeContextAttachment,
    clearContextAttachments
  ]);
  return import_react17.default.createElement(ContextAttachmentContext.Provider, { value }, children);
}
function useTamboContextAttachment() {
  const context = (0, import_react17.useContext)(ContextAttachmentContext);
  if (!context) {
    throw new Error("useTamboContextAttachment must be used within a TamboContextAttachmentProvider");
  }
  return context;
}

// node_modules/@tambo-ai/react/esm/providers/tambo-thread-input-provider.js
var import_react18 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/hooks/react-query-hooks.js
function useTamboQuery(options) {
  const queryClient = useTamboQueryClient();
  return useQuery(options, queryClient);
}
function useTamboMutation(options) {
  const queryClient = useTamboQueryClient();
  return useMutation(options, queryClient);
}

// node_modules/@tambo-ai/react/esm/model/thread-input-error.js
var ThreadInputError = class extends TamboAIError {
};

// node_modules/@tambo-ai/react/esm/util/message-builder.js
var RESOURCE_REFERENCE_PATTERN = /@([a-zA-Z0-9-]+):(\S+)/g;
function parseResourceReferences(text, resourceNames, resourceContent) {
  var _a13;
  const parts = [];
  const matches = Array.from(text.matchAll(RESOURCE_REFERENCE_PATTERN));
  let lastIndex = 0;
  for (const match of matches) {
    const [fullMatch, serverKey, uri] = match;
    const fullId = `${serverKey}:${uri}`;
    if (match.index !== void 0 && match.index > lastIndex) {
      const textBefore = text.slice(lastIndex, match.index);
      if (textBefore.length > 0) {
        parts.push({
          type: "text",
          text: textBefore
        });
      }
    }
    const resource = { uri };
    const name = resourceNames[fullId];
    if (name) {
      resource.name = name;
    }
    const resolvedContent = resourceContent == null ? void 0 : resourceContent.get(fullId);
    if ((_a13 = resolvedContent == null ? void 0 : resolvedContent.contents) == null ? void 0 : _a13[0]) {
      const content = resolvedContent.contents[0];
      if ("text" in content && content.text) {
        resource.text = content.text;
      } else if ("blob" in content && content.blob) {
        resource.blob = content.blob;
      }
      if ("mimeType" in content && content.mimeType) {
        resource.mimeType = content.mimeType;
      }
    }
    parts.push({ type: "resource", resource });
    if (match.index !== void 0) {
      lastIndex = match.index + fullMatch.length;
    }
  }
  if (lastIndex < text.length) {
    const textAfter = text.slice(lastIndex);
    if (textAfter.length > 0) {
      parts.push({
        type: "text",
        text: textAfter
      });
    }
  }
  if (parts.length === 0 && text.trim()) {
    parts.push({ type: "text", text });
  }
  return parts;
}
function buildMessageContent(text, images, resourceNames = {}, resourceContent) {
  const content = [];
  const hasNonWhitespaceText = text.trim().length > 0;
  if (hasNonWhitespaceText) {
    const parts = parseResourceReferences(text, resourceNames, resourceContent);
    content.push(...parts);
  }
  for (const image of images) {
    content.push({
      type: "image_url",
      image_url: {
        url: image.dataUrl
      }
    });
  }
  if (content.length === 0) {
    throw new Error("Message must contain text or images");
  }
  return content;
}

// node_modules/@tambo-ai/react/esm/util/resource-content-resolver.js
function isConnectedMcpServer(server) {
  return "client" in server && server.client != null;
}
async function resolveResourceContents(resourceUris, mcpServers, resourceSource) {
  const results = /* @__PURE__ */ new Map();
  const fetchPromises = resourceUris.map(async (prefixedUri) => {
    const colonIndex = prefixedUri.indexOf(":");
    if (colonIndex === -1)
      return;
    const serverKey = prefixedUri.slice(0, colonIndex);
    const originalUri = prefixedUri.slice(colonIndex + 1);
    try {
      if (serverKey === REGISTRY_SERVER_KEY) {
        if (!resourceSource) {
          console.warn(`No resource source available to resolve registry resource: ${prefixedUri}`);
          return;
        }
        const registryContent = await resourceSource.getResource(originalUri);
        if (registryContent) {
          results.set(prefixedUri, registryContent);
        }
        return;
      }
      const server = mcpServers.find((s) => s.serverKey === serverKey);
      if (!server) {
        console.warn(`No server found for resource: ${prefixedUri}`);
        return;
      }
      switch (server.serverType) {
        case ServerType.TAMBO_INTERNAL:
          return;
        case ServerType.TAMBO_REGISTRY:
          return;
        case ServerType.BROWSER_SIDE: {
          if (!isConnectedMcpServer(server)) {
            console.warn(`MCP server not connected for resource: ${prefixedUri}`);
            return;
          }
          const mcpContent = await server.client.client.readResource({
            uri: originalUri
          });
          if (mcpContent) {
            results.set(prefixedUri, mcpContent);
          }
          return;
        }
      }
    } catch (error) {
      console.warn(`Failed to fetch resource content for ${prefixedUri}:`, error);
    }
  });
  await Promise.all(fetchPromises);
  return results;
}
function extractResourceUris(text) {
  const pattern = /@([a-zA-Z0-9-]+):(\S+)/g;
  const matches = Array.from(text.matchAll(pattern));
  return matches.map(([, serverKey, uri]) => `${serverKey}:${uri}`);
}

// node_modules/@tambo-ai/react/esm/providers/tambo-thread-input-provider.js
var INPUT_ERROR_MESSAGES = {
  EMPTY: "Message cannot be empty",
  NETWORK: "Network error. Please check your connection",
  SERVER: "Server error. Please try again",
  VALIDATION: "Invalid message format"
};
var TamboThreadInputContext = (0, import_react18.createContext)(void 0);
var TamboThreadInputProvider = ({ children }) => {
  const { thread, sendThreadMessage, contextKey } = useTamboThread();
  const [inputValue, setInputValue] = (0, import_react18.useState)("");
  const imageState = useMessageImages();
  const mcpServers = useTamboMcpServers();
  const { resourceSource } = useTamboRegistry();
  const { clearInteractableSelections } = useTamboInteractable();
  const submit = (0, import_react18.useCallback)(async ({ streamResponse, forceToolChoice, additionalContext, resourceNames = {} } = {}) => {
    if (inputValue == null ? void 0 : inputValue.trim()) {
      const validation = validateInput(inputValue);
      if (!validation.isValid) {
        throw new ThreadInputError(`Cannot submit message: ${validation.error ?? INPUT_ERROR_MESSAGES.VALIDATION}`, { cause: validation.error });
      }
    }
    if (!inputValue.trim() && imageState.images.length === 0) {
      throw new ThreadInputError(INPUT_ERROR_MESSAGES.EMPTY, {
        cause: "No text or images to send"
      });
    }
    const resourceUris = extractResourceUris(inputValue);
    const resolvedContent = await resolveResourceContents(resourceUris, mcpServers, resourceSource ?? void 0);
    const messageContent = buildMessageContent(inputValue, imageState.images, resourceNames, resolvedContent);
    try {
      await sendThreadMessage(inputValue || "Image message", {
        threadId: thread.id,
        contextKey,
        streamResponse,
        forceToolChoice,
        additionalContext,
        content: messageContent
      });
      clearInteractableSelections();
    } catch (error) {
      if (imageState.images.length > 0) {
        const errorMessage = error instanceof Error ? error.message.toLowerCase() : "";
        if (errorMessage.includes("unknown content part type: image")) {
          throw new ThreadInputError("Image attachments are not yet supported by the backend. This feature is coming soon.", { cause: error });
        }
        if (errorMessage.includes("does not support image message content types") || errorMessage.includes("invalid model") && errorMessage.includes("image_url is only supported by certain models")) {
          throw new ThreadInputError("This model doesn't support images. Please use GPT-4o, GPT-4 Turbo, or other vision-capable models.", { cause: error });
        }
        if (errorMessage.includes("does not support image") || errorMessage.includes("vision not supported")) {
          throw new ThreadInputError("This Claude model doesn't support images. Please use Claude 3.5 Sonnet, Claude 3 Opus, or other vision-capable models.", { cause: error });
        }
        if (errorMessage.includes("image") || errorMessage.includes("vision")) {
          throw new ThreadInputError("This model doesn't support image attachments. Please use a vision-capable model.", { cause: error });
        }
      }
      throw error;
    }
    setInputValue("");
  }, [
    inputValue,
    sendThreadMessage,
    thread.id,
    contextKey,
    imageState,
    mcpServers,
    resourceSource,
    clearInteractableSelections
  ]);
  const { mutateAsync: submitAsync, mutate: _unusedSubmit, ...mutationState } = useTamboMutation({
    mutationFn: submit
  });
  const value = {
    ...mutationState,
    value: inputValue,
    setValue: setInputValue,
    submit: submitAsync,
    images: imageState.images,
    addImage: imageState.addImage,
    addImages: imageState.addImages,
    removeImage: imageState.removeImage,
    clearImages: imageState.clearImages
  };
  return import_react18.default.createElement(TamboThreadInputContext.Provider, { value }, children);
};
var useTamboThreadInput = () => {
  const context = (0, import_react18.useContext)(TamboThreadInputContext);
  if (!context) {
    throw new Error("useTamboThreadInput must be used within a TamboThreadInputProvider");
  }
  return context;
};

// node_modules/@tambo-ai/react/esm/providers/tambo-provider.js
var TamboProvider = ({ children, tamboUrl, apiKey, userToken, components, environment, tools, mcpServers, streaming, autoGenerateThreadName, autoGenerateNameThreshold, contextHelpers, contextKey, initialMessages, onCallUnregisteredTool, getResource, listResources, resources }) => {
  return import_react19.default.createElement(
    TamboClientProvider,
    { tamboUrl, apiKey, environment, userToken },
    import_react19.default.createElement(
      TamboRegistryProvider,
      { components, tools, mcpServers, onCallUnregisteredTool, getResource, listResources, resources },
      import_react19.default.createElement(
        TamboContextHelpersProvider,
        { contextHelpers },
        import_react19.default.createElement(
          TamboThreadProvider,
          { contextKey, streaming, autoGenerateThreadName, autoGenerateNameThreshold, initialMessages },
          import_react19.default.createElement(
            TamboMcpTokenProvider,
            null,
            import_react19.default.createElement(
              TamboMcpProvider,
              { contextKey },
              import_react19.default.createElement(
                TamboContextAttachmentProvider,
                null,
                import_react19.default.createElement(
                  TamboComponentProvider,
                  null,
                  import_react19.default.createElement(
                    TamboInteractableProvider,
                    null,
                    import_react19.default.createElement(
                      TamboThreadInputProvider,
                      null,
                      import_react19.default.createElement(TamboCompositeProvider, null, children)
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  );
};
var TamboContext = (0, import_react19.createContext)({});
var TamboCompositeProvider = ({ children }) => {
  const threads = useTamboThread();
  const clientContext = (0, import_react19.useContext)(TamboClientContext);
  if (!clientContext) {
    throw new Error("TamboCompositeProvider must be used within a TamboClientProvider");
  }
  const { client, queryClient, isUpdatingToken } = clientContext;
  const componentRegistry = useTamboComponent();
  const interactableComponents = useTamboInteractable();
  const contextHelpers = useTamboContextHelpers();
  const contextAttachment = useTamboContextAttachment();
  return import_react19.default.createElement(TamboContext.Provider, { value: {
    client,
    queryClient,
    isUpdatingToken,
    ...componentRegistry,
    ...threads,
    ...interactableComponents,
    ...contextHelpers,
    ...contextAttachment
  } }, children);
};
var useTambo = () => {
  return (0, import_react19.useContext)(TamboContext);
};

// node_modules/@tambo-ai/react/esm/util/query-utils.js
function combineMutationResults(resultA, resultB) {
  let status;
  if (resultA.isPending || resultB.isPending) {
    status = "pending";
  } else if (resultA.isError || resultB.isError) {
    status = "error";
  } else if (resultA.isSuccess && resultB.isSuccess) {
    status = "success";
  } else {
    status = "idle";
  }
  return {
    isPending: resultA.isPending || resultB.isPending,
    isSuccess: resultA.isSuccess && resultB.isSuccess,
    isError: resultA.isError || resultB.isError,
    isIdle: resultA.isIdle && resultB.isIdle,
    isPaused: resultA.isPaused || resultB.isPaused,
    submittedAt: resultA.submittedAt || resultB.submittedAt,
    status,
    error: resultA.error ?? resultB.error,
    failureCount: resultA.failureCount + resultB.failureCount,
    failureReason: resultA.failureReason ?? resultB.failureReason
  };
}

// node_modules/@tambo-ai/react/esm/hooks/use-suggestions.js
function useTamboSuggestions(options = {}) {
  const { maxSuggestions = 3 } = options;
  const { thread, generationStage } = useTamboThread();
  const { sendThreadMessage } = useTambo();
  const tamboClient = useTamboClient();
  const { componentList, toolRegistry, componentToolAssociations } = useTamboRegistry();
  const [selectedSuggestionId, setSelectedSuggestionId] = (0, import_react20.useState)(null);
  const { setValue: setInputValue } = useTamboThreadInput();
  const latestMessage = thread.messages[thread.messages.length - 1];
  const isLatestFromTambo = (latestMessage == null ? void 0 : latestMessage.role) === "assistant";
  const latestMessageId = latestMessage == null ? void 0 : latestMessage.id;
  (0, import_react20.useEffect)(() => {
    setSelectedSuggestionId(null);
  }, [latestMessageId]);
  const shouldGenerateSuggestions = latestMessageId && isLatestFromTambo && isIdleStage(generationStage);
  const suggestionsResult = useTamboQuery({
    // Make sure the query key changes when the message changes, so that we are
    // always generating suggestions when there is a new message
    queryKey: [
      "suggestions",
      shouldGenerateSuggestions ? latestMessageId : null
    ],
    queryFn: async () => {
      if (!shouldGenerateSuggestions) {
        return [];
      }
      const components = getAvailableComponents(componentList, toolRegistry, componentToolAssociations);
      return await tamboClient.beta.threads.suggestions.generate(latestMessageId, {
        id: thread.id,
        maxSuggestions,
        availableComponents: components
      });
    },
    // Only run the query if we have a valid message from hydra
    enabled: Boolean(latestMessageId && isLatestFromTambo),
    // Don't refetch on window focus or reconnect
    refetchOnWindowFocus: false,
    refetchOnReconnect: false,
    // Don't retry on failure
    retry: false
  });
  const acceptMutationState = useTamboMutation({
    mutationFn: async ({ suggestion, shouldSubmit = false }) => {
      const validation = validateInput(suggestion.detailedSuggestion);
      if (!validation.isValid) {
        if (validation.error) {
          throw validation.error;
        }
        throw new Error(INPUT_ERROR_MESSAGES.VALIDATION);
      }
      if (shouldSubmit) {
        await sendThreadMessage(validation.sanitizedInput, {
          threadId: thread.id
        });
      } else {
        setInputValue(validation.sanitizedInput);
      }
      setSelectedSuggestionId(suggestion.id);
    }
  });
  const generateMutationState = useTamboMutation({
    mutationFn: async (abortController) => {
      if (!shouldGenerateSuggestions) {
        return void 0;
      }
      const components = getAvailableComponents(componentList, toolRegistry, componentToolAssociations);
      return await tamboClient.beta.threads.suggestions.generate(latestMessageId, {
        id: thread.id,
        maxSuggestions,
        availableComponents: components
      }, { signal: abortController.signal });
    },
    // Don't retry on failure
    retry: false
  });
  const suggestions = isLatestFromTambo ? suggestionsResult.data ?? generateMutationState.data ?? [] : [];
  return {
    suggestions,
    accept: acceptMutationState.mutateAsync,
    selectedSuggestionId,
    acceptResult: acceptMutationState,
    generateResult: generateMutationState,
    suggestionsResult,
    ...combineMutationResults(acceptMutationState, generateMutationState)
  };
}

// node_modules/@tambo-ai/react/esm/hooks/use-tambo-stream-status.js
var import_react21 = __toESM(require_react());
function assertClientSide() {
  if (typeof window === "undefined") {
    throw new Error("useTamboStreamStatus can only be used in browser contexts. This hook is not compatible with SSR/SSG. Consider wrapping it in useEffect or using dynamic imports.");
  }
}
function usePropsStreamingStatus(props, generationStage, messageId) {
  const [propTracking, setPropTracking] = (0, import_react21.useState)({});
  (0, import_react21.useEffect)(() => {
    setPropTracking((prev) => {
      const hasOldMessageData = Object.values(prev).some((track) => track.messageId && track.messageId !== messageId);
      return hasOldMessageData ? {} : prev;
    });
  }, [messageId]);
  (0, import_react21.useEffect)(() => {
    if (!props)
      return;
    setPropTracking((prev) => {
      const updated = { ...prev };
      let hasChanges = false;
      const propsStartingNow = [];
      Object.entries(props).forEach(([key, value]) => {
        const current = prev[key] || {
          hasStarted: false,
          isComplete: false
        };
        const hasContent = value !== void 0 && value !== null && value !== "";
        const justStarted = hasContent && !current.hasStarted;
        if (justStarted) {
          propsStartingNow.push(key);
        }
      });
      Object.entries(props).forEach(([key, value]) => {
        const current = prev[key] || {
          hasStarted: false,
          isComplete: false
        };
        const hasContent = value !== void 0 && value !== null && value !== "";
        const justStarted = hasContent && !current.hasStarted;
        const hasFollowingPropStarted = propsStartingNow.some((startingKey) => startingKey !== key);
        const isGenerationComplete = generationStage === GenerationStage.COMPLETE;
        const isComplete = current.hasStarted && (hasFollowingPropStarted || isGenerationComplete) && !current.isComplete;
        if (current.isComplete && current.messageId === messageId) {
          return;
        }
        if (justStarted || isComplete) {
          updated[key] = {
            ...current,
            hasStarted: justStarted ? true : current.hasStarted,
            isComplete: isComplete ? true : current.isComplete,
            messageId
          };
          hasChanges = true;
        }
      });
      return hasChanges ? updated : prev;
    });
  }, [props, generationStage, messageId]);
  return (0, import_react21.useMemo)(() => {
    if (!props)
      return {};
    const result = {};
    Object.keys(props).forEach((key) => {
      const tracking = propTracking[key] || {
        hasStarted: false,
        isComplete: false,
        messageId: ""
      };
      const isCompleteForThisMessage = tracking.isComplete && tracking.messageId === messageId;
      const isGenerationStreaming = !isCompleteForThisMessage && generationStage === GenerationStage.STREAMING_RESPONSE;
      result[key] = {
        isPending: !tracking.hasStarted && !isCompleteForThisMessage,
        isStreaming: tracking.hasStarted && !isCompleteForThisMessage && isGenerationStreaming,
        isSuccess: isCompleteForThisMessage,
        error: tracking.error
      };
    });
    return result;
  }, [props, propTracking, generationStage, messageId]);
}
function deriveGlobalStreamStatus(generationStage, propStatus, hasComponent, generationError) {
  var _a13;
  const propStatuses = Object.values(propStatus);
  const allPropsSuccessful = propStatuses.length > 0 && propStatuses.every((p) => p.isSuccess);
  const isGenerationStreaming = !allPropsSuccessful && generationStage === GenerationStage.STREAMING_RESPONSE;
  const isGenerationError = generationStage === GenerationStage.ERROR;
  const firstError = generationError ?? ((_a13 = propStatuses.find((p) => p.error)) == null ? void 0 : _a13.error);
  return {
    /** isPending: no component yet OR (has component but no props have started) */
    isPending: !hasComponent || !isGenerationStreaming && !allPropsSuccessful && propStatuses.every((p) => p.isPending),
    /** isStreaming: any prop is streaming (generation stage doesn't matter if props are complete) */
    isStreaming: propStatuses.some((p) => p.isStreaming),
    /** isSuccess: all props successful (component is stable once all props complete) */
    isSuccess: allPropsSuccessful,
    /** isError: generation error OR any prop error */
    isError: isGenerationError || propStatuses.some((p) => p.error) || !!generationError,
    streamError: firstError
  };
}
function useTamboStreamStatus() {
  var _a13;
  assertClientSide();
  const { generationStage } = useTamboGenerationStage();
  const message = useTamboCurrentMessage();
  const componentProps = ((_a13 = message == null ? void 0 : message.component) == null ? void 0 : _a13.props) || {};
  const propStatus = usePropsStreamingStatus(componentProps, generationStage, (message == null ? void 0 : message.id) ?? "");
  const streamStatus = (0, import_react21.useMemo)(() => {
    const generationError = (message == null ? void 0 : message.error) ? new Error(message.error) : void 0;
    const hasComponent = !!(message == null ? void 0 : message.component);
    return deriveGlobalStreamStatus(generationStage, propStatus, hasComponent, generationError);
  }, [generationStage, propStatus, message]);
  return {
    streamStatus,
    propStatus
  };
}

// node_modules/@tambo-ai/react/esm/hooks/use-tambo-voice.js
var import_react22 = __toESM(require_react());
var import_react_media_recorder = __toESM(require_react_media_recorder());
function useTamboVoice() {
  var _a13;
  const [transcript, setTranscript] = (0, import_react22.useState)(null);
  const client = useTamboClient();
  const { status, startRecording: startMediaRecording, stopRecording: stopMediaRecording, mediaBlobUrl, error: mediaAccessError } = (0, import_react_media_recorder.useReactMediaRecorder)({
    audio: true,
    video: false,
    blobPropertyBag: { type: "audio/webm" }
  });
  const isRecording = status === "recording";
  const transcriptionMutation = useTamboMutation({
    mutationFn: async (blobUrl) => {
      const response = await fetch(blobUrl);
      const audioBlob = await response.blob();
      const file2 = new File([audioBlob], "recording.webm", {
        type: "audio/webm"
      });
      return await client.beta.audio.transcribe({ file: file2 });
    },
    onSuccess: (transcription) => {
      setTranscript(transcription);
    }
  });
  const shouldTranscribe = status === "stopped" && mediaBlobUrl && !transcriptionMutation.isPending && !transcriptionMutation.isSuccess;
  (0, import_react22.useEffect)(() => {
    if (shouldTranscribe) {
      transcriptionMutation.mutate(mediaBlobUrl);
    }
  }, [shouldTranscribe, mediaBlobUrl, transcriptionMutation]);
  const startRecording = (0, import_react22.useCallback)(() => {
    if (isRecording)
      return;
    setTranscript(null);
    transcriptionMutation.reset();
    startMediaRecording();
  }, [isRecording, startMediaRecording, transcriptionMutation]);
  const stopRecording = (0, import_react22.useCallback)(() => {
    if (isRecording) {
      stopMediaRecording();
    }
  }, [isRecording, stopMediaRecording]);
  return {
    startRecording,
    stopRecording,
    isRecording,
    mediaAccessError: mediaAccessError === "" ? null : mediaAccessError,
    isTranscribing: transcriptionMutation.isPending,
    transcript,
    transcriptionError: ((_a13 = transcriptionMutation.error) == null ? void 0 : _a13.message) ?? null
  };
}

// node_modules/@tambo-ai/react/esm/providers/tambo-prop-stream-provider/pending.js
var import_react24 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/providers/tambo-prop-stream-provider/provider.js
var import_react23 = __toESM(require_react());

// node_modules/@tambo-ai/react/esm/providers/tambo-prop-stream-provider/types.js
var DEFAULT_STREAM_KEY = "default";

// node_modules/@tambo-ai/react/esm/providers/tambo-prop-stream-provider/provider.js
var TamboPropStreamContext = (0, import_react23.createContext)(null);
var useTamboStream = () => {
  const context = (0, import_react23.useContext)(TamboPropStreamContext);
  if (!context) {
    throw new Error("useTamboStream must be used within a TamboPropStreamProvider");
  }
  return context;
};
var TamboPropStreamProviderComponent = ({ children }) => {
  const { propStatus, streamStatus } = useTamboStreamStatus();
  const keyStatusMap = (0, import_react23.useMemo)(() => {
    const map2 = /* @__PURE__ */ new Map();
    if (propStatus) {
      Object.entries(propStatus).forEach(([key, status]) => {
        map2.set(key, {
          isPending: status.isPending,
          isStreaming: status.isStreaming,
          isSuccess: status.isSuccess,
          isError: !!status.error,
          error: status.error
        });
      });
    }
    map2.set(DEFAULT_STREAM_KEY, {
      isPending: streamStatus.isPending,
      isStreaming: streamStatus.isStreaming,
      isSuccess: streamStatus.isSuccess,
      isError: streamStatus.isError,
      error: streamStatus.streamError
    });
    return map2;
  }, [streamStatus, propStatus]);
  const getStatusForKey = (0, import_react23.useCallback)((key) => {
    const propStatus2 = keyStatusMap.get(key);
    if (propStatus2) {
      return propStatus2;
    }
    return {
      isPending: true,
      isStreaming: false,
      isSuccess: false,
      isError: false
    };
  }, [keyStatusMap]);
  const contextValue = (0, import_react23.useMemo)(() => ({
    streamStatus,
    getStatusForKey
  }), [streamStatus, getStatusForKey]);
  return import_react23.default.createElement(TamboPropStreamContext.Provider, { value: contextValue }, children);
};

// node_modules/@tambo-ai/react/esm/providers/tambo-prop-stream-provider/pending.js
var Pending = ({ streamKey = DEFAULT_STREAM_KEY, children, className }) => {
  const { getStatusForKey } = useTamboStream();
  const status = getStatusForKey(streamKey);
  const hasActiveStatus = status.isStreaming || status.isSuccess || status.isError;
  const shouldShowPending = !hasActiveStatus;
  if (!shouldShowPending) {
    return null;
  }
  return import_react24.default.createElement("div", { className, "data-stream-key": streamKey, "data-stream-state": "pending" }, children);
};
Pending.displayName = "TamboPropStreamProvider.Pending";

// node_modules/@tambo-ai/react/esm/providers/tambo-prop-stream-provider/streaming.js
var import_react25 = __toESM(require_react());
var Streaming = ({ streamKey = DEFAULT_STREAM_KEY, children, className }) => {
  const { getStatusForKey } = useTamboStream();
  const status = getStatusForKey(streamKey);
  if (!status.isPending && !status.isStreaming) {
    return null;
  }
  return import_react25.default.createElement("div", { className, "data-stream-key": streamKey, "data-stream-state": "streaming" }, children);
};
Streaming.displayName = "TamboPropStreamProvider.Streaming";

// node_modules/@tambo-ai/react/esm/providers/tambo-prop-stream-provider/success.js
var import_react26 = __toESM(require_react());
var Success = ({ streamKey = DEFAULT_STREAM_KEY, children, className }) => {
  const { getStatusForKey } = useTamboStream();
  const status = getStatusForKey(streamKey);
  if (!status.isSuccess) {
    return null;
  }
  return import_react26.default.createElement("div", { className, "data-stream-key": streamKey, "data-stream-state": "success" }, children);
};
Success.displayName = "TamboPropStreamProvider.Success";

// node_modules/@tambo-ai/react/esm/providers/tambo-prop-stream-provider/index.js
var TamboPropStreamProvider = Object.assign(TamboPropStreamProviderComponent, {
  Streaming,
  Pending,
  Success
});

// node_modules/@tambo-ai/react/esm/providers/tambo-stubs.js
var import_react27 = __toESM(require_react());
var TamboStubClientProvider = ({ children, client, queryClient, threads, projectId, contextKey, isUpdatingToken }) => {
  (0, import_react27.useEffect)(() => {
    if (threads) {
      queryClient.setQueryData(["projectId"], projectId);
      queryClient.setQueryData(["threads", projectId, contextKey], threads);
    }
  }, [threads, projectId, contextKey, queryClient]);
  return import_react27.default.createElement(TamboClientContext.Provider, { value: {
    client,
    queryClient,
    isUpdatingToken
  } }, children);
};
var TamboStubRegistryProvider = ({ children, componentList, toolRegistry, componentToolAssociations, registerComponent, registerTool, registerTools, addToolAssociation }) => {
  return import_react27.default.createElement(TamboRegistryContext.Provider, { value: {
    componentList,
    toolRegistry,
    componentToolAssociations,
    mcpServerInfos: [],
    resources: [],
    resourceSource: null,
    registerComponent,
    registerTool,
    registerTools,
    addToolAssociation,
    registerMcpServer: () => {
    },
    registerMcpServers: () => {
    },
    registerResource: () => {
    },
    registerResources: () => {
    },
    registerResourceSource: () => {
    }
  } }, children);
};
var TamboStubThreadProvider = ({ children, ...threadContextProps }) => {
  var _a13, _b;
  const generationStage = ((_a13 = threadContextProps.thread) == null ? void 0 : _a13.generationStage) ?? GenerationStage.IDLE;
  const statusMessage = ((_b = threadContextProps.thread) == null ? void 0 : _b.statusMessage) ?? "";
  return import_react27.default.createElement(
    TamboThreadContext.Provider,
    { value: threadContextProps },
    import_react27.default.createElement(TamboGenerationStageProvider, { generationStage, statusMessage }, children)
  );
};
var createDefaultCallbacks = () => ({
  switchCurrentThread: () => {
    throw new Error("switchCurrentThread not implemented in stub");
  },
  startNewThread: () => {
    throw new Error("startNewThread not implemented in stub");
  },
  updateThreadName: () => {
    throw new Error("updateThreadName not implemented in stub");
  },
  generateThreadName: () => {
    throw new Error("generateThreadName not implemented in stub");
  },
  addThreadMessage: () => {
    throw new Error("addThreadMessage not implemented in stub");
  },
  updateThreadMessage: () => {
    throw new Error("updateThreadMessage not implemented in stub");
  },
  setInputValue: () => {
    throw new Error("setInputValue not implemented in stub");
  },
  sendThreadMessage: () => {
    throw new Error("sendThreadMessage not implemented in stub");
  },
  registerComponent: () => {
    throw new Error("registerComponent not implemented in stub");
  },
  registerTool: () => {
    throw new Error("registerTool not implemented in stub");
  },
  registerTools: () => {
    throw new Error("registerTools not implemented in stub");
  },
  addToolAssociation: () => {
    throw new Error("addToolAssociation not implemented in stub");
  },
  cancel: () => {
    throw new Error("cancel not implemented in stub");
  }
});
var TamboStubProvider = ({ children, thread, components = [], tools = [], threads, projectId, contextKey, contextHelpers, ...overrides }) => {
  const defaults = createDefaultCallbacks();
  const stubClient = {};
  const stubQueryClient = new QueryClient();
  const resolvedProjectId = projectId ?? thread.projectId;
  const componentList = components.reduce((acc, component) => {
    acc[component.name] = {
      component: component.component,
      loadingComponent: component.loadingComponent,
      name: component.name,
      description: component.description,
      props: component.propsDefinition ?? {},
      contextTools: []
    };
    return acc;
  }, {});
  const toolRegistry = tools.reduce((acc, tool) => {
    acc[tool.name] = tool;
    return acc;
  }, {});
  const componentToolAssociations = components.reduce((acc, component) => {
    if (component.associatedTools) {
      acc[component.name] = component.associatedTools.map((tool) => tool.name);
    }
    return acc;
  }, {});
  const threadContextProps = {
    thread,
    currentThreadId: thread.id,
    currentThread: thread,
    threadMap: { [thread.id]: thread },
    setThreadMap: () => {
    },
    switchCurrentThread: overrides.switchCurrentThread ?? defaults.switchCurrentThread,
    startNewThread: overrides.startNewThread ?? defaults.startNewThread,
    updateThreadName: overrides.updateThreadName ?? defaults.updateThreadName,
    generateThreadName: overrides.generateThreadName ?? defaults.generateThreadName,
    addThreadMessage: overrides.addThreadMessage ?? defaults.addThreadMessage,
    updateThreadMessage: overrides.updateThreadMessage ?? defaults.updateThreadMessage,
    streaming: overrides.streaming ?? true,
    sendThreadMessage: overrides.sendThreadMessage ?? defaults.sendThreadMessage,
    cancel: overrides.cancel ?? defaults.cancel,
    contextKey
  };
  const componentContextProps = {
    registerComponent: overrides.registerComponent ?? defaults.registerComponent,
    registerTool: overrides.registerTool ?? defaults.registerTool,
    registerTools: overrides.registerTools ?? defaults.registerTools,
    addToolAssociation: overrides.addToolAssociation ?? defaults.addToolAssociation
  };
  return import_react27.default.createElement(
    TamboStubClientProvider,
    { client: stubClient, queryClient: stubQueryClient, threads, projectId: resolvedProjectId, contextKey, isUpdatingToken: false },
    import_react27.default.createElement(
      TamboStubRegistryProvider,
      { componentList, toolRegistry, componentToolAssociations, registerComponent: componentContextProps.registerComponent, registerTool: componentContextProps.registerTool, registerTools: componentContextProps.registerTools, addToolAssociation: componentContextProps.addToolAssociation },
      import_react27.default.createElement(
        TamboStubThreadProvider,
        { ...threadContextProps },
        import_react27.default.createElement(
          TamboContextHelpersProvider,
          { contextHelpers },
          import_react27.default.createElement(
            TamboContextAttachmentProvider,
            null,
            import_react27.default.createElement(
              TamboComponentProvider,
              null,
              import_react27.default.createElement(
                TamboInteractableProvider,
                null,
                import_react27.default.createElement(TamboCompositeProvider, null, children)
              )
            )
          )
        )
      )
    )
  );
};

// node_modules/@tambo-ai/react/esm/hoc/with-tambo-interactable.js
var import_react28 = __toESM(require_react());
function withTamboInteractable(WrappedComponent, config2) {
  const displayName = WrappedComponent.displayName ?? WrappedComponent.name ?? "Component";
  const TamboInteractableWrapper = (props) => {
    const { addInteractableComponent, updateInteractableComponentProps, getInteractableComponent } = useTamboInteractable();
    const [interactableId, setInteractableId] = (0, import_react28.useState)(null);
    const isInitialized = (0, import_react28.useRef)(false);
    const lastSerializedProps = (0, import_react28.useRef)({});
    const {
      interactableId: _providedId,
      // Reserved for future use
      onInteractableReady,
      onPropsUpdate,
      ...componentProps
    } = props;
    const currentInteractable = interactableId ? getInteractableComponent(interactableId) : null;
    const effectiveProps = (currentInteractable == null ? void 0 : currentInteractable.props) ?? componentProps;
    const registerComponent = (0, import_react28.useCallback)(() => {
      if (!isInitialized.current) {
        const id = addInteractableComponent({
          name: config2.componentName,
          description: config2.description,
          component: WrappedComponent,
          props: componentProps,
          propsSchema: config2.propsSchema,
          stateSchema: config2.stateSchema
        });
        setInteractableId(id);
        onInteractableReady == null ? void 0 : onInteractableReady(id);
        isInitialized.current = true;
      }
    }, [addInteractableComponent, componentProps, onInteractableReady]);
    (0, import_react28.useEffect)(() => {
      registerComponent();
    }, [registerComponent]);
    (0, import_react28.useEffect)(() => {
      if (interactableId && isInitialized.current) {
        const lastPropsString = JSON.stringify(lastSerializedProps.current);
        const currentPropsString = JSON.stringify(componentProps);
        if (lastPropsString !== currentPropsString) {
          updateInteractableComponentProps(interactableId, componentProps);
          onPropsUpdate == null ? void 0 : onPropsUpdate(componentProps);
          lastSerializedProps.current = componentProps;
        }
      }
    }, [
      interactableId,
      componentProps,
      updateInteractableComponentProps,
      onPropsUpdate
    ]);
    if (!interactableId) {
      return import_react28.default.createElement(WrappedComponent, { ...effectiveProps });
    }
    const minimalMessage = {
      id: interactableId,
      role: "assistant",
      content: [],
      threadId: "",
      createdAt: (/* @__PURE__ */ new Date()).toISOString(),
      component: {
        componentName: config2.componentName,
        componentState: {},
        message: "",
        props: effectiveProps
      },
      componentState: {}
    };
    return import_react28.default.createElement(
      TamboMessageProvider,
      { message: minimalMessage, interactableMetadata: {
        id: interactableId,
        componentName: config2.componentName,
        description: config2.description
      } },
      import_react28.default.createElement(WrappedComponent, { ...effectiveProps })
    );
  };
  TamboInteractableWrapper.displayName = `withTamboInteractable(${displayName})`;
  return TamboInteractableWrapper;
}

// node_modules/@tambo-ai/react/esm/hooks/use-tambo-threads.js
function useTamboThreadList({ projectId } = {}, options = {}) {
  const client = useTamboClient();
  const { contextKey } = useTamboThread();
  const { data: queriedProjectId, ...projectIdState } = useTamboQuery({
    ...options,
    queryKey: ["projectId"],
    queryFn: async () => {
      return (await client.beta.projects.getCurrent()).id;
    }
  });
  const currentProjectId = projectId ?? queriedProjectId;
  const threadState = useTamboQuery({
    ...options,
    enabled: !!currentProjectId,
    queryKey: ["threads", currentProjectId, contextKey],
    queryFn: async () => {
      if (!currentProjectId) {
        return null;
      }
      const threadIter = await client.beta.threads.list(currentProjectId, {
        contextKey
      });
      return threadIter;
    }
  });
  return currentProjectId ? threadState : { data: null, ...projectIdState };
}

// node_modules/@tambo-ai/react/esm/context-helpers/current-page-context-helper.js
var currentPageContextHelper = () => {
  try {
    if (typeof window === "undefined") {
      return null;
    }
    return {
      url: window.location.href,
      title: document.title
    };
  } catch (e2) {
    console.error("prebuiltUserPage failed:", e2);
    return null;
  }
};

// node_modules/@tambo-ai/react/esm/context-helpers/current-time-context-helper.js
var currentTimeContextHelper = () => {
  try {
    const now = /* @__PURE__ */ new Date();
    return {
      timestamp: now.toString()
    };
  } catch (e2) {
    console.error("prebuiltUserTime failed:", e2);
    return null;
  }
};
export {
  GenerationStage,
  MCPTransport,
  TamboClientProvider,
  TamboComponentProvider,
  TamboContextAttachmentProvider,
  TamboContextHelpersProvider,
  TamboMessageProvider,
  TamboPropStreamProvider,
  TamboProvider,
  TamboRegistryProvider,
  TamboStubProvider,
  TamboThreadInputProvider,
  TamboThreadProvider,
  currentPageContextHelper,
  currentTimeContextHelper,
  defineTool,
  useCurrentInteractablesSnapshot,
  useIsTamboTokenUpdating,
  useMessageImages,
  useTambo,
  useTamboClient,
  useTamboComponentState,
  useTamboContextAttachment,
  useTamboContextHelpers,
  useTamboCurrentComponent,
  useTamboCurrentMessage,
  useTamboGenerationStage,
  useTamboInteractable,
  useTamboMcpServerInfos,
  useTamboStream,
  useTamboStreamStatus,
  useTamboStreamingProps,
  useTamboSuggestions,
  useTamboThread,
  useTamboThreadInput,
  useTamboThreadList,
  useTamboVoice,
  withTamboInteractable as withInteractable
};
/*! Bundled license information:

dashify/index.js:
  (*!
   * dashify <https://github.com/jonschlinkert/dashify>
   *
   * Copyright (c) 2015-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)
*/
//# sourceMappingURL=@tambo-ai_react.js.map
